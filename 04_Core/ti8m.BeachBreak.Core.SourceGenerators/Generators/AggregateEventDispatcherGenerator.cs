using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace ti8m.BeachBreak.Core.SourceGenerators.Generators;

/// <summary>
/// Roslyn source generator that discovers AggregateRoot classes and their Apply methods
/// and generates AOT-safe event dispatch methods to replace ReflectionMagic usage.
/// </summary>
[Generator]
public class AggregateEventDispatcherGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Always generate a basic diagnostic file to verify the generator runs
        context.RegisterPostInitializationOutput(static ctx =>
        {
            var sourceText = @"
// <auto-generated />
// This file is generated to verify AggregateEventDispatcherGenerator is executing
namespace ti8m.BeachBreak.Core.Domain.Generated;

/// <summary>
/// Diagnostic to verify AggregateEventDispatcherGenerator execution.
/// </summary>
public static class AggregateEventDispatcherExecutionTest
{
    public static string GetMessage() => ""AggregateEventDispatcherGenerator is executing"";
    public static System.DateTime ExecutionTime => new System.DateTime(2026, 1, 18, 16, 45, 0);
}
";
            ctx.AddSource("AggregateEventDispatcherExecutionTest.g.cs", sourceText);
        });

        // Step 1: Find all classes that inherit from AggregateRoot
        var aggregateRoots = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetAggregateRootInfo(ctx))
            .Where(static result => result is not null)
            .Select(static (result, _) => result!);

        // Step 2: Generate partial classes with ApplyEvent methods
        context.RegisterSourceOutput(aggregateRoots.Collect(), static (ctx, aggregateInfos) =>
        {
            foreach (var aggregateInfo in aggregateInfos)
            {
                var source = GeneratePartialClass(aggregateInfo);
                ctx.AddSource($"{aggregateInfo.ClassName}.EventDispatcher.g.cs", source);
            }
        });
    }

    private static AggregateInfo? GetAggregateRootInfo(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        // Get the type symbol for this class
        var typeSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);
        if (typeSymbol is null)
            return null;

        // Check if this class inherits from AggregateRoot
        if (!InheritsFromAggregateRoot(typeSymbol))
            return null;

        // Get all Apply methods that take IDomainEvent parameters
        var applyMethods = typeSymbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => m.Name == "Apply" &&
                       m.Parameters.Length == 1 &&
                       m.ReturnType.SpecialType == SpecialType.System_Void &&
                       ImplementsIDomainEvent(m.Parameters[0].Type))
            .Select(m => new ApplyMethodInfo(
                m.Name,
                m.Parameters[0].Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)))
            .ToImmutableArray();

        if (applyMethods.IsEmpty)
            return null;

        return new AggregateInfo(
            typeSymbol.Name,
            typeSymbol.ContainingNamespace.ToDisplayString(),
            applyMethods);
    }

    private static bool InheritsFromAggregateRoot(INamedTypeSymbol typeSymbol)
    {
        var baseType = typeSymbol.BaseType;
        while (baseType is not null)
        {
            if (baseType.Name == "AggregateRoot" &&
                baseType.ContainingNamespace.ToDisplayString() == "ti8m.BeachBreak.Core.Domain.BuildingBlocks")
            {
                return true;
            }
            baseType = baseType.BaseType;
        }
        return false;
    }

    private static bool ImplementsIDomainEvent(ITypeSymbol typeSymbol)
    {
        // Check if the type implements IDomainEvent interface
        return typeSymbol.AllInterfaces.Any(i =>
            i.Name == "IDomainEvent" &&
            i.ContainingNamespace.ToDisplayString() == "ti8m.BeachBreak.Core.Domain.BuildingBlocks");
    }

    private static string GeneratePartialClass(AggregateInfo aggregateInfo)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine($"// Generated ApplyEvent dispatcher for {aggregateInfo.ClassName}");
        sb.AppendLine("using ti8m.BeachBreak.Core.Domain.BuildingBlocks;");
        sb.AppendLine();
        sb.AppendLine($"namespace {aggregateInfo.Namespace};");
        sb.AppendLine();
        sb.AppendLine($"public partial class {aggregateInfo.ClassName}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// AOT-safe event dispatcher that replaces ReflectionMagic usage.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    protected override void ApplyEvent(IDomainEvent @event)");
        sb.AppendLine("    {");
        sb.AppendLine("        switch (@event)");
        sb.AppendLine("        {");

        foreach (var applyMethod in aggregateInfo.ApplyMethods)
        {
            // Use the full type name for type-safe switch
            var fullTypeName = applyMethod.ParameterType.Replace("global::", "");
            sb.AppendLine($"            case {fullTypeName} evt:");
            sb.AppendLine($"                Apply(evt);");
            sb.AppendLine($"                break;");
        }

        sb.AppendLine("            default:");
        sb.AppendLine("                throw new System.ArgumentException($\"Unknown event type: {@event.GetType().Name}\", nameof(@event));");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }


    private sealed class AggregateInfo
    {
        public string ClassName { get; }
        public string Namespace { get; }
        public ImmutableArray<ApplyMethodInfo> ApplyMethods { get; }

        public AggregateInfo(string className, string @namespace, ImmutableArray<ApplyMethodInfo> applyMethods)
        {
            ClassName = className;
            Namespace = @namespace;
            ApplyMethods = applyMethods;
        }
    }

    private sealed class ApplyMethodInfo
    {
        public string MethodName { get; }
        public string ParameterType { get; }

        public ApplyMethodInfo(string methodName, string parameterType)
        {
            MethodName = methodName;
            ParameterType = parameterType;
        }
    }
}