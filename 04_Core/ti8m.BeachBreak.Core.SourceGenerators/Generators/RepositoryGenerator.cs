using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using ti8m.BeachBreak.Core.SourceGenerators.Models;

namespace ti8m.BeachBreak.Core.SourceGenerators.Generators;

/// <summary>
/// Roslyn source generator that discovers IRepository implementations
/// and generates a high-performance registration using explicit DI registrations to replace Scrutor-based scanning.
/// </summary>
[Generator]
public class RepositoryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Check if this is an Infrastructure project by looking for repository implementations
        var isInfrastructureProject = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsRepositoryCandidate(s),
                transform: static (ctx, _) => IsRepositoryImplementation(ctx))
            .Where(static result => result)
            .Collect()
            .Select(static (results, _) => results.Any());

        // Always generate a basic diagnostic file to verify the generator runs
        context.RegisterPostInitializationOutput(static ctx =>
        {
            var sourceText = @"
// <auto-generated />
// This file is generated to verify RepositoryGenerator is executing
namespace ti8m.BeachBreak.Infrastructure.Generated;

/// <summary>
/// Basic diagnostic to verify source generator execution.
/// </summary>
public static class RepositoryGeneratorExecutionTest
{
    public static string GetMessage() => ""RepositoryGenerator is executing"";
    public static System.DateTime ExecutionTime => new System.DateTime(2026, 1, 17, 22, 38, 0);
}
";
            ctx.AddSource("RepositoryGeneratorExecutionTest.g.cs", sourceText);
        });

        // Step 1: Find all IRepository implementations
        var repositories = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsRepositoryCandidate(s),
                transform: static (ctx, _) => ExtractRepositoryInfo(ctx))
            .Where(static m => m is not null)
            .Select(static (m, _) => m!);

        // Step 2: Combine and generate (only if this is an Infrastructure project)
        var combined = repositories.Collect().Combine(isInfrastructureProject);

        // Generate diagnostic info first (only for projects with repositories)
        context.RegisterSourceOutput(combined, static (spc, source) =>
        {
            var (repos, isInfra) = source;
            if (repos.Any())
            {
                GenerateRepositoryDiagnosticInfo(spc, repos);
            }
        });

        // Generate repository registrations (only for projects with repositories)
        context.RegisterSourceOutput(combined, static (spc, source) =>
        {
            var (repos, isInfra) = source;
            if (repos.Any())
            {
                GenerateRepositoryRegistrations(spc, repos);
            }
        });
    }

    /// <summary>
    /// Identifies syntax nodes that might be repository classes implementing IRepository interface.
    /// </summary>
    private static bool IsRepositoryCandidate(SyntaxNode node)
    {
        // Look for class declarations that might implement IRepository
        return node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 };
    }

    /// <summary>
    /// Checks if this is a repository implementation (not just interface).
    /// </summary>
    private static bool IsRepositoryImplementation(GeneratorSyntaxContext context)
    {
        if (context.Node is ClassDeclarationSyntax classDecl)
        {
            var semanticModel = context.SemanticModel;
            if (semanticModel.GetDeclaredSymbol(classDecl) is INamedTypeSymbol classSymbol)
            {
                // Check if it implements any interface that inherits from IRepository
                return classSymbol.AllInterfaces.Any(i =>
                    i.AllInterfaces.Any(baseInterface => baseInterface.Name == "IRepository") ||
                    i.Name == "IRepository");
            }
        }
        return false;
    }

    /// <summary>
    /// Extracts repository metadata from a class that implements IRepository interface.
    /// </summary>
    private static RepositoryInfo? ExtractRepositoryInfo(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        if (semanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol)
            return null;

        // Find interface that inherits from IRepository
        var repositoryInterface = classSymbol.AllInterfaces
            .FirstOrDefault(i =>
                i.AllInterfaces.Any(baseInterface => baseInterface.Name == "IRepository") ||
                i.Name == "IRepository");

        if (repositoryInterface == null)
            return null;

        // Skip if this is the base IRepository interface itself
        if (repositoryInterface.Name == "IRepository")
            return null;

        // Check if class is internal
        var isInternal = classSymbol.DeclaredAccessibility == Accessibility.Internal;

        return new RepositoryInfo(
            classSymbol.Name,
            classSymbol.ToDisplayString(),
            repositoryInterface.ToDisplayString(),
            classSymbol.ContainingNamespace.ToDisplayString(),
            isInternal
        );
    }

    /// <summary>
    /// Generates the dependency injection registration class to replace Scrutor-based repository scanning.
    /// </summary>
    private static void GenerateRepositoryRegistrations(SourceProductionContext context, ImmutableArray<RepositoryInfo> repositories)
    {
        if (!repositories.Any())
        {
            // Generate a stub registration for debugging
            var stubRegistration = @"// <auto-generated />
// No repositories discovered - GeneratedRepositoryRegistrations stub for debugging
#nullable enable
using Microsoft.Extensions.DependencyInjection;

namespace ti8m.BeachBreak.Infrastructure.Generated;

/// <summary>
/// Stub repository registrations - no repositories were discovered by source generator.
/// </summary>
public static class GeneratedRepositoryRegistrations
{
    public static IServiceCollection AddGeneratedRepositories(this IServiceCollection services)
    {
        // No repositories discovered - source generator found 0 IRepository implementations
        return services;
    }
}
";
            context.AddSource("RepositoryRegistrations.g.cs", stubRegistration);
            return;
        }

        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// This file was generated by ti8m.BeachBreak.Core.SourceGenerators.RepositoryGenerator");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();

        // Add using statements for all repository namespaces
        var repositoryNamespaces = repositories.Select(r => r.Namespace).Distinct().OrderBy(ns => ns);
        foreach (var ns in repositoryNamespaces)
        {
            sb.AppendLine($"using {ns};");
        }
        sb.AppendLine();

        sb.AppendLine("namespace ti8m.BeachBreak.Infrastructure.Generated;");
        sb.AppendLine();

        // Class declaration
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Generated dependency injection registrations for all repositories.");
        sb.AppendLine($"/// Registers {repositories.Length} repository classes implementing {repositories.Length} interfaces.");
        sb.AppendLine("/// Replaces Scrutor-based scanning with explicit, compile-time registrations.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class GeneratedRepositoryRegistrations");
        sb.AppendLine("{");
        sb.AppendLine("    public static IServiceCollection AddGeneratedRepositories(this IServiceCollection services)");
        sb.AppendLine("    {");

        // Register repositories
        foreach (var repo in repositories.OrderBy(r => r.TypeName))
        {
            sb.AppendLine($"        // {repo.TypeName} -> {repo.InterfaceType}");
            sb.AppendLine($"        services.AddScoped<{repo.InterfaceType}, {repo.FullTypeName}>();");
            sb.AppendLine();
        }

        sb.AppendLine("        return services;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource("RepositoryRegistrations.g.cs", sb.ToString());
    }

    /// <summary>
    /// Generates diagnostic information about discovered repositories to help debug the source generator.
    /// </summary>
    private static void GenerateRepositoryDiagnosticInfo(SourceProductionContext context, ImmutableArray<RepositoryInfo> repositories)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// This file contains diagnostic information from RepositoryGenerator");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        sb.AppendLine("namespace ti8m.BeachBreak.Infrastructure.Generated;");
        sb.AppendLine();

        // Diagnostic class
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Diagnostic information about discovered repositories.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class RepositoryGeneratorDiagnostics");
        sb.AppendLine("{");
        sb.AppendLine($"    public static int RepositoryCount => {repositories.Length};");
        sb.AppendLine("    public static System.DateTime GeneratedAt => new System.DateTime(2026, 1, 17, 22, 30, 0);");
        sb.AppendLine();

        // List discovered repositories
        sb.AppendLine("    public static string[] DiscoveredRepositories => new string[]");
        sb.AppendLine("    {");
        foreach (var repo in repositories.OrderBy(r => r.TypeName))
        {
            var visibility = repo.IsInternal ? "internal" : "public";
            sb.AppendLine($"        \"{repo.TypeName} ({visibility}) -> {repo.InterfaceType} (namespace: {repo.Namespace})\",");
        }
        if (!repositories.Any())
        {
            sb.AppendLine("        // No repositories discovered - check if IRepository interfaces are being detected properly");
        }
        sb.AppendLine("    };");

        sb.AppendLine("}");

        // ALWAYS generate this file for debugging, even if no repositories found
        context.AddSource("RepositoryGeneratorDiagnostics.g.cs", sb.ToString());
    }
}