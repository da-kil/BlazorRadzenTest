@using Microsoft.AspNetCore.Components
@using Radzen
@using Radzen.Blazor
@using ti8m.BeachBreak.Client.Models.Dto
@using ti8m.BeachBreak.Client.Components.Shared
@using ti8m.BeachBreak.Client.Services
@inject IEmployeeFeedbackApiService FeedbackService
@inherits OptimizedTranslatableComponentBase

<div class="feedback-source-selector">
    <RadzenText TextStyle="TextStyle.H6" Class="mb-3">
        @T("sections.feedback-source")
    </RadzenText>

    @if (sourceTypeOptions.Any())
    {
        <div class="source-type-radio-group">
            @foreach (var option in sourceTypeOptions)
            {
                <div class="radio-option">
                    <input type="radio"
                           name="sourceType"
                           id="source_@option.Value"
                           value="@option.Value"
                           checked="@(selectedSourceType == option.Value)"
                           @onchange="@(() => HandleSourceTypeChanged(option.Value))" />
                    <label for="source_@option.Value">
                        <div class="radio-label-main">@option.DisplayName</div>
                        <div class="radio-label-description">@option.Description</div>
                    </label>
                </div>
            }
        </div>
    }
</div>

@code {
    [Parameter] public int? SelectedSourceType { get; set; }
    [Parameter] public EventCallback<int?> SelectedSourceTypeChanged { get; set; }
    [Parameter] public EventCallback<int?> OnSourceTypeSelection { get; set; }
    [Parameter] public EventCallback<int?> OnSourceTypeChanged { get; set; }

    private int? selectedSourceType;
    private List<SourceTypeOption> sourceTypeOptions = new();

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        selectedSourceType = SelectedSourceType;
        // Try to load from API first, fallback only if needed
        await LoadSourceTypeOptions();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (selectedSourceType != SelectedSourceType)
        {
            selectedSourceType = SelectedSourceType;
            StateHasChanged();
        }
    }

    private void InitializeFallbackOptions()
    {
        // Initialize with hardcoded source types as fallback when backend is unavailable
        sourceTypeOptions = new List<SourceTypeOption>
        {
            new SourceTypeOption
            {
                Value = 0,
                DisplayName = T("source-types.customer.name"),
                Description = T("source-types.customer.description"),
                RequiresProjectContext = false,
                RequiresProviderRole = false
            },
            new SourceTypeOption
            {
                Value = 1,
                DisplayName = T("source-types.peer.name"),
                Description = T("source-types.peer.description"),
                RequiresProjectContext = false,
                RequiresProviderRole = true
            },
            new SourceTypeOption
            {
                Value = 2,
                DisplayName = T("source-types.project-colleague.name"),
                Description = T("source-types.project-colleague.description"),
                RequiresProjectContext = true,
                RequiresProviderRole = true
            }
        };
    }

    private async Task LoadSourceTypeOptions()
    {
        try
        {
            // Try to load source types from backend
            var result = await FeedbackService.GetSourceTypeOptionsAsync();

            if (result.Succeeded && result.Payload?.SourceTypeOptions?.Any() == true)
            {
                // Backend returns options with empty DisplayName/Description (expects frontend to translate)
                // So we populate the translations here
                sourceTypeOptions = result.Payload.SourceTypeOptions.Select(opt => new SourceTypeOption
                {
                    Value = opt.Value,
                    DisplayName = GetTranslatedName(opt.Value),
                    Description = GetTranslatedDescription(opt.Value),
                    RequiresProjectContext = opt.RequiresProjectContext,
                    RequiresProviderRole = opt.RequiresProviderRole
                }).ToList();
            }
            else
            {
                // Backend returned no options - use fallback
                InitializeFallbackOptions();
            }

            StateHasChanged();
        }
        catch (Exception)
        {
            // On any exception, use fallback
            // This ensures the component still works even if backend is unavailable
            InitializeFallbackOptions();
            StateHasChanged();
        }
    }

    private string GetTranslatedName(int sourceType)
    {
        return sourceType switch
        {
            0 => T("source-types.customer.name"),
            1 => T("source-types.peer.name"),
            2 => T("source-types.project-colleague.name"),
            _ => $"Source Type {sourceType}"
        };
    }

    private string GetTranslatedDescription(int sourceType)
    {
        return sourceType switch
        {
            0 => T("source-types.customer.description"),
            1 => T("source-types.peer.description"),
            2 => T("source-types.project-colleague.description"),
            _ => ""
        };
    }

    private async Task HandleSourceTypeChanged(int? value)
    {
        selectedSourceType = value;

        // Notify parent components
        if (SelectedSourceTypeChanged.HasDelegate)
        {
            await SelectedSourceTypeChanged.InvokeAsync(value);
        }

        if (OnSourceTypeSelection.HasDelegate)
        {
            await OnSourceTypeSelection.InvokeAsync(value);
        }

        if (OnSourceTypeChanged.HasDelegate)
        {
            await OnSourceTypeChanged.InvokeAsync(value);
        }
    }
}

<style>
    .source-type-radio-group {
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }

    .radio-option {
        display: flex;
        align-items: flex-start;
        gap: 0.75rem;
    }

    .radio-option input[type="radio"] {
        margin-top: 0.25rem;
        flex-shrink: 0;
        cursor: pointer;
    }

    .radio-option label {
        cursor: pointer;
        user-select: none;
        flex: 1;
    }

    .radio-label-main {
        font-weight: 500;
        margin-bottom: 0.25rem;
    }

    .radio-label-description {
        font-size: 0.875rem;
        color: var(--rz-text-secondary-color, #666);
        line-height: 1.4;
    }
</style>