@using Microsoft.AspNetCore.Components
@using Radzen
@using Radzen.Blazor
@using ti8m.BeachBreak.Client.Models.Dto
@using ti8m.BeachBreak.Client.Components.Shared
@using ti8m.BeachBreak.Client.Services
@inject IEmployeeFeedbackApiService FeedbackService
@inherits OptimizedTranslatableComponentBase

<div class="feedback-source-selector">
    <RadzenText TextStyle="TextStyle.H6" Class="mb-3">
        @T("sections.feedback-source")
    </RadzenText>

    @if (sourceTypeOptions.Any())
    {
        <div class="source-type-radio-group">
            @foreach (var option in sourceTypeOptions)
            {
                <div class="radio-option">
                    <input type="radio"
                           name="sourceType"
                           id="source_@option.Value"
                           value="@option.Value"
                           checked="@(selectedSourceType == option.Value)"
                           @onchange="@(() => HandleSourceTypeChanged(option.Value))" />
                    <label for="source_@option.Value">@GetOptionDisplay(option)</label>
                </div>
            }
        </div>

        <!-- Source Type Details -->
        @if (selectedSourceType.HasValue)
        {
            var selectedOption = sourceTypeOptions.FirstOrDefault(o => o.Value == selectedSourceType.Value);
            if (selectedOption != null)
            {
                <RadzenCard Class="mt-3" Style="background-color: var(--rz-base-50);">
                    <RadzenText TextStyle="TextStyle.Body2" Class="mb-2">
                        <strong>@T("labels.selected-source"):</strong> @selectedOption.DisplayName
                    </RadzenText>
                    <RadzenText TextStyle="TextStyle.Body2" Class="text-muted">
                        @selectedOption.Description
                    </RadzenText>

                    @if (selectedOption.RequiresProjectContext || selectedOption.RequiresProviderRole)
                    {
                        <div class="mt-2">
                            <RadzenText TextStyle="TextStyle.Body2" Class="text-info">
                                <RadzenIcon Icon="info" Class="me-1" />
                                @T("labels.additional-requirements"):
                            </RadzenText>
                            <ul class="requirements-list">
                                @if (selectedOption.RequiresProviderRole)
                                {
                                    <li>@T("requirements.provider-role-required")</li>
                                }
                                @if (selectedOption.RequiresProjectContext)
                                {
                                    <li>@T("requirements.project-context-required")</li>
                                }
                            </ul>
                        </div>
                    }
                </RadzenCard>
            }
        }
    }
    else
    {
        <RadzenProgressBar Mode="ProgressBarMode.Indeterminate" />
    }
</div>

@code {
    [Parameter] public int? SelectedSourceType { get; set; }
    [Parameter] public EventCallback<int?> SelectedSourceTypeChanged { get; set; }
    [Parameter] public EventCallback<int?> OnSourceTypeSelection { get; set; }
    [Parameter] public EventCallback<int?> OnSourceTypeChanged { get; set; }

    private int? selectedSourceType;
    private List<SourceTypeOption> sourceTypeOptions = new();

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        selectedSourceType = SelectedSourceType;
        // Try to load from API first, fallback only if needed
        await LoadSourceTypeOptions();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (selectedSourceType != SelectedSourceType)
        {
            selectedSourceType = SelectedSourceType;
            StateHasChanged();
        }
    }

    private void InitializeFallbackOptions()
    {
        // Initialize with hardcoded source types as fallback when backend is unavailable
        sourceTypeOptions = new List<SourceTypeOption>
        {
            new SourceTypeOption
            {
                Value = 0,
                DisplayName = T("source-types.customer.name"),
                Description = T("source-types.customer.description"),
                RequiresProjectContext = false,
                RequiresProviderRole = false
            },
            new SourceTypeOption
            {
                Value = 1,
                DisplayName = T("source-types.peer.name"),
                Description = T("source-types.peer.description"),
                RequiresProjectContext = false,
                RequiresProviderRole = true
            },
            new SourceTypeOption
            {
                Value = 2,
                DisplayName = T("source-types.project-colleague.name"),
                Description = T("source-types.project-colleague.description"),
                RequiresProjectContext = true,
                RequiresProviderRole = true
            }
        };
    }

    private async Task LoadSourceTypeOptions()
    {
        try
        {
            // Try to load source types from backend
            var result = await FeedbackService.GetSourceTypeOptionsAsync();

            if (result.Succeeded && result.Payload?.SourceTypeOptions?.Any() == true)
            {
                // Backend returns options with empty DisplayName/Description (expects frontend to translate)
                // So we populate the translations here
                sourceTypeOptions = result.Payload.SourceTypeOptions.Select(opt => new SourceTypeOption
                {
                    Value = opt.Value,
                    DisplayName = GetTranslatedName(opt.Value),
                    Description = GetTranslatedDescription(opt.Value),
                    RequiresProjectContext = opt.RequiresProjectContext,
                    RequiresProviderRole = opt.RequiresProviderRole
                }).ToList();
            }
            else
            {
                // Backend returned no options - use fallback
                InitializeFallbackOptions();
            }

            StateHasChanged();
        }
        catch (Exception)
        {
            // On any exception, use fallback
            // This ensures the component still works even if backend is unavailable
            InitializeFallbackOptions();
            StateHasChanged();
        }
    }

    private string GetTranslatedName(int sourceType)
    {
        return sourceType switch
        {
            0 => T("source-types.customer.name"),
            1 => T("source-types.peer.name"),
            2 => T("source-types.project-colleague.name"),
            _ => $"Source Type {sourceType}"
        };
    }

    private string GetTranslatedDescription(int sourceType)
    {
        return sourceType switch
        {
            0 => T("source-types.customer.description"),
            1 => T("source-types.peer.description"),
            2 => T("source-types.project-colleague.description"),
            _ => ""
        };
    }

    private async Task HandleSourceTypeChanged(int? value)
    {
        selectedSourceType = value;

        // Notify parent components
        if (SelectedSourceTypeChanged.HasDelegate)
        {
            await SelectedSourceTypeChanged.InvokeAsync(value);
        }

        if (OnSourceTypeSelection.HasDelegate)
        {
            await OnSourceTypeSelection.InvokeAsync(value);
        }

        if (OnSourceTypeChanged.HasDelegate)
        {
            await OnSourceTypeChanged.InvokeAsync(value);
        }
    }

    private string GetOptionDisplay(SourceTypeOption option)
    {
        var display = $"{option.DisplayName} - {option.Description}";

        if (option.RequiresProjectContext || option.RequiresProviderRole)
        {
            var requirements = new List<string>();
            if (option.RequiresProviderRole) requirements.Add(T("labels.role-required"));
            if (option.RequiresProjectContext) requirements.Add(T("labels.project-required"));

            display += $" ({string.Join(", ", requirements)})";
        }

        return display;
    }
}

<style>
    .source-type-radio-group {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }

    .radio-option {
        display: flex;
        align-items: flex-start;
        gap: 0.5rem;
    }

    .radio-option input[type="radio"] {
        margin-top: 0.25rem;
        flex-shrink: 0;
        cursor: pointer;
    }

    .radio-option label {
        cursor: pointer;
        user-select: none;
    }
</style>