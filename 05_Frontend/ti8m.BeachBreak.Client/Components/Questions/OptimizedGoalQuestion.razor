@using Radzen.Blazor
@using ti8m.BeachBreak.Client.Models
@using ti8m.BeachBreak.Client.Models.Dto
@using ti8m.BeachBreak.Client.Components.Shared
@using ti8m.BeachBreak.Client.Components.Dialogs
@using ti8m.BeachBreak.Client.Services
@using ti8m.BeachBreak.Client.Extensions
@inject GoalService GoalService
@inject IGoalApiService GoalApiService
@inject DialogService DialogService
@inject NotificationService NotificationService
@inject IAuthService AuthService
@inherits OptimizedComponentBase

@if (!HideHeader)
{
    <RadzenCard Class="goal-question">
        <RadzenText TextStyle="TextStyle.H5" Class="text-primary mb-3">
            <RadzenIcon Icon="flag" Class="me-2" />
            @Question.Title
            @if (Question.IsRequired) { <span class="text-danger">*</span> }
            <EditedDuringReviewBadge Response="@Response" />
        </RadzenText>

        @if (!string.IsNullOrWhiteSpace(Question.Description))
        {
            <RadzenText TextStyle="TextStyle.Body1" Class="mb-4">@Question.Description</RadzenText>
        }

        @RenderGoalContent()
    </RadzenCard>
}
else
{
    @RenderGoalContent()
}

@code {
    private RenderFragment RenderGoalContent() => __builder =>
    {
        <div class="goal-content">
            @* Predecessor Ratings Section *@
            @if (hasPredecessor)
            {
                <RadzenAlert AlertStyle="AlertStyle.Info" Class="mb-4" ShowIcon="true">
                    <RadzenText TextStyle="TextStyle.Body2">
                        <strong>Predecessor Linked:</strong> Previous questionnaire goals are available for rating.
                    </RadzenText>
                </RadzenAlert>

                <RadzenFieldset Class="mb-4">
                    <HeaderTemplate>
                        <RadzenIcon Icon="assessment" Class="me-2" />
                        <span class="fw-bold">Rate Previous Goals</span>
                    </HeaderTemplate>
                    <ChildContent>
                        @if (!predecessorRatings.Any())
                        {
                            <RadzenAlert AlertStyle="AlertStyle.Warning" Variant="Variant.Flat" Class="mb-3">
                                <RadzenText TextStyle="TextStyle.Body2">
                                    No predecessor goals available for rating.
                                </RadzenText>
                            </RadzenAlert>
                        }
                        else
                        {
                            @foreach (var rating in predecessorRatings)
                            {
                                <div class="predecessor-rating-card mb-3 p-3 border rounded" @key="@rating[GoalService.RatingSourceGoalIdKey]">
                                    @RenderPredecessorRating(rating)
                                </div>
                            }
                        }
                    </ChildContent>
                </RadzenFieldset>
            }
            else if (!IsReadOnly && !IsInReviewPhase())
            {
                @* Link Predecessor Section - Only show if no predecessor linked, not read-only, and not in review phase *@
                <RadzenAlert AlertStyle="AlertStyle.Info" Class="mb-4" ShowIcon="true">
                    <RadzenText TextStyle="TextStyle.Body2" Class="mb-2">
                        <strong>Link Previous Questionnaire:</strong> Link a predecessor questionnaire to rate goals from a previous period.
                    </RadzenText>
                    <RadzenButton Text="Link Predecessor Questionnaire"
                                Icon="link"
                                ButtonStyle="ButtonStyle.Primary"
                                Size="ButtonSize.Small"
                                Click="@ShowLinkPredecessorDialog" />
                </RadzenAlert>
            }

            @* Current Goals Section *@
            <RadzenFieldset>
                <HeaderTemplate>
                    <RadzenIcon Icon="track_changes" Class="me-2" />
                    <span class="fw-bold">Current Goals</span>
                </HeaderTemplate>
                <ChildContent>
                    @if (!currentGoals.Any() && !pendingAdds.Any())
                    {
                        <RadzenAlert AlertStyle="AlertStyle.Info" Variant="Variant.Flat" Class="mb-3">
                            <RadzenText TextStyle="TextStyle.Body2">
                                No goals have been added yet. @(!IsReadOnly ? "Click 'Add Goal' to create one." : "")
                            </RadzenText>
                        </RadzenAlert>
                    }
                    else
                    {
                        @* Render saved goals *@
                        @foreach (var goal in currentGoals)
                        {
                            <div class="goal-card mb-3 p-3 border rounded" @key="@goal[GoalService.GoalIdKey]">
                                @RenderGoal(goal)
                            </div>
                        }

                        @* Render pending adds (not yet saved) *@
                        @foreach (var pendingAdd in pendingAdds)
                        {
                            var tempKey = $"pending_{pendingAdds.IndexOf(pendingAdd)}";
                            <div class="goal-card mb-3 p-3 border rounded" @key="@tempKey">
                                @RenderPendingAdd(pendingAdd, pendingAdds.IndexOf(pendingAdd))
                            </div>
                        }
                    }

                    @if (!IsReadOnly)
                    {
                        <RadzenButton Text="Add Goal"
                                    Icon="add"
                                    ButtonStyle="ButtonStyle.Secondary"
                                    Class="mt-3"
                                    Click="@ShowAddGoalDialog" />
                    }
                </ChildContent>
            </RadzenFieldset>
        </div>
    };

    private RenderFragment RenderPredecessorRating(Dictionary<string, object> rating) => __builder =>
    {
        var sourceGoalId = rating.TryGetValue(GoalService.RatingSourceGoalIdKey, out var sgId) ? sgId : Guid.Empty;
        var originalObjective = rating.TryGetValue(GoalService.RatingOriginalObjectiveKey, out var obj) ? obj?.ToString() ?? "" : "";
        var degree = rating.TryGetValue(GoalService.RatingDegreeKey, out var deg) ? Convert.ToDecimal(deg) : 0;
        var justification = rating.TryGetValue(GoalService.RatingJustificationKey, out var just) ? just?.ToString() ?? "" : "";
        var ratedByRole = rating.TryGetValue(GoalService.RatingByRoleKey, out var role) ? role?.ToString() ?? "" : "";

        <RadzenRow>
            <RadzenColumn Size="12">
                <RadzenText TextStyle="TextStyle.Subtitle1" Class="fw-bold mb-2">
                    @originalObjective
                </RadzenText>
                <RadzenBadge Text="@ratedByRole" BadgeStyle="BadgeStyle.Info" Class="mb-2" />
            </RadzenColumn>
        </RadzenRow>

        <RadzenRow Class="mt-2">
            <RadzenColumn Size="12" SizeMD="6">
                <RadzenText TextStyle="TextStyle.Caption" Class="mb-1">Degree of Achievement (%):</RadzenText>
                @if (!IsReadOnly)
                {
                    <RadzenNumeric Value="@degree"
                                 ValueChanged="@((decimal value) => SetPredecessorRatingDegree(sourceGoalId, value))"
                                 Min="0"
                                 Max="100"
                                 Step="5"
                                 Class="w-100"
                                 Disabled="@IsReadOnly" />
                }
                else
                {
                    <RadzenText TextStyle="TextStyle.Body1" Class="fw-bold">@degree%</RadzenText>
                }
            </RadzenColumn>
        </RadzenRow>

        <RadzenRow Class="mt-2">
            <RadzenColumn Size="12">
                <RadzenText TextStyle="TextStyle.Caption" Class="mb-1">Justification:</RadzenText>
                @if (!IsReadOnly)
                {
                    <RadzenTextArea Value="@justification"
                                  ValueChanged="@((string value) => SetPredecessorRatingJustification(sourceGoalId, value))"
                                  Placeholder="Provide justification for the achievement degree..."
                                  Rows="3"
                                  Class="w-100"
                                  Disabled="@IsReadOnly" />
                }
                else if (!string.IsNullOrEmpty(justification))
                {
                    <div class="p-2 bg-light rounded">
                        <span>@justification</span>
                    </div>
                }
            </RadzenColumn>
        </RadzenRow>
    };

    private RenderFragment RenderPendingAdd(AddGoalDto dto, int index) => __builder =>
    {
        <RadzenRow>
            <RadzenColumn Size="12">
                <RadzenText TextStyle="TextStyle.Subtitle1" Class="fw-bold mb-2">
                    @dto.ObjectiveDescription
                </RadzenText>
                <RadzenBadge Text="@GetDisplayRole(dto.AddedByRole)" BadgeStyle="BadgeStyle.Success" Class="mb-2" />
                <RadzenBadge Text="Pending Add" BadgeStyle="BadgeStyle.Info" Class="mb-2 ms-2" />
            </RadzenColumn>
        </RadzenRow>

        <RadzenRow Class="mt-2">
            <RadzenColumn Size="12" SizeMD="6">
                <RadzenText TextStyle="TextStyle.Caption" Class="text-muted">Timeframe:</RadzenText>
                <RadzenText TextStyle="TextStyle.Body2">@dto.TimeframeFrom.ToShortDateString() - @dto.TimeframeTo.ToShortDateString()</RadzenText>
            </RadzenColumn>
            <RadzenColumn Size="12" SizeMD="6">
                <RadzenText TextStyle="TextStyle.Caption" Class="text-muted">Weighting:</RadzenText>
                <RadzenText TextStyle="TextStyle.Body2">@(dto.WeightingPercentage?.ToString() ?? "0")%</RadzenText>
            </RadzenColumn>
        </RadzenRow>

        <RadzenRow Class="mt-2">
            <RadzenColumn Size="12">
                <RadzenText TextStyle="TextStyle.Caption" Class="text-muted">Measurement Metric:</RadzenText>
                <RadzenText TextStyle="TextStyle.Body2">@dto.MeasurementMetric</RadzenText>
            </RadzenColumn>
        </RadzenRow>

        @if (!IsReadOnly)
        {
            <RadzenRow Class="mt-3">
                <RadzenColumn Size="12" Class="d-flex justify-content-end gap-2">
                    <RadzenButton Text="Edit"
                                Icon="edit"
                                ButtonStyle="ButtonStyle.Light"
                                Size="ButtonSize.Small"
                                Click="@(() => ShowEditPendingGoalDialog(index, dto))" />
                    <RadzenButton Text="Cancel"
                                Icon="close"
                                ButtonStyle="ButtonStyle.Danger"
                                Size="ButtonSize.Small"
                                Click="@(() => CancelPendingAdd(index))" />
                </RadzenColumn>
            </RadzenRow>
        }
    };

    private RenderFragment RenderGoal(Dictionary<string, object> goal) => __builder =>
    {
        var goalId = goal.TryGetValue(GoalService.GoalIdKey, out var gId) ? gId : Guid.Empty;
        var objective = goal.TryGetValue(GoalService.GoalObjectiveKey, out var obj) ? obj?.ToString() ?? "" : "";
        var measurement = goal.TryGetValue(GoalService.GoalMeasurementKey, out var meas) ? meas?.ToString() ?? "" : "";
        var weighting = goal.TryGetValue(GoalService.GoalWeightingKey, out var weight) ? Convert.ToDecimal(weight) : 0;
        var addedByRole = goal.TryGetValue(GoalService.GoalAddedByRoleKey, out var role) ? role?.ToString() ?? "" : "";

        // Check pending status
        var isPendingDelete = goalId is Guid gGuid && pendingDeletes.Contains(gGuid);
        var isPendingModify = goalId is Guid gGuid2 && pendingModifies.ContainsKey(gGuid2);

        DateTime fromDate = DateTime.Now;
        DateTime toDate = DateTime.Now.AddMonths(1);

        if (goal.TryGetValue(GoalService.GoalTimeframeFromKey, out var fromVal))
        {
            if (fromVal is DateTime dt) fromDate = dt;
            else if (fromVal is DateTimeOffset dto) fromDate = dto.DateTime;
            else DateTime.TryParse(fromVal?.ToString(), out fromDate);
        }

        if (goal.TryGetValue(GoalService.GoalTimeframeToKey, out var toVal))
        {
            if (toVal is DateTime dt) toDate = dt;
            else if (toVal is DateTimeOffset dto) toDate = dto.DateTime;
            else DateTime.TryParse(toVal?.ToString(), out toDate);
        }

        // If there's a pending modify, override values with pending changes
        if (isPendingModify && goalId is Guid pendingGoalId && pendingModifies.TryGetValue(pendingGoalId, out var pendingDto))
        {
            objective = pendingDto.ObjectiveDescription ?? objective;
            measurement = pendingDto.MeasurementMetric ?? measurement;
            fromDate = pendingDto.TimeframeFrom ?? fromDate;
            toDate = pendingDto.TimeframeTo ?? toDate;
            weighting = pendingDto.WeightingPercentage ?? weighting;
        }

        <RadzenRow>
            <RadzenColumn Size="12">
                <RadzenText TextStyle="TextStyle.Subtitle1" Class="fw-bold mb-2">
                    @objective
                </RadzenText>
                <RadzenBadge Text="@GetDisplayRole(addedByRole)" BadgeStyle="BadgeStyle.Success" Class="mb-2" />
                @if (isPendingDelete)
                {
                    <RadzenBadge Text="Pending Delete" BadgeStyle="BadgeStyle.Danger" Class="mb-2 ms-2" />
                }
                else if (isPendingModify)
                {
                    <RadzenBadge Text="Pending Edit" BadgeStyle="BadgeStyle.Warning" Class="mb-2 ms-2" />
                }
            </RadzenColumn>
        </RadzenRow>

        <RadzenRow Class="mt-2">
            <RadzenColumn Size="12" SizeMD="6">
                <RadzenText TextStyle="TextStyle.Caption" Class="text-muted">Timeframe:</RadzenText>
                <RadzenText TextStyle="TextStyle.Body2">@fromDate.ToShortDateString() - @toDate.ToShortDateString()</RadzenText>
            </RadzenColumn>
            <RadzenColumn Size="12" SizeMD="6">
                <RadzenText TextStyle="TextStyle.Caption" Class="text-muted">Weighting:</RadzenText>
                <RadzenText TextStyle="TextStyle.Body2">@weighting%</RadzenText>
            </RadzenColumn>
        </RadzenRow>

        <RadzenRow Class="mt-2">
            <RadzenColumn Size="12">
                <RadzenText TextStyle="TextStyle.Caption" Class="text-muted">Measurement Metric:</RadzenText>
                <RadzenText TextStyle="TextStyle.Body2">@measurement</RadzenText>
            </RadzenColumn>
        </RadzenRow>

        @if (!IsReadOnly)
        {
            <RadzenRow Class="mt-3">
                <RadzenColumn Size="12" Class="d-flex justify-content-end gap-2">
                    @if (isPendingDelete && goalId is Guid undoGuid)
                    {
                        <RadzenButton Text="Undo Delete"
                                    Icon="undo"
                                    ButtonStyle="ButtonStyle.Warning"
                                    Size="ButtonSize.Small"
                                    Click="@(() => UndoDelete(undoGuid))" />
                    }
                    else
                    {
                        <RadzenButton Text="Edit"
                                    Icon="edit"
                                    ButtonStyle="ButtonStyle.Light"
                                    Size="ButtonSize.Small"
                                    Click="@(() => ShowEditGoalDialog(goalId, objective, measurement, fromDate, toDate, weighting))" />
                        <RadzenButton Text="Delete"
                                    Icon="delete"
                                    ButtonStyle="ButtonStyle.Danger"
                                    Size="ButtonSize.Small"
                                    Click="@(() => ShowDeleteGoalConfirmation(goalId, objective))" />
                    }
                </RadzenColumn>
            </RadzenRow>
        }
    };

    [Parameter, EditorRequired] public QuestionItem Question { get; set; } = default!;
    [Parameter, EditorRequired] public QuestionResponse Response { get; set; } = default!;
    [Parameter] public EventCallback<QuestionResponse> OnResponseChanged { get; set; }
    [Parameter] public bool IsReadOnly { get; set; } = false;
    [Parameter] public bool HideHeader { get; set; } = false;
    [Parameter] public Guid AssignmentId { get; set; }
    [Parameter] public string CurrentUserRole { get; set; } = "Employee";
    [Parameter] public WorkflowState AssignmentWorkflowState { get; set; } = WorkflowState.EmployeeInProgress;

    // Current state (loaded from API)
    private List<Dictionary<string, object>> currentGoals = new();
    private List<Dictionary<string, object>> predecessorRatings = new();
    private bool hasPredecessor = false;

    // Pending operations queue (executed on Save Progress / Submit)
    private List<AddGoalDto> pendingAdds = new();
    private Dictionary<Guid, ModifyGoalDto> pendingModifies = new();
    private List<Guid> pendingDeletes = new();

    // Helper to check if there are any pending changes
    public bool HasPendingChanges => pendingAdds.Any() || pendingModifies.Any() || pendingDeletes.Any();

    protected override async Task OnInitializedAsync()
    {
        // Load goals from API (goals are stored in QuestionnaireAssignment aggregate)
        // Pending operations will be queued locally and executed on "Save Progress" or "Submit"
        await ReloadGoalData();
        await base.OnInitializedAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (HasParameterChanged(nameof(Question), Question) ||
            HasParameterChanged(nameof(Response), Response))
        {
            LoadGoalData();
        }

        await base.OnParametersSetAsync();
    }

    private void LoadGoalData()
    {
        var allGoals = GoalService.GetGoals(Response);

        // Filter goals for comparison views in review meetings
        var currentRole = CurrentUserRole;

        currentGoals = allGoals.Where(goal =>
        {
            if (goal.TryGetValue(GoalService.GoalAddedByRoleKey, out var addedByRole))
            {
                var roleString = addedByRole?.ToString() ?? "";

                // For comparison views: strict role-based filtering
                if (currentRole == "Employee")
                {
                    // Employee side: show only goals added by Employee role
                    return string.Equals(roleString, "Employee", StringComparison.OrdinalIgnoreCase);
                }
                else if (IsManagerRole(currentRole))
                {
                    // Manager side: show only goals added by any manager role
                    return IsManagerRole(roleString);
                }
                else
                {
                    // Fallback: show all goals for admin/other roles
                    return true;
                }
            }

            // If no role information, default based on current context
            // In comparison views, only show goals with proper role attribution
            // This prevents duplicate goals from appearing on both sides
            if (currentRole == "Employee")
            {
                // Employee side: if no role info, assume legacy employee goal
                return true;
            }
            else
            {
                // Manager side: if no role info, don't show (prevents duplication)
                return false;
            }
        }).ToList();

        predecessorRatings = GoalService.GetPredecessorRatings(Response);
        hasPredecessor = GoalService.GetPredecessorAssignmentId(Response).HasValue;
    }

    private bool IsManagerRole(string role)
    {
        return role == "TeamLead" || role == "HR" || role == "HRLead" || role == "Admin";
    }

    protected override bool HasStateChanged()
    {
        return HasParameterChanged(nameof(Response.ComplexValue), Response.ComplexValue?.Count ?? 0) ||
               HasParameterChanged(nameof(currentGoals), currentGoals.Count) ||
               HasParameterChanged(nameof(predecessorRatings), predecessorRatings.Count) ||
               HasParameterChanged(nameof(pendingAdds), pendingAdds.Count) ||
               HasParameterChanged(nameof(pendingModifies), pendingModifies.Count) ||
               HasParameterChanged(nameof(pendingDeletes), pendingDeletes.Count);
    }

    private async Task SetPredecessorRatingDegree(object sourceGoalId, decimal value)
    {
        if (IsReadOnly) return;

        var rating = predecessorRatings.FirstOrDefault(r =>
            r.TryGetValue(GoalService.RatingSourceGoalIdKey, out var id) && id.Equals(sourceGoalId));

        if (rating != null)
        {
            rating[GoalService.RatingDegreeKey] = value;
            Response.ComplexValue ??= new Dictionary<string, object>();
            Response.ComplexValue[GoalService.PredecessorRatingsKey] = predecessorRatings;
            Response.LastModified = DateTime.Now;

            await NotifyResponseChanged();
        }
    }

    private async Task SetPredecessorRatingJustification(object sourceGoalId, string value)
    {
        if (IsReadOnly) return;

        var rating = predecessorRatings.FirstOrDefault(r =>
            r.TryGetValue(GoalService.RatingSourceGoalIdKey, out var id) && id.Equals(sourceGoalId));

        if (rating != null)
        {
            rating[GoalService.RatingJustificationKey] = value ?? "";
            Response.ComplexValue ??= new Dictionary<string, object>();
            Response.ComplexValue[GoalService.PredecessorRatingsKey] = predecessorRatings;
            Response.LastModified = DateTime.Now;

            await NotifyStateChangedDebounced(300);
            await NotifyResponseChanged();
        }
    }

    private async Task ShowAddGoalDialog()
    {
        var result = await DialogService.OpenAsync<AddGoalDialog>("Add New Goal",
            new Dictionary<string, object>
            {
                { "AssignmentId", AssignmentId },
                { "QuestionId", Question.Id },
                { "AddedByRole", await GetLoggedInUserRole() }
            },
            new DialogOptions
            {
                Width = "700px",
                Resizable = true,
                Draggable = true,
                CloseDialogOnOverlayClick = false
            });

        // Dialog returns AddGoalDto
        if (result is AddGoalDto dto)
        {
            // Queue the add operation (will be executed when "Save Progress" or "Submit" is clicked)
            pendingAdds.Add(dto);

            // Show success message
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Info,
                Summary = "Goal Queued",
                Detail = "Goal will be saved when you click 'Save Progress' or 'Submit'.",
                Duration = 4000
            });

            // Trigger re-render to show the pending goal
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ShowEditPendingGoalDialog(int index, AddGoalDto existingDto)
    {
        var result = await DialogService.OpenAsync<AddGoalDialog>("Edit Pending Goal",
            new Dictionary<string, object>
            {
                { "AssignmentId", AssignmentId },
                { "QuestionId", Question.Id },
                { "AddedByRole", await GetLoggedInUserRole() },
                { "InitialObjective", existingDto.ObjectiveDescription ?? "" },
                { "InitialMeasurement", existingDto.MeasurementMetric ?? "" },
                { "InitialTimeframeFrom", existingDto.TimeframeFrom },
                { "InitialTimeframeTo", existingDto.TimeframeTo }
            },
            new DialogOptions
            {
                Width = "700px",
                Resizable = true,
                Draggable = true,
                CloseDialogOnOverlayClick = false
            });

        // Dialog returns updated AddGoalDto
        if (result is AddGoalDto dto)
        {
            // Update the pending goal at the specified index
            pendingAdds[index] = dto;

            // Show success message
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Info,
                Summary = "Edit Queued",
                Detail = "Changes will be saved when you click 'Save Progress' or 'Submit'.",
                Duration = 4000
            });

            // Trigger re-render to show the updated pending goal
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ShowLinkPredecessorDialog()
    {
        var result = await DialogService.OpenAsync<LinkPredecessorDialog>("Link Predecessor Questionnaire",
            new Dictionary<string, object>
            {
                { "AssignmentId", AssignmentId },
                { "QuestionId", Question.Id }
            },
            new DialogOptions
            {
                Width = "800px",
                Resizable = true,
                Draggable = true,
                CloseDialogOnOverlayClick = false
            });

        if (result is bool success && success)
        {
            // Reload goal data from API to get new predecessor ratings
            await ReloadGoalData();
        }
    }

    private async Task ReloadGoalData()
    {
        try
        {
            var result = await GoalApiService.GetGoalQuestionDataAsync(AssignmentId, Question.Id);

            if (result.Succeeded && result.Payload != null)
            {
                // Update the response with fresh data from the server
                // Convert the DTOs back to the dictionary format expected by GoalService
                var allGoalsList = result.Payload.Goals.Select(g => new Dictionary<string, object>
                {
                    [GoalService.GoalIdKey] = g.Id,
                    [GoalService.GoalObjectiveKey] = g.ObjectiveDescription,
                    [GoalService.GoalTimeframeFromKey] = g.TimeframeFrom,
                    [GoalService.GoalTimeframeToKey] = g.TimeframeTo,
                    [GoalService.GoalMeasurementKey] = g.MeasurementMetric,
                    [GoalService.GoalWeightingKey] = g.WeightingPercentage,
                    [GoalService.GoalAddedByRoleKey] = g.AddedByRole.ToString()
                }).ToList();

                // Store ALL goals in response (for persistence), but LoadGoalData() will filter for display
                var goalsList = allGoalsList;

                Response.ComplexValue ??= new Dictionary<string, object>();
                Response.ComplexValue[GoalService.GoalsKey] = goalsList;

                if (result.Payload.PredecessorAssignmentId.HasValue)
                {
                    Response.ComplexValue[GoalService.PredecessorAssignmentIdKey] = result.Payload.PredecessorAssignmentId.Value;

                    var ratingsList = result.Payload.PredecessorGoalRatings.Select(r => new Dictionary<string, object>
                    {
                        [GoalService.RatingSourceGoalIdKey] = r.SourceGoalId,
                        [GoalService.RatingDegreeKey] = r.DegreeOfAchievement,
                        [GoalService.RatingJustificationKey] = r.Justification ?? "",
                        [GoalService.RatingByRoleKey] = r.RatedByRole.ToString(),
                        [GoalService.RatingOriginalObjectiveKey] = r.OriginalObjectiveDescription ?? ""
                    }).ToList();

                    Response.ComplexValue[GoalService.PredecessorRatingsKey] = ratingsList;
                }

                Response.LastModified = DateTime.Now;

                // Reload local data
                LoadGoalData();

                // Notify parent component
                await NotifyResponseChanged();
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Error,
                Summary = "Error",
                Detail = $"Failed to reload goal data: {ex.Message}",
                Duration = 6000
            });
        }
    }

    private async Task ShowEditGoalDialog(object goalId, string objective, string measurement, DateTime fromDate, DateTime toDate, decimal weighting)
    {
        var result = await DialogService.OpenAsync<EditGoalDialog>("Edit Goal",
            new Dictionary<string, object>
            {
                { "AssignmentId", AssignmentId },
                { "QuestionId", Question.Id },
                { "GoalId", goalId },
                { "ModifiedByRole", await GetLoggedInUserRole() },
                { "InitialObjective", objective },
                { "InitialMeasurement", measurement },
                { "InitialTimeframeFrom", fromDate },
                { "InitialTimeframeTo", toDate },
                { "InitialWeighting", weighting },
                { "AssignmentWorkflowState", AssignmentWorkflowState }
            },
            new DialogOptions
            {
                Width = "700px",
                Resizable = true,
                Draggable = true,
                CloseDialogOnOverlayClick = false
            });

        // Dialog returns tuple (Guid GoalId, ModifyGoalDto)
        if (result is ValueTuple<Guid, ModifyGoalDto> tuple)
        {
            var (gId, dto) = tuple;

            // Queue the modify operation (will be executed when "Save Progress" or "Submit" is clicked)
            pendingModifies[gId] = dto;

            // Show success message
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Info,
                Summary = "Edit Queued",
                Detail = "Changes will be saved when you click 'Save Progress' or 'Submit'.",
                Duration = 4000
            });

            // Trigger re-render to show the pending edit indicator
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ShowDeleteGoalConfirmation(object goalId, string objective)
    {
        var confirmed = await DialogService.Confirm(
            $"Are you sure you want to delete this goal: '{objective}'?",
            "Confirm Delete",
            new ConfirmOptions { OkButtonText = "Yes, Delete", CancelButtonText = "Cancel" }
        );

        if (confirmed == true && goalId is Guid gId)
        {
            // Queue the delete operation (will be executed when "Save Progress" or "Submit" is clicked)
            pendingDeletes.Add(gId);

            // Show success message
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Info,
                Summary = "Delete Queued",
                Detail = "Goal will be deleted when you click 'Save Progress' or 'Submit'.",
                Duration = 4000
            });

            // Trigger re-render to show the pending delete indicator
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task UndoDelete(Guid goalId)
    {
        // Remove from pending deletes
        pendingDeletes.Remove(goalId);

        // Show success message
        NotificationService.Notify(new NotificationMessage
        {
            Severity = NotificationSeverity.Info,
            Summary = "Delete Cancelled",
            Detail = "Goal deletion has been cancelled.",
            Duration = 4000
        });

        // Trigger re-render
        await InvokeAsync(StateHasChanged);
    }

    private async Task CancelPendingAdd(int index)
    {
        if (index >= 0 && index < pendingAdds.Count)
        {
            pendingAdds.RemoveAt(index);

            // Show success message
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Info,
                Summary = "Add Cancelled",
                Detail = "Goal addition has been cancelled.",
                Duration = 4000
            });

            // Trigger re-render
            await InvokeAsync(StateHasChanged);
        }
    }

    /// <summary>
    /// Executes all pending goal operations (add/modify/delete).
    /// Returns true if all operations succeed, false if any fail.
    /// Successful operations are kept saved (no rollback).
    /// </summary>
    public async Task<bool> SavePendingGoalChanges()
    {
        if (!HasPendingChanges)
            return true; // Nothing to save

        bool allSucceeded = true;
        var errors = new List<string>();

        // Execute deletes first
        // TODO: Implement DeleteGoalAsync in IGoalApiService and backend
        foreach (var goalId in pendingDeletes.ToList()) // ToList to avoid modification during iteration
        {
            // DeleteGoalAsync not yet implemented in API
            allSucceeded = false;
            errors.Add($"Delete operation not yet implemented in backend API");
            // Keep in queue for now
        }

        // Execute modifies
        foreach (var kvp in pendingModifies.ToList()) // ToList to avoid modification during iteration
        {
            try
            {
                var result = await GoalApiService.ModifyGoalAsync(AssignmentId, kvp.Key, kvp.Value);
                if (result.Succeeded)
                {
                    pendingModifies.Remove(kvp.Key);
                }
                else
                {
                    allSucceeded = false;
                    errors.Add($"Modify failed: {result.ErrorMessage}");
                }
            }
            catch (Exception ex)
            {
                allSucceeded = false;
                errors.Add($"Modify error: {ex.Message}");
            }
        }

        // Execute adds
        foreach (var dto in pendingAdds.ToList()) // ToList to avoid modification during iteration
        {
            try
            {
                var result = await GoalApiService.AddGoalAsync(AssignmentId, dto);
                if (result.Succeeded)
                {
                    pendingAdds.Remove(dto);
                }
                else
                {
                    allSucceeded = false;
                    errors.Add($"Add failed: {result.ErrorMessage}");
                }
            }
            catch (Exception ex)
            {
                allSucceeded = false;
                errors.Add($"Add error: {ex.Message}");
            }
        }

        // Reload goals from API to reflect saved changes
        await ReloadGoalData();

        // Trigger re-render
        await InvokeAsync(StateHasChanged);

        // Show result notification
        if (allSucceeded)
        {
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Success,
                Summary = "Goals Saved",
                Detail = "All goal changes have been saved successfully.",
                Duration = 4000
            });
        }
        else
        {
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Error,
                Summary = "Partial Save",
                Detail = $"Some goal operations failed: {string.Join("; ", errors)}",
                Duration = 8000
            });
        }

        return allSucceeded;
    }

    private async Task NotifyResponseChanged()
    {
        if (OnResponseChanged.HasDelegate)
        {
            await OnResponseChanged.InvokeAsync(Response);
        }
    }

    /// <summary>
    /// Checks if the assignment is in a review phase where structural changes (like linking predecessors) should not be allowed.
    /// </summary>
    private bool IsInReviewPhase()
    {
        return AssignmentWorkflowState is WorkflowState.InReview or
                                         WorkflowState.ManagerReviewConfirmed or
                                         WorkflowState.EmployeeReviewConfirmed or
                                         WorkflowState.Finalized;
    }

    /// <summary>
    /// Gets the current user's ApplicationRole for API communication.
    /// Returns the actual ApplicationRole enum string that the API expects.
    /// </summary>
    private async Task<string> GetLoggedInUserRole()
    {
        try
        {
            var roleData = await AuthService.GetMyRoleAsync();
            if (roleData == null)
            {
                return ApplicationRole.Employee.ToString(); // Safe default
            }

            // Return actual ApplicationRole for API - don't convert to simplified form
            return roleData.ApplicationRole.ToString();
        }
        catch (Exception)
        {
            // Safe default if role lookup fails
            return ApplicationRole.Employee.ToString();
        }
    }

    /// <summary>
    /// Converts any role string (specific ApplicationRole or simplified ResponseRole)
    /// to the simplified Employee/Manager format for display.
    /// </summary>
    private string GetDisplayRole(string roleString)
    {
        if (string.IsNullOrEmpty(roleString))
        {
            return ResponseRole.Employee.ToRoleKey();
        }

        // Handle simplified roles (already correct)
        if (roleString == "Employee" || roleString == "Manager")
        {
            return roleString;
        }

        // Convert specific ApplicationRole strings to simplified format
        return roleString switch
        {
            "Employee" => ResponseRole.Employee.ToRoleKey(),
            "TeamLead" => ResponseRole.Manager.ToRoleKey(),
            "HR" => ResponseRole.Manager.ToRoleKey(),
            "HRLead" => ResponseRole.Manager.ToRoleKey(),
            "Admin" => ResponseRole.Manager.ToRoleKey(),
            _ => ResponseRole.Employee.ToRoleKey() // Default for unknown roles
        };
    }
}

<style>
.goal-card, .predecessor-rating-card {
    transition: all 0.2s ease;
    border-color: var(--border-light, #e2e8f0) !important;
}

.goal-card:hover, .predecessor-rating-card:hover {
    border-color: var(--primary-color, #2563eb) !important;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.goal-content {
    min-height: 100px;
}

/* Performance optimization */
.goal-card[data-updating="true"],
.predecessor-rating-card[data-updating="true"] {
    opacity: 0.8;
}
</style>
