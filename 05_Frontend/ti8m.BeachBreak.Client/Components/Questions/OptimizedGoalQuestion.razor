@using Radzen.Blazor
@using ti8m.BeachBreak.Client.Models
@using ti8m.BeachBreak.Client.Models.DTOs
@using ti8m.BeachBreak.Client.Components.Shared
@using ti8m.BeachBreak.Client.Components.Dialogs
@using ti8m.BeachBreak.Client.Services
@using ti8m.BeachBreak.Client.Extensions
@inject GoalService GoalService
@inject IGoalApiService GoalApiService
@inject DialogService DialogService
@inject NotificationService NotificationService
@inject IAuthService AuthService
@inherits OptimizedTranslatableComponentBase

@if (!HideHeader)
{
    <div class="goal-question">
        <header class="question-header">
            <h3 class="question-title">
                @Section.GetLocalizedTitleWithFallback(CurrentLanguage)
                <EditedDuringReviewBadge Response="@Response" />
            </h3>

            @{
                var questionDescription = Section.GetLocalizedDescriptionWithFallback(CurrentLanguage);
            }
            @if (!string.IsNullOrWhiteSpace(questionDescription))
            {
                <p class="question-description">@questionDescription</p>
            }
        </header>

        @RenderTwoSectionGoalContent()
    </div>
}
else
{
    @RenderTwoSectionGoalContent()
}

@code {
    private RenderFragment RenderTwoSectionGoalContent() => __builder =>
    {
        <div class="two-section-goal-content">
            @* SECTION 1: Predecessor Goals Assessment (Always First if Available) *@
            @if (hasPredecessor)
            {
                <PredecessorGoalsComparisonSection
                    Section="@Section"
                    Response="@Response"
                    OnResponseChanged="@NotifyResponseChanged"
                    IsReadOnly="@IsReadOnly"
                    CurrentUserRole="@CurrentUserRole"
                    @ref="predecessorSection" />
            }
            else if (!IsReadOnly && !IsInReviewPhase() && CurrentUserRole >= ApplicationRole.TeamLead)
            {
                @* Link Predecessor Section - Only show if no predecessor linked, not read-only, not in review phase, and user is TeamLead or above *@
                <RadzenAlert AlertStyle="AlertStyle.Info" Class="mb-4" ShowIcon="true">
                    <RadzenText TextStyle="TextStyle.Body2" Class="mb-2">
                        <strong>Link Previous Questionnaire:</strong> Link a predecessor questionnaire to rate goals from a previous period.
                    </RadzenText>
                    <RadzenButton Text="Link Predecessor Questionnaire"
                                Icon="link"
                                ButtonStyle="ButtonStyle.Primary"
                                Size="ButtonSize.Small"
                                Click="@ShowLinkPredecessorDialog" />
                </RadzenAlert>
            }

            @* SECTION 2: New Goals (Always Second, Collaborative Editing) *@
            <NewGoalsCollaborativeSection
                Section="@Section"
                Response="@Response"
                OnResponseChanged="@NotifyResponseChanged"
                IsReadOnly="@IsReadOnly"
                CurrentUserRole="@CurrentUserRole"
                AssignmentWorkflowState="@AssignmentWorkflowState"
                AssignmentId="@AssignmentId"
                SectionData="@SectionData"
                @ref="newGoalsSection" />
        </div>
    };

    // === Old render fragment methods removed - now handled by child components ===

    [Parameter, EditorRequired] public QuestionSection Section { get; set; } = default!;
    [Parameter, EditorRequired] public QuestionResponse Response { get; set; } = default!;
    [Parameter] public EventCallback<QuestionResponse> OnResponseChanged { get; set; }
    [Parameter] public bool IsReadOnly { get; set; } = false;
    [Parameter] public bool HideHeader { get; set; } = false;
    [Parameter] public Guid AssignmentId { get; set; }
    [Parameter] public ApplicationRole CurrentUserRole { get; set; } = ApplicationRole.Employee;
    [Parameter] public WorkflowState AssignmentWorkflowState { get; set; } = WorkflowState.EmployeeInProgress;
    [Parameter] public SectionResponse? SectionData { get; set; } // Access to all role responses for review mode
    [Parameter] public int GoalRefreshToken { get; set; } = 0;

    // Component references for the two sections
    private NewGoalsCollaborativeSection? newGoalsSection;
    private PredecessorGoalsComparisonSection? predecessorSection;

    // Current state (simplified for two-section approach)
    private bool hasPredecessor = false;

    // Helper properties that delegate to child components
    public bool HasPendingChanges => newGoalsSection?.HasPendingChanges ?? false;
    public bool HasValidationErrors => predecessorSection?.ValidationErrors?.Any() ?? false;

    // Tracking for refresh token to detect when parent requests data reload
    private int lastGoalRefreshToken = 0;

    protected override async Task OnInitializedAsync()
    {
        // Always load configuration on initialization
        // This ensures the component works correctly when used in dialogs or other contexts
        // where parameter change detection might not work as expected
        LoadBasicGoalData();

        await base.OnInitializedAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (HasParameterChanged(nameof(Section), Section) ||
            HasParameterChanged(nameof(Response), Response) ||
            GoalRefreshToken != lastGoalRefreshToken)
        {
            lastGoalRefreshToken = GoalRefreshToken;
            LoadBasicGoalData();
        }

        await base.OnParametersSetAsync();
    }

    private void LoadBasicGoalData()
    {
        // Only load basic state needed by parent component
        hasPredecessor = GoalService.GetPredecessorAssignmentId(Response).HasValue;
    }

    protected override bool HasStateChanged()
    {
        var responseDataHash = Response.ResponseData?.GetHashCode() ?? 0;
        return HasParameterChanged(nameof(Response.ResponseData), responseDataHash) ||
               HasParameterChanged(nameof(hasPredecessor), hasPredecessor);
    }


    private async Task ShowLinkPredecessorDialog()
    {
        var result = await DialogService.OpenAsync<LinkPredecessorDialog>("Link Predecessor Questionnaire",
            new Dictionary<string, object>
            {
                { "AssignmentId", AssignmentId },
                { "QuestionId", Section.Id }
            },
            new DialogOptions
            {
                Width = "800px",
                Resizable = true,
                Draggable = true,
                CloseDialogOnOverlayClick = false
            });

        if (result is bool success && success)
        {
            // Update local state and trigger re-render
            LoadBasicGoalData();
            await NotifyResponseChanged();
            await InvokeAsync(StateHasChanged);
        }
    }


    /// <summary>
    /// Executes all pending goal operations by delegating to the child component.
    /// Returns true if all operations succeed, false if any fail.
    /// </summary>
    public async Task<bool> SavePendingGoalChanges()
    {
        // Delegate to the child component which handles all goal operations
        if (newGoalsSection != null)
        {
            return await newGoalsSection.SavePendingGoalChanges();
        }

        return true; // No pending changes if component not initialized
    }

    private async Task NotifyResponseChanged()
    {
        if (OnResponseChanged.HasDelegate)
        {
            await OnResponseChanged.InvokeAsync(Response);
        }
    }

    /// <summary>
    /// Checks if the assignment is in a review phase where structural changes (like linking predecessors) should not be allowed.
    /// </summary>
    private bool IsInReviewPhase()
    {
        return AssignmentWorkflowState is WorkflowState.InReview or
                                         WorkflowState.ReviewFinished or
                                         WorkflowState.EmployeeReviewConfirmed or
                                         WorkflowState.Finalized;
    }

}
