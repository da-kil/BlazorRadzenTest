@using Radzen.Blazor
@using ti8m.BeachBreak.Client.Models
@using ti8m.BeachBreak.Client.Models.Dto
@using ti8m.BeachBreak.Client.Components.Shared
@using ti8m.BeachBreak.Client.Components.Dialogs
@using ti8m.BeachBreak.Client.Services
@using ti8m.BeachBreak.Client.Extensions
@inject GoalService GoalService
@inject IGoalApiService GoalApiService
@inject DialogService DialogService
@inject NotificationService NotificationService
@inject IAuthService AuthService
@inherits OptimizedComponentBase

<RadzenFieldset Class="mb-4 new-goals-section">
    <HeaderTemplate>
        <RadzenIcon Icon="track_changes" Class="me-2" />
        <span class="fw-bold">New Goals</span>
        <RadzenText TextStyle="TextStyle.Caption" Class="ms-2 text-muted">
            (Set goals for upcoming period)
        </RadzenText>
    </HeaderTemplate>
    <ChildContent>
        @if (!allCurrentGoals.Any())
        {
            <RadzenAlert AlertStyle="AlertStyle.Info" Variant="Variant.Flat" Class="mb-3">
                <RadzenText TextStyle="TextStyle.Body2">
                    No goals have been added yet for the upcoming period.
                    @(!IsReadOnly ? "Start by adding goals that will drive performance in the next review cycle." : "")
                </RadzenText>
            </RadzenAlert>
        }
        else
        {
            @* Show all goals without role-based separation (collaborative approach) *@
            @* Render all goals (saved + pending) *@
            @foreach (var goal in allCurrentGoals.OrderBy(g => g.AddedAt))
            {
                var cardClass = goal.HasPendingChanges ? "goal-card mb-3 p-3 border rounded pending-goal" : "goal-card mb-3 p-3 border rounded";

                <div class="@cardClass" @key="@($"{goal.Id}_{goal.ObjectiveDescription?.GetHashCode()}_{goal.HasPendingChanges}")">
                    @RenderTypedGoal(goal)
                </div>
            }

            @* All goals including pending are now in allCurrentGoals *@
        }

        @if (!IsReadOnly)
        {
            <div class="add-goal-section mt-3">
                <RadzenButton Text="Add New Goal"
                            Icon="add"
                            ButtonStyle="ButtonStyle.Primary"
                            Click="@ShowAddGoalDialog" />
                @if (HasPendingChanges)
                {
                    <RadzenBadge Text="@($"{GetPendingChangesCount()} Pending")"
                               BadgeStyle="BadgeStyle.Warning"
                               Class="ms-2" />
                }
            </div>
        }

        @* Show progress summary *@
        @if (allCurrentGoals.Any())
        {
            <div class="goals-summary mt-4 p-3 bg-light rounded">
                <RadzenText TextStyle="TextStyle.Subtitle2" Class="fw-bold mb-2">Goals Summary:</RadzenText>
                <RadzenRow>
                    <RadzenColumn Size="6">
                        <RadzenText TextStyle="TextStyle.Caption" Class="text-muted">Total Goals:</RadzenText>
                        <RadzenText TextStyle="TextStyle.Body1" Class="fw-bold">
                            @allCurrentGoals.Count
                        </RadzenText>
                    </RadzenColumn>
                    <RadzenColumn Size="6">
                        <RadzenText TextStyle="TextStyle.Caption" Class="text-muted">By Role:</RadzenText>
                        @foreach (var roleGroup in GetGoalsByRole())
                        {
                            <div>
                                <RadzenBadge Text="@roleGroup.Key" BadgeStyle="@GetRoleBadgeStyle(roleGroup.Key)" Class="me-1" />
                                <span>@roleGroup.Value goals</span>
                            </div>
                        }
                    </RadzenColumn>
                </RadzenRow>
            </div>
        }
    </ChildContent>
</RadzenFieldset>

@code {
    [Parameter, EditorRequired] public QuestionItem Question { get; set; } = default!;
    [Parameter, EditorRequired] public QuestionResponse Response { get; set; } = default!;
    [Parameter] public EventCallback<QuestionResponse> OnResponseChanged { get; set; }
    [Parameter] public bool IsReadOnly { get; set; } = false;
    [Parameter] public string CurrentUserRole { get; set; } = "Employee";
    [Parameter] public WorkflowState AssignmentWorkflowState { get; set; } = WorkflowState.EmployeeInProgress;
    [Parameter] public Guid AssignmentId { get; set; }

    // All current goals (strongly-typed with pending state tracking)
    private List<GoalWithState> allCurrentGoals = new();

    protected override void OnInitialized()
    {
        LoadNewGoalsData();

        // If this is the first load and we have goals with IsPendingAdd flags that weren't just added
        // in this session, they're likely incorrectly flagged (now using strongly-typed approach)
        var hasIncorrectFlags = allCurrentGoals.Any(g => g.IsPendingAdd);

        if (hasIncorrectFlags)
        {
            // Clear all pending flags on initial load - they should come from legitimate add operations
            ClearAllPendingAddFlags();
        }

        base.OnInitialized();
    }

    protected override void OnParametersSet()
    {
        if (HasParameterChanged(nameof(Response), Response))
        {
            LoadNewGoalsData();
        }
        base.OnParametersSet();
    }

    private void LoadNewGoalsData()
    {
        var previousCount = allCurrentGoals.Count;

        // NEW: Load goals as strongly-typed objects
        allCurrentGoals = LoadGoalsFromResponse();

        // Track state change for OptimizedComponentBase
        _lastGoalCount = allCurrentGoals.Count;
        _goalCountChanged = _lastGoalCount != previousCount;
    }

    /// <summary>
    /// Load goals from Response data as strongly-typed GoalWithState objects
    /// </summary>
    private List<GoalWithState> LoadGoalsFromResponse()
    {
        if (Response?.ComplexValue == null || !Response.ComplexValue.ContainsKey(GoalService.GoalsKey))
            return new List<GoalWithState>();

        var goalsValue = Response.ComplexValue[GoalService.GoalsKey];

        // Handle JsonElement from API responses
        if (goalsValue is System.Text.Json.JsonElement jsonElement)
        {
            var goalDtos = System.Text.Json.JsonSerializer.Deserialize<List<GoalDto>>(jsonElement.GetRawText());
            return goalDtos?.Select(GoalWithState.FromGoalDto).ToList() ?? new List<GoalWithState>();
        }

        // Handle direct GoalDto list
        if (goalsValue is List<GoalDto> goalDtoList)
        {
            return goalDtoList.Select(GoalWithState.FromGoalDto).ToList();
        }

        // Handle GoalWithState list (already converted)
        if (goalsValue is List<GoalWithState> goalWithStateList)
        {
            return goalWithStateList;
        }

        return new List<GoalWithState>();
    }


    /// <summary>
    /// Removes IsPendingAdd flag from goals that appear to be persisted (non-temporary GUIDs)
    /// This fixes cases where persisted goals incorrectly show "PENDING ADD" badges
    /// NOW USES STRONGLY-TYPED GOALS
    /// </summary>
    private void CleanupIncorrectPendingFlags()
    {
        var hasChanges = false;

        // Clear pending flags from goals that look like they were loaded from the database
        foreach (var goal in allCurrentGoals)
        {
            if (goal.IsPendingAdd && !IsLikelyTemporaryGoal(goal))
            {
                goal.IsPendingAdd = false;
                hasChanges = true;
            }
        }

        // Save changes back to Response if we cleaned up any flags
        if (hasChanges)
        {
            SaveGoalsToResponse();
        }
    }

    /// <summary>
    /// Heuristic to identify goals that were likely just added via dialog vs loaded from database
    /// NOW WORKS WITH STRONGLY-TYPED GOALS
    /// </summary>
    private bool IsLikelyTemporaryGoal(GoalWithState goal)
    {
        // Goals added through ShowAddGoalDialog should legitimately have IsPendingAdd = true
        // For now, be conservative and don't auto-remove flags
        return true; // Keep existing flags for now, let the edit logic prevent future incorrect flagging
    }

    /// <summary>
    /// Emergency method to clear all IsPendingAdd flags from goals in Response data
    /// Use this when goals are incorrectly showing PENDING ADD badges
    /// </summary>
    public void ClearAllPendingAddFlags()
    {
        var goals = GoalService.GetGoals(Response).ToList();
        var hasChanges = false;

        for (int i = 0; i < goals.Count; i++)
        {
            if (goals[i].ContainsKey("IsPendingAdd"))
            {
                var cleanedGoal = new Dictionary<string, object>(goals[i]);
                cleanedGoal.Remove("IsPendingAdd");
                goals[i] = cleanedGoal;
                hasChanges = true;
            }
        }

        if (hasChanges)
        {
            Response.ComplexValue ??= new Dictionary<string, object>();
            Response.ComplexValue[GoalService.GoalsKey] = goals;
            LoadNewGoalsData(); // Refresh local cache
            _goalCountChanged = true; // Force re-render
            StateHasChanged();
        }
    }

    // State tracking for OptimizedComponentBase
    private int _lastGoalCount = 0;
    private bool _goalCountChanged = false;

    protected override bool HasStateChanged()
    {
        var currentCount = allCurrentGoals?.Count ?? 0;
        var hasChanged = currentCount != _lastGoalCount || _goalCountChanged;

        // Reset change flags after checking
        if (_goalCountChanged)
        {
            _goalCountChanged = false;
            _lastGoalCount = currentCount;
        }

        return hasChanged || base.HasStateChanged();
    }

    private DateTime GetGoalAddedDate(Dictionary<string, object> goal)
    {
        // Try to get AddedAt if available, otherwise use a default ordering
        if (goal.TryGetValue("AddedAt", out var addedAt))
        {
            if (addedAt is DateTime dt) return dt;
            if (DateTime.TryParse(addedAt?.ToString(), out var parsed)) return parsed;
        }
        return DateTime.MinValue;
    }

    private Dictionary<string, int> GetGoalsByRole()
    {
        var roleGroups = new Dictionary<string, int>();

        // Count all goals (including pending ones) - now strongly-typed
        foreach (var goal in allCurrentGoals)
        {
            var role = GetDisplayRole(goal.AddedByRole);
            roleGroups[role] = roleGroups.GetValueOrDefault(role, 0) + 1;
        }

        return roleGroups;
    }

    /// <summary>
    /// Renders a strongly-typed GoalWithState object (replaces Dictionary-based rendering)
    /// </summary>
    private RenderFragment RenderTypedGoal(GoalWithState goal) => __builder =>
    {
        <div class="collaborative-goal">
            <RadzenRow>
                <RadzenColumn Size="8">
                    <div class="goal-header">
                        <RadzenText TextStyle="TextStyle.Subtitle1" Class="fw-bold mb-2">
                            @goal.ObjectiveDescription
                        </RadzenText>
                        <div class="goal-badges mb-2">
                            <RadzenBadge Text="@GetDisplayRole(goal.AddedByRole)"
                                       BadgeStyle="@GetRoleBadgeStyle(GetDisplayRole(goal.AddedByRole))"
                                       Class="me-2" />

                            @if (goal.IsPendingDelete)
                            {
                                <RadzenBadge Text="Pending Delete" BadgeStyle="BadgeStyle.Danger" Class="me-2" />
                            }
                            else if (goal.IsPendingModify)
                            {
                                <RadzenBadge Text="Pending Edit" BadgeStyle="BadgeStyle.Warning" Class="me-2" />
                            }
                            else if (goal.IsPendingAdd)
                            {
                                <RadzenBadge Text="Pending Add" BadgeStyle="BadgeStyle.Info" Class="me-2" />
                            }
                        </div>
                    </div>
                </RadzenColumn>
                <RadzenColumn Size="4">
                    @if (!IsReadOnly && !goal.IsPendingDelete)
                    {
                        <div class="d-flex justify-content-end gap-2">
                            <RadzenButton Text="Edit" Icon="edit"
                                        ButtonStyle="ButtonStyle.Light" Size="ButtonSize.Small" Class="me-2"
                                        Click="@(() => EditTypedGoal(goal))" />
                            <RadzenButton Text="Delete" Icon="delete"
                                        ButtonStyle="ButtonStyle.Danger" Size="ButtonSize.Small"
                                        Click="@(() => DeleteTypedGoal(goal))" />
                        </div>
                    }
                    else if (goal.IsPendingDelete)
                    {
                        <div class="d-flex justify-content-end gap-2">
                            <RadzenButton Text="Undo" Icon="undo"
                                        ButtonStyle="ButtonStyle.Light" Size="ButtonSize.Small"
                                        Click="@(() => UndoDeleteTypedGoal(goal))" />
                        </div>
                    }
                </RadzenColumn>
            </RadzenRow>

            <RadzenRow Class="mt-2">
                <RadzenColumn Size="6">
                    <RadzenText TextStyle="TextStyle.Caption" Class="text-muted">Timeframe:</RadzenText>
                    <RadzenText TextStyle="TextStyle.Body2">
                        @goal.TimeframeFrom.ToString("d") - @goal.TimeframeTo.ToString("d")
                    </RadzenText>
                </RadzenColumn>
                <RadzenColumn Size="6">
                    <RadzenText TextStyle="TextStyle.Caption" Class="text-muted">Weight:</RadzenText>
                    <RadzenText TextStyle="TextStyle.Body2">@goal.WeightingPercentage.ToString("0")%</RadzenText>
                </RadzenColumn>
            </RadzenRow>

            <RadzenRow Class="mt-2">
                <RadzenColumn Size="12">
                    <RadzenText TextStyle="TextStyle.Caption" Class="text-muted">Measurement Metric:</RadzenText>
                    <RadzenText TextStyle="TextStyle.Body2">@goal.MeasurementMetric</RadzenText>
                </RadzenColumn>
            </RadzenRow>
        </div>
    };

    /// <summary>
    /// Edit a strongly-typed goal (replaces Dictionary-based edit logic)
    /// </summary>
    private async Task EditTypedGoal(GoalWithState goal)
    {
        var result = await DialogService.OpenAsync<EditGoalDialog>("Edit Goal",
            new Dictionary<string, object>
            {
                { "AssignmentId", AssignmentId },
                { "QuestionId", Question.Id },
                { "GoalId", goal.Id },
                { "ModifiedByRole", await GetLoggedInUserRole() },
                { "InitialObjective", goal.ObjectiveDescription },
                { "InitialMeasurement", goal.MeasurementMetric },
                { "InitialTimeframeFrom", goal.TimeframeFrom },
                { "InitialTimeframeTo", goal.TimeframeTo },
                { "InitialWeighting", goal.WeightingPercentage },
                { "AssignmentWorkflowState", AssignmentWorkflowState }
            },
            new DialogOptions
            {
                Width = "700px",
                Resizable = true,
                Draggable = true,
                CloseDialogOnOverlayClick = false
            });

        if (result is ModifyGoalDto modifyDto)
        {
            // Find the goal in the collection and update it
            var goalIndex = allCurrentGoals.IndexOf(goal);
            if (goalIndex >= 0)
            {
                // Create an updated copy to ensure UI recognizes changes
                var updatedGoal = new GoalWithState
                {
                    Id = goal.Id,
                    QuestionId = goal.QuestionId,
                    AddedByRole = goal.AddedByRole,
                    ObjectiveDescription = modifyDto.ObjectiveDescription ?? goal.ObjectiveDescription,
                    MeasurementMetric = modifyDto.MeasurementMetric ?? goal.MeasurementMetric,
                    TimeframeFrom = modifyDto.TimeframeFrom ?? goal.TimeframeFrom,
                    TimeframeTo = modifyDto.TimeframeTo ?? goal.TimeframeTo,
                    WeightingPercentage = modifyDto.WeightingPercentage ?? goal.WeightingPercentage,
                    AddedAt = goal.AddedAt,
                    AddedByEmployeeId = goal.AddedByEmployeeId,
                    Modifications = goal.Modifications,

                    // Preserve pending state
                    IsPendingAdd = goal.IsPendingAdd,
                    IsPendingDelete = goal.IsPendingDelete,
                    IsPendingModify = goal.IsPendingAdd ? false : true // Only mark as modified if not pending add
                };

                // Replace with updated copy
                allCurrentGoals[goalIndex] = updatedGoal;
            }

            // Save changes back to Response
            SaveGoalsToResponse();
            _goalCountChanged = true;
            await NotifyResponseChanged();

            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Info,
                Summary = "Goal Updated",
                Detail = "Changes will be saved when you click 'Save Progress' or 'Submit'.",
                Duration = 4000
            });

            // Force immediate UI update
            await InvokeAsync(StateHasChanged);
        }
    }

    /// <summary>
    /// Delete a strongly-typed goal (replaces Dictionary-based delete logic)
    /// </summary>
    private async Task DeleteTypedGoal(GoalWithState goal)
    {
        var confirmed = await DialogService.Confirm(
            $"Are you sure you want to delete this goal: '{goal.ObjectiveDescription}'?",
            "Confirm Delete",
            new ConfirmOptions { OkButtonText = "Yes, Delete", CancelButtonText = "Cancel" }
        );

        if (confirmed == true)
        {
            if (goal.IsPendingAdd)
            {
                // Remove pending add goal entirely
                allCurrentGoals.Remove(goal);
            }
            else
            {
                // Mark existing goal for deletion
                goal.IsPendingDelete = true;
                goal.IsPendingModify = false; // Clear modify flag if set
            }

            SaveGoalsToResponse();
            _goalCountChanged = true;

            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Info,
                Summary = "Delete Queued",
                Detail = goal.IsPendingAdd ? "Goal removed." : "Goal will be deleted when you click 'Save Progress' or 'Submit'.",
                Duration = 4000
            });

            await InvokeAsync(StateHasChanged);
        }
    }

    /// <summary>
    /// Undo delete for a strongly-typed goal
    /// </summary>
    private async Task UndoDeleteTypedGoal(GoalWithState goal)
    {
        goal.IsPendingDelete = false;

        SaveGoalsToResponse();
        _goalCountChanged = true;

        NotificationService.Notify(new NotificationMessage
        {
            Severity = NotificationSeverity.Info,
            Summary = "Delete Cancelled",
            Detail = "Goal deletion has been cancelled.",
            Duration = 4000
        });

        await InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// Save strongly-typed goals back to Response data
    /// </summary>
    private void SaveGoalsToResponse()
    {
        Response.ComplexValue ??= new Dictionary<string, object>();
        Response.ComplexValue[GoalService.GoalsKey] = allCurrentGoals.Select(g => g.ToGoalDto()).ToList();
        Response.LastModified = DateTime.Now;
    }

    private BadgeStyle GetRoleBadgeStyle(string role)
    {
        return role == "Employee" ? BadgeStyle.Primary : BadgeStyle.Success;
    }




    private async Task ShowAddGoalDialog()
    {
        var result = await DialogService.OpenAsync<AddGoalDialog>("Add New Goal",
            new Dictionary<string, object>
            {
                { "AssignmentId", AssignmentId },
                { "QuestionId", Question.Id },
                { "AddedByRole", await GetLoggedInUserRole() }
            },
            new DialogOptions
            {
                Width = "700px",
                Resizable = true,
                Draggable = true,
                CloseDialogOnOverlayClick = false
            });

        if (result is AddGoalDto dto)
        {
            // NEW: Create a strongly-typed goal instead of Dictionary
            var newGoal = new GoalWithState
            {
                Id = Guid.NewGuid(), // Temporary ID for pending goal
                QuestionId = Question.Id,
                ObjectiveDescription = dto.ObjectiveDescription ?? "",
                MeasurementMetric = dto.MeasurementMetric ?? "",
                TimeframeFrom = dto.TimeframeFrom,
                TimeframeTo = dto.TimeframeTo,
                WeightingPercentage = dto.WeightingPercentage ?? 0m,
                AddedByRole = dto.AddedByRole ?? "Employee",
                AddedAt = DateTime.UtcNow,
                AddedByEmployeeId = Guid.Empty, // Will be set by backend
                Modifications = new List<GoalModificationDto>(),

                // Mark as pending add
                IsPendingAdd = true,
                IsPendingModify = false,
                IsPendingDelete = false
            };

            // Add to strongly-typed collection and save
            allCurrentGoals.Add(newGoal);
            SaveGoalsToResponse();
            _goalCountChanged = true; // Force re-render for new goal addition
            await NotifyResponseChanged();

            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Info,
                Summary = "Goal Added",
                Detail = "Goal will be saved when you click 'Save Progress' or 'Submit'.",
                Duration = 4000
            });

            await InvokeAsync(StateHasChanged);
        }
    }




    private bool IsInReviewPhase()
    {
        return AssignmentWorkflowState is WorkflowState.InReview or
                                         WorkflowState.ManagerReviewConfirmed or
                                         WorkflowState.EmployeeReviewConfirmed or
                                         WorkflowState.Finalized;
    }

    private async Task<string> GetLoggedInUserRole()
    {
        try
        {
            var roleData = await AuthService.GetMyRoleAsync();
            return roleData?.ApplicationRole.ToString() ?? ApplicationRole.Employee.ToString();
        }
        catch
        {
            return ApplicationRole.Employee.ToString();
        }
    }

    private string GetDisplayRole(string roleString)
    {
        if (string.IsNullOrEmpty(roleString))
            return "Employee";

        return roleString switch
        {
            "Employee" => "Employee",
            "TeamLead" => "Manager",
            "HR" => "Manager",
            "HRLead" => "Manager",
            "Admin" => "Manager",
            "Manager" => "Manager",
            _ => "Employee"
        };
    }

    // Helper properties for parent component integration
    public bool HasPendingChanges => allCurrentGoals.Any(g => g.HasPendingChanges);

    public int GetPendingChangesCount()
    {
        return allCurrentGoals.Count(g => g.HasPendingChanges);
    }

    /// <summary>
    /// Executes all pending goal operations (add/modify/delete).
    /// Returns true if all operations succeed, false if any fail.
    /// </summary>
    public async Task<bool> SavePendingGoalChanges()
    {
        if (!HasPendingChanges)
            return true;

        bool allSucceeded = true;
        var errors = new List<string>();

        // Execute deletes first
        var goalsToDelete = allCurrentGoals.Where(g => g.IsPendingDelete && !g.IsPendingAdd).ToList();
        foreach (var goal in goalsToDelete)
        {
            // DeleteGoalAsync not yet implemented in API
            allSucceeded = false;
            errors.Add($"Delete operation not yet implemented in backend API");
        }

        // Execute modifies
        var goalsToModify = allCurrentGoals.Where(g => g.IsPendingModify && !g.IsPendingAdd).ToList();
        foreach (var goal in goalsToModify)
        {
            try
            {
                var modifyDto = new ModifyGoalDto
                {
                    ObjectiveDescription = goal.ObjectiveDescription,
                    MeasurementMetric = goal.MeasurementMetric,
                    TimeframeFrom = goal.TimeframeFrom,
                    TimeframeTo = goal.TimeframeTo,
                    WeightingPercentage = goal.WeightingPercentage
                };

                var result = await GoalApiService.ModifyGoalAsync(AssignmentId, goal.Id, modifyDto);
                if (result.Succeeded)
                {
                    goal.IsPendingModify = false;
                }
                else
                {
                    allSucceeded = false;
                    errors.Add($"Modify failed: {result.ErrorMessage}");
                }
            }
            catch (Exception ex)
            {
                allSucceeded = false;
                errors.Add($"Modify error: {ex.Message}");
            }
        }

        // Execute adds
        var goalsToAdd = allCurrentGoals.Where(g => g.IsPendingAdd).ToList();
        foreach (var goal in goalsToAdd)
        {
            try
            {
                var addDto = new AddGoalDto
                {
                    QuestionId = goal.QuestionId,
                    AddedByRole = goal.AddedByRole,
                    ObjectiveDescription = goal.ObjectiveDescription,
                    MeasurementMetric = goal.MeasurementMetric,
                    TimeframeFrom = goal.TimeframeFrom,
                    TimeframeTo = goal.TimeframeTo,
                    WeightingPercentage = goal.WeightingPercentage
                };

                var result = await GoalApiService.AddGoalAsync(AssignmentId, addDto);
                if (result.Succeeded)
                {
                    goal.IsPendingAdd = false;
                    // Update the goal with the backend-assigned ID if available
                    if (result.Payload != Guid.Empty)
                    {
                        goal.Id = result.Payload;
                    }
                }
                else
                {
                    allSucceeded = false;
                    errors.Add($"Add failed: {result.ErrorMessage}");
                }
            }
            catch (Exception ex)
            {
                allSucceeded = false;
                errors.Add($"Add error: {ex.Message}");
            }
        }

        // Remove goals that were marked for deletion and are pending adds (temporary goals)
        var tempGoalsToRemove = allCurrentGoals.Where(g => g.IsPendingDelete && g.IsPendingAdd).ToList();
        foreach (var goal in tempGoalsToRemove)
        {
            allCurrentGoals.Remove(goal);
        }

        // Update Response data
        SaveGoalsToResponse();
        await NotifyResponseChanged();
        await InvokeAsync(StateHasChanged);

        // Show result notification
        if (allSucceeded)
        {
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Success,
                Summary = "Goals Saved",
                Detail = "All goal changes have been saved successfully.",
                Duration = 4000
            });
        }
        else
        {
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Error,
                Summary = "Partial Save",
                Detail = $"Some goal operations failed: {string.Join("; ", errors)}",
                Duration = 8000
            });
        }

        return allSucceeded;
    }

    private async Task ReloadGoalData()
    {
        try
        {
            var result = await GoalApiService.GetGoalQuestionDataAsync(AssignmentId, Question.Id);

            if (result.Succeeded && result.Payload != null)
            {
                // Convert to strongly-typed goals and save to Response
                var goalDtoList = result.Payload.Goals.ToList();
                Response.ComplexValue ??= new Dictionary<string, object>();
                Response.ComplexValue[GoalService.GoalsKey] = goalDtoList;
                Response.LastModified = DateTime.Now;

                LoadGoalsFromResponse();
                await NotifyResponseChanged();
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Error,
                Summary = "Error",
                Detail = $"Failed to reload goal data: {ex.Message}",
                Duration = 6000
            });
        }
    }

    private async Task NotifyResponseChanged()
    {
        if (OnResponseChanged.HasDelegate)
        {
            await OnResponseChanged.InvokeAsync(Response);
        }
    }




}

<style>
.new-goals-section .collaborative-goal {
    transition: all 0.2s ease;
}

.new-goals-section .goal-card {
    transition: all 0.2s ease;
    border-color: var(--border-light, #e2e8f0) !important;
}

.new-goals-section .goal-card:hover {
    border-color: var(--primary-color, #2563eb) !important;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.new-goals-section .pending-goal {
    border-style: dashed !important;
    border-color: var(--rz-info) !important;
    background-color: rgba(33, 150, 243, 0.05);
}

.new-goals-section .pending-delete {
    opacity: 0.6;
    background-color: rgba(244, 67, 54, 0.05);
}

.new-goals-section .pending-modify {
    background-color: rgba(255, 152, 0, 0.05);
}

.new-goals-section .goal-actions {
    display: flex;
    gap: 0.25rem;
    flex-shrink: 0;
}

.new-goals-section .goal-badges .rz-badge {
    font-size: 0.75rem;
}

.new-goals-section .goals-summary {
    border: 1px solid var(--border-light, #e2e8f0);
}

.new-goals-section .add-goal-section {
    display: flex;
    align-items: center;
    gap: 1rem;
}
</style>