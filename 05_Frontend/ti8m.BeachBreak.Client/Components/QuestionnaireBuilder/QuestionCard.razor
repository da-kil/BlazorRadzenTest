@using Radzen
@using Radzen.Blazor
@using ti8m.BeachBreak.Client.Models
@using ti8m.BeachBreak.Client.Components.Shared
@inject DialogService DialogService


<div class="competencies-container">
        <!-- Assessment Configuration -->
        @if (Question.Type == QuestionType.Assessment)
        {
            var competencies = GetOrderedCompetencies();
            <div class="competencies-config">

                @if (competencies.Count == 0)
                {
                    <div class="text-center p-3 text-muted">
                        <RadzenIcon Icon="self_improvement" Style="font-size: 1.5rem; opacity: 0.5; color: var(--primary-color);" />
                        <div class="mt-2 small">No competencies configured</div>
                    </div>
                }
                else
                {
                    @for (int i = 0; i < competencies.Count; i++)
                    {
                        var competencyIndex = i;
                        var competency = competencies[competencyIndex];

                        <div class="competency-item mb-3 p-3 border rounded bg-white">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <div class="d-flex align-items-center gap-2">
                                    <div class="competency-number bg-primary text-white rounded-circle d-flex align-items-center justify-content-center"
                                         style="width: 24px; height: 24px; font-size: 0.75rem; font-weight: bold;">
                                        @(competencyIndex + 1)
                                    </div>
                                    <RadzenText TextStyle="TextStyle.Body2" Class="fw-bold mb-0">
                                        Competency @(competencyIndex + 1)
                                    </RadzenText>
                                </div>
                                <div class="d-flex gap-1">
                                    <AsyncButton ButtonStyle="ButtonStyle.Light"
                                                Icon="keyboard_arrow_up"
                                                Size="ButtonSize.ExtraSmall"
                                                Click="@(() => MoveCompetencyUp(competencyIndex))"
                                                Disabled="@(competencyIndex == 0 || !Template.IsAvailableForEditing)"
                                                Title="Move up" />
                                    <AsyncButton ButtonStyle="ButtonStyle.Light"
                                                Icon="keyboard_arrow_down"
                                                Size="ButtonSize.ExtraSmall"
                                                Click="@(() => MoveCompetencyDown(competencyIndex))"
                                                Disabled="@(competencyIndex == competencies.Count - 1 || !Template.IsAvailableForEditing)"
                                                Title="Move down" />
                                    <AsyncButton ButtonStyle="ButtonStyle.Danger"
                                                ProcessingText="Deleting"
                                                Icon="delete_outline"
                                                Size="ButtonSize.ExtraSmall"
                                                Click="@(() => RemoveCompetency(competencyIndex))"
                                                Title="Delete competency"
                                                Disabled="@(!Template.IsAvailableForEditing)" />
                                </div>
                            </div>
                            <div class="competency-input-row">
                                <div class="input-field-container">
                                    <RadzenTextBox Value="@competency.Title"
                                                  ValueChanged="@((string value) => UpdateCompetencyTitle(competencyIndex, value))"
                                                  Placeholder="Enter competency title..."
                                                  Disabled="@(!Template.IsAvailableForEditing)"
                                                  Class="@GetCompetencyTitleValidationClass(competencyIndex)"
                                                  @onblur="@(() => ValidateCompetencyTitle(competencyIndex))" />
                                    @if (!GetCompetencyTitleValid(competencyIndex) && GetCompetencyTitleValidated(competencyIndex))
                                    {
                                        <div class="validation-message">
                                            <RadzenIcon Icon="error_outline" Style="font-size: 0.85rem;" Class="me-1" />
                                            Competency title is required
                                        </div>
                                    }
                                </div>
                                <div class="required-checkbox-container">
                                    <RadzenCheckBox Value="@GetCompetencyRequired(competencyIndex)"
                                                   ValueChanged="@((bool value) => UpdateCompetencyRequired(competencyIndex, value))"
                                                   Name="@($"comp_req_{Question.Id}_{competencyIndex}")"
                                                   Disabled="@(!Template.IsAvailableForEditing)" />
                                    <RadzenLabel Text="Required" Component="@($"comp_req_{Question.Id}_{competencyIndex}")" Class="ms-2" />
                                </div>
                            </div>
                            <div class="mb-0">
                                <RadzenTextArea Value="@competency.Description"
                                               ValueChanged="@((string value) => UpdateCompetencyDescription(competencyIndex, value))"
                                               Placeholder="Describe what this competency evaluates..."
                                               Rows="2"
                                               Class="w-100" />
                            </div>
                        </div>
                    }
                }
            </div>
        }

        <!-- Goal Configuration -->
        @if (Question.Type == QuestionType.Goal)
        {
            <div class="goal-config text-center p-4">
                <RadzenIcon Icon="flag" Style="font-size: 2rem; color: var(--rz-primary);" Class="mb-3" />
                <RadzenText TextStyle="TextStyle.Body1" Class="mb-2 fw-bold">
                    Goal Question Type
                </RadzenText>
                <RadzenText TextStyle="TextStyle.Body2" Class="text-muted mb-3">
                    No template configuration is required for Goal questions.
                </RadzenText>
                <RadzenAlert AlertStyle="AlertStyle.Info" Shade="Shade.Lighter" Class="mb-0" ShowIcon="false">
                    <RadzenText TextStyle="TextStyle.Caption" Class="d-block mb-1">
                        Goals are added dynamically during the questionnaire workflow:
                    </RadzenText>
                    <ul class="text-start small mb-0" style="line-height: 1.8;">
                        <li>Employee and Manager add goals during their completion phases</li>
                        <li>Goals can be linked to predecessor questionnaires for rating</li>
                        <li>Each goal includes objective, timeframe, measurement, and weighting</li>
                    </ul>
                </RadzenAlert>
            </div>
        }

        <!-- Text Question Configuration -->
        @if (Question.Type == QuestionType.TextQuestion)
        {
            var textSections = GetOrderedTextSections();
            <div class="text-sections-config">
                @if (textSections.Count == 0)
                {
                    <div class="text-center p-3 text-muted">
                        <RadzenIcon Icon="psychology" Style="font-size: 1.5rem; opacity: 0.5; color: var(--info-color);" />
                        <div class="mt-2 small">No text sections configured</div>
                    </div>
                }
                else
                {
                    @for (int i = 0; i < textSections.Count; i++)
                    {
                        var sectionIndex = i;
                        var textSection = textSections[sectionIndex];

                        <div class="text-section-item rz-background-color-base-100 rz-p-3 rz-mb-2 rz-border-radius-3" style="border: 1px solid var(--rz-base-300);">
                            <div class="d-flex justify-content-between align-items-start mb-2">
                                <RadzenText TextStyle="TextStyle.Body2" Class="fw-bold question-text-response">
                                    Text Section @(sectionIndex + 1)
                                </RadzenText>
                                <div class="d-flex gap-1">
                                    <AsyncButton ButtonStyle="ButtonStyle.Light"
                                                Icon="keyboard_arrow_up"
                                                Size="ButtonSize.ExtraSmall"
                                                Click="@(() => MoveTextSectionUp(sectionIndex))"
                                                Disabled="@(sectionIndex == 0 || !Template.IsAvailableForEditing)"
                                                Title="Move up" />
                                    <AsyncButton ButtonStyle="ButtonStyle.Light"
                                                Icon="keyboard_arrow_down"
                                                Size="ButtonSize.ExtraSmall"
                                                Click="@(() => MoveTextSectionDown(sectionIndex))"
                                                Disabled="@(sectionIndex == textSections.Count - 1 || !Template.IsAvailableForEditing)"
                                                Title="Move down" />
                                    <AsyncButton ButtonStyle="ButtonStyle.Danger"
                                                ProcessingText="Deleting"
                                                Icon="delete"
                                                Size="ButtonSize.ExtraSmall"
                                                Click="@(() => RemoveTextSection(sectionIndex))"
                                                Title="Delete"
                                                Disabled="@(!Template.IsAvailableForEditing)" />
                                </div>
                            </div>
                            <div class="text-section-input-row">
                                <div class="input-field-container">
                                    <RadzenTextBox Value="@textSection.Title"
                                                  ValueChanged="@((string value) => UpdateTextSectionTitle(sectionIndex, value))"
                                                  Placeholder="Enter section title..."
                                                  Disabled="@(!Template.IsAvailableForEditing)"
                                                  Class="@GetTextSectionTitleValidationClass(sectionIndex)"
                                                  @onblur="@(() => ValidateTextSectionTitle(sectionIndex))" />
                                    @if (!GetTextSectionTitleValid(sectionIndex) && GetTextSectionTitleValidated(sectionIndex))
                                    {
                                        <div class="validation-message">
                                            <RadzenIcon Icon="error_outline" Style="font-size: 0.85rem;" Class="me-1" />
                                            Text section title is required
                                        </div>
                                    }
                                </div>
                                <div class="required-checkbox-container">
                                    <RadzenCheckBox Value="@GetTextSectionRequired(sectionIndex)"
                                                   ValueChanged="@((bool value) => UpdateTextSectionRequired(sectionIndex, value))"
                                                   Name="@($"text_req_{Question.Id}_{sectionIndex}")"
                                                   Disabled="@(!Template.IsAvailableForEditing)" />
                                    <RadzenLabel Text="Required" Component="@($"text_req_{Question.Id}_{sectionIndex}")" Class="ms-2" />
                                </div>
                            </div>
                            <div class="mb-2">
                                <RadzenTextArea Value="@textSection.Description"
                                               ValueChanged="@((string value) => UpdateTextSectionDescription(sectionIndex, value))"
                                               Placeholder="Describe this text section..."
                                               Rows="2"
                                               Class="w-100" />
                            </div>
                        </div>
                    }
                }
            </div>
        }

        <!-- Question-level required flag is removed as individual items now have their own required flags -->
</div>

@code {
    [Parameter, EditorRequired] public QuestionItem Question { get; set; } = null!;
    [Parameter, EditorRequired] public QuestionnaireTemplate Template { get; set; } = null!;
    [Parameter, EditorRequired] public bool CanMoveUp { get; set; }
    [Parameter, EditorRequired] public bool CanMoveDown { get; set; }
    [Parameter, EditorRequired] public Dictionary<QuestionType, string> QuestionTypeLabels { get; set; } = null!;


    [Parameter] public EventCallback OnEdit { get; set; }
    [Parameter] public EventCallback OnMoveUp { get; set; }
    [Parameter] public EventCallback OnMoveDown { get; set; }
    [Parameter] public EventCallback OnDelete { get; set; }
    [Parameter] public EventCallback OnRequiredChanged { get; set; }

    // Validation state
    private bool isTitleValid = true;
    private bool hasBeenValidated = false;

    // Competency validation state
    private Dictionary<int, bool> competencyTitleValid = new();
    private Dictionary<int, bool> competencyTitleValidated = new();

    // Goal category validation state
    private Dictionary<int, bool> goalCategoryTitleValid = new();
    private Dictionary<int, bool> goalCategoryTitleValidated = new();

    // Text section validation state
    private Dictionary<int, bool> textSectionTitleValid = new();
    private Dictionary<int, bool> textSectionTitleValidated = new();

    private async Task OnEditClick() => await OnEdit.InvokeAsync();
    private async Task OnMoveUpClick() => await OnMoveUp.InvokeAsync();
    private async Task OnMoveDownClick() => await OnMoveDown.InvokeAsync();
    private async Task OnDeleteClick() => await OnDelete.InvokeAsync();

    // Validation methods
    private void ValidateTitle()
    {
        hasBeenValidated = true;
        isTitleValid = !string.IsNullOrWhiteSpace(Question.Title);
        StateHasChanged();
    }

    private string GetTitleValidationClass()
    {
        var baseClass = "w-100";
        if (hasBeenValidated && !isTitleValid)
        {
            return $"{baseClass} border-danger";
        }
        return baseClass;
    }

    public bool IsQuestionValid()
    {
        ValidateTitle();

        // Validate question content based on type
        bool contentValid = true;

        if (Question.Type == QuestionType.Assessment)
        {
            var competencies = GetOrderedCompetencies();
            for (int i = 0; i < competencies.Count; i++)
            {
                ValidateCompetencyTitle(i);
                if (!GetCompetencyTitleValid(i))
                    contentValid = false;
            }
        }
        else if (Question.Type == QuestionType.Goal)
        {
            // Goal questions don't use template items - always valid
            contentValid = true;
        }
        else if (Question.Type == QuestionType.TextQuestion)
        {
            var sections = GetOrderedTextSections();
            for (int i = 0; i < sections.Count; i++)
            {
                ValidateTextSectionTitle(i);
                if (!GetTextSectionTitleValid(i))
                    contentValid = false;
            }
        }

        return isTitleValid && contentValid;
    }

    // Competency validation methods
    private void ValidateCompetencyTitle(int index)
    {
        var competencies = GetOrderedCompetencies();
        if (index >= 0 && index < competencies.Count)
        {
            competencyTitleValidated[index] = true;
            competencyTitleValid[index] = !string.IsNullOrWhiteSpace(competencies[index].Title);
            StateHasChanged();
        }
    }

    private bool GetCompetencyTitleValid(int index)
    {
        return competencyTitleValid.GetValueOrDefault(index, true);
    }

    private bool GetCompetencyTitleValidated(int index)
    {
        return competencyTitleValidated.GetValueOrDefault(index, false);
    }

    private string GetCompetencyTitleValidationClass(int index)
    {
        var baseClass = "w-100 mb-2";
        if (GetCompetencyTitleValidated(index) && !GetCompetencyTitleValid(index))
        {
            return $"{baseClass} border-danger";
        }
        return baseClass;
    }

    // Goal category validation methods
    private void ValidateGoalCategoryTitle(int index)
    {
        var categories = GetOrderedGoalCategories();
        if (index >= 0 && index < categories.Count)
        {
            goalCategoryTitleValidated[index] = true;
            goalCategoryTitleValid[index] = !string.IsNullOrWhiteSpace(categories[index].Title);
            StateHasChanged();
        }
    }

    private bool GetGoalCategoryTitleValid(int index)
    {
        return goalCategoryTitleValid.GetValueOrDefault(index, true);
    }

    private bool GetGoalCategoryTitleValidated(int index)
    {
        return goalCategoryTitleValidated.GetValueOrDefault(index, false);
    }

    private string GetGoalCategoryTitleValidationClass(int index)
    {
        var baseClass = "w-100 mb-2";
        if (GetGoalCategoryTitleValidated(index) && !GetGoalCategoryTitleValid(index))
        {
            return $"{baseClass} border-danger";
        }
        return baseClass;
    }

    // Text section validation methods
    private void ValidateTextSectionTitle(int index)
    {
        var sections = GetOrderedTextSections();
        if (index >= 0 && index < sections.Count)
        {
            textSectionTitleValidated[index] = true;
            textSectionTitleValid[index] = !string.IsNullOrWhiteSpace(sections[index].Title);
            StateHasChanged();
        }
    }

    private bool GetTextSectionTitleValid(int index)
    {
        return textSectionTitleValid.GetValueOrDefault(index, true);
    }

    private bool GetTextSectionTitleValidated(int index)
    {
        return textSectionTitleValidated.GetValueOrDefault(index, false);
    }

    private string GetTextSectionTitleValidationClass(int index)
    {
        var baseClass = "w-100 mb-2";
        if (GetTextSectionTitleValidated(index) && !GetTextSectionTitleValid(index))
        {
            return $"{baseClass} border-danger";
        }
        return baseClass;
    }

    private string GetQuestionTypeIcon(QuestionType type) => type switch
    {
        QuestionType.Assessment => "self_improvement",
        QuestionType.Goal => "track_changes",
        QuestionType.TextQuestion => "psychology",
        _ => "help"
    };


    // Assessment methods
    private List<CompetencyDefinition> GetCompetenciesFromConfiguration()
    {
        if (Question.Configuration.ContainsKey("Competencies"))
        {
            var competenciesObj = Question.Configuration["Competencies"];

            // Handle direct cast (when set in editor)
            if (competenciesObj is List<CompetencyDefinition> competencies)
            {
                return competencies;
            }

            // Handle JSON deserialization (when loaded from API)
            if (competenciesObj is System.Text.Json.JsonElement jsonElement)
            {
                try
                {
                    if (jsonElement.ValueKind == System.Text.Json.JsonValueKind.Array)
                    {
                        return System.Text.Json.JsonSerializer.Deserialize<List<CompetencyDefinition>>(jsonElement.GetRawText()) ?? new List<CompetencyDefinition>();
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error deserializing competencies: {ex.Message}");
                }
            }

            // Handle string representation (backup case)
            if (competenciesObj is string jsonString)
            {
                try
                {
                    return System.Text.Json.JsonSerializer.Deserialize<List<CompetencyDefinition>>(jsonString) ?? new List<CompetencyDefinition>();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error deserializing competencies from string: {ex.Message}");
                }
            }
        }

        // Return default competencies if none exist
        return new List<CompetencyDefinition>();
    }

    private List<CompetencyDefinition> GetOrderedCompetencies()
    {
        var competencies = GetCompetenciesFromConfiguration();

        // Check if we need to initialize Order values (for legacy data or duplicates)
        var orderValues = competencies.Select(c => c.Order).ToList();
        var distinctOrderCount = orderValues.Distinct().Count();
        var hasUnsetOrders = orderValues.Any(o => o == 0) && competencies.Count > 1;
        var hasDuplicateOrders = distinctOrderCount != competencies.Count;

        if (hasUnsetOrders || hasDuplicateOrders)
        {
            // Re-assign all Order values sequentially
            for (int i = 0; i < competencies.Count; i++)
            {
                competencies[i].Order = i;
            }
            Question.Configuration["Competencies"] = competencies;
        }

        return competencies.OrderBy(c => c.Order).ToList();
    }


    private async Task RemoveCompetency(int displayIndex)
    {
        var orderedCompetencies = GetOrderedCompetencies();
        if (displayIndex >= 0 && displayIndex < orderedCompetencies.Count)
        {
            var competencyToRemove = orderedCompetencies[displayIndex];
            var competencyName = string.IsNullOrWhiteSpace(competencyToRemove.Title) ? $"Competency {displayIndex + 1}" : competencyToRemove.Title;
            var confirmed = await DialogService.Confirm($"Are you sure you want to delete '{competencyName}'?", "Delete Competency",
                new ConfirmOptions() { OkButtonText = "Yes", CancelButtonText = "No" });

            if (confirmed == true)
            {
                var allCompetencies = GetCompetenciesFromConfiguration();
                allCompetencies.Remove(competencyToRemove);
                Question.Configuration["Competencies"] = allCompetencies;
                StateHasChanged();
            }
        }
    }

    private void UpdateCompetencyTitle(int displayIndex, string value)
    {
        var competencies = GetCompetenciesFromConfiguration();
        var orderedCompetencies = competencies.OrderBy(c => c.Order).ToList();
        if (displayIndex >= 0 && displayIndex < orderedCompetencies.Count)
        {
            orderedCompetencies[displayIndex].Title = value ?? "";
            // Store the original list (modifications already applied via reference)
            Question.Configuration["Competencies"] = competencies;
            StateHasChanged();
        }
    }

    private void UpdateCompetencyDescription(int displayIndex, string value)
    {
        var competencies = GetCompetenciesFromConfiguration();
        var orderedCompetencies = competencies.OrderBy(c => c.Order).ToList();
        if (displayIndex >= 0 && displayIndex < orderedCompetencies.Count)
        {
            orderedCompetencies[displayIndex].Description = value ?? "";
            // Store the original list (modifications already applied via reference)
            Question.Configuration["Competencies"] = competencies;
            StateHasChanged();
        }
    }

    // Goal Achievement methods
    private List<GoalCategory> GetGoalCategoriesFromConfiguration()
    {
        if (Question.Configuration.ContainsKey("GoalCategories"))
        {
            var goalCategoriesObj = Question.Configuration["GoalCategories"];

            // Handle direct cast (when set in editor)
            if (goalCategoriesObj is List<GoalCategory> categories)
            {
                return categories;
            }

            // Handle JSON deserialization (when loaded from API)
            if (goalCategoriesObj is System.Text.Json.JsonElement jsonElement)
            {
                try
                {
                    if (jsonElement.ValueKind == System.Text.Json.JsonValueKind.Array)
                    {
                        return System.Text.Json.JsonSerializer.Deserialize<List<GoalCategory>>(jsonElement.GetRawText()) ?? new List<GoalCategory>();
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error deserializing goal categories: {ex.Message}");
                }
            }

            // Handle string representation (backup case)
            if (goalCategoriesObj is string jsonString)
            {
                try
                {
                    return System.Text.Json.JsonSerializer.Deserialize<List<GoalCategory>>(jsonString) ?? new List<GoalCategory>();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error deserializing goal categories from string: {ex.Message}");
                }
            }

            // Handle List<object> from API deserialization
            // Note: List<object> is necessary here because JSON API data sometimes comes as untyped objects
            // that need to be converted to strongly-typed GoalCategory objects
            if (goalCategoriesObj is List<object> objectList)
            {
                try
                {
                    var json = System.Text.Json.JsonSerializer.Serialize(objectList);
                    return System.Text.Json.JsonSerializer.Deserialize<List<GoalCategory>>(json) ?? new List<GoalCategory>();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error deserializing goal categories from API List<object>: {ex.Message}");
                }
            }
        }
        return new List<GoalCategory>();
    }

    private List<GoalCategory> GetOrderedGoalCategories()
    {
        var categories = GetGoalCategoriesFromConfiguration();

        // Check if we need to initialize Order values (for legacy data or duplicates)
        var orderValues = categories.Select(c => c.Order).ToList();
        var distinctOrderCount = orderValues.Distinct().Count();
        var hasUnsetOrders = orderValues.Any(o => o == 0) && categories.Count > 1;
        var hasDuplicateOrders = distinctOrderCount != categories.Count;

        if (hasUnsetOrders || hasDuplicateOrders)
        {
            // Re-assign all Order values sequentially
            for (int i = 0; i < categories.Count; i++)
            {
                categories[i].Order = i;
            }
            Question.Configuration["GoalCategories"] = categories;
        }

        return categories.OrderBy(c => c.Order).ToList();
    }


    private async Task RemoveGoalCategory(int index)
    {
        var categories = GetGoalCategoriesFromConfiguration();
        if (index >= 0 && index < categories.Count)
        {
            var categoryName = string.IsNullOrWhiteSpace(categories[index].Title) ? $"Goal Category {index + 1}" : categories[index].Title;
            var confirmed = await DialogService.Confirm($"Are you sure you want to delete '{categoryName}'?", "Delete Goal Category",
                new ConfirmOptions() { OkButtonText = "Yes", CancelButtonText = "No" });

            if (confirmed == true)
            {
                categories.RemoveAt(index);
                Question.Configuration["GoalCategories"] = categories;
                StateHasChanged();
            }
        }
    }

    private void UpdateGoalCategoryTitle(int index, string value)
    {
        var categories = GetGoalCategoriesFromConfiguration();
        if (index >= 0 && index < categories.Count)
        {
            categories[index].Title = value ?? "";
            Question.Configuration["GoalCategories"] = categories;
            StateHasChanged();
        }
    }

    private void UpdateGoalCategoryDescription(int index, string value)
    {
        var categories = GetGoalCategoriesFromConfiguration();
        if (index >= 0 && index < categories.Count)
        {
            categories[index].Description = value ?? "";
            Question.Configuration["GoalCategories"] = categories;
            StateHasChanged();
        }
    }

    // Text Question methods
    private List<TextSection> GetTextSectionsFromConfiguration()
    {
        if (Question.Configuration.ContainsKey("TextSections"))
        {
            var textSectionsObj = Question.Configuration["TextSections"];

            // Handle direct cast (when set in editor)
            if (textSectionsObj is List<TextSection> sections)
            {
                return sections;
            }

            // Handle JSON deserialization (when loaded from API)
            if (textSectionsObj is System.Text.Json.JsonElement jsonElement)
            {
                try
                {
                    if (jsonElement.ValueKind == System.Text.Json.JsonValueKind.Array)
                    {
                        return System.Text.Json.JsonSerializer.Deserialize<List<TextSection>>(jsonElement.GetRawText()) ?? new List<TextSection>();
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error deserializing text sections: {ex.Message}");
                }
            }

            // Handle string representation (backup case)
            if (textSectionsObj is string jsonString)
            {
                try
                {
                    return System.Text.Json.JsonSerializer.Deserialize<List<TextSection>>(jsonString) ?? new List<TextSection>();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error deserializing text sections from string: {ex.Message}");
                }
            }

            // Handle List<object> from API deserialization
            // Note: List<object> is necessary here because JSON API data sometimes comes as untyped objects
            // that need to be converted to strongly-typed TextSection objects
            if (textSectionsObj is List<object> objectList)
            {
                try
                {
                    var json = System.Text.Json.JsonSerializer.Serialize(objectList);
                    return System.Text.Json.JsonSerializer.Deserialize<List<TextSection>>(json) ?? new List<TextSection>();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error deserializing text sections from API List<object>: {ex.Message}");
                }
            }
        }

        // Check for legacy format and convert
        if (Question.Configuration.ContainsKey("SectionTitle") || Question.Configuration.ContainsKey("SectionDescription"))
        {
            return new List<TextSection>
            {
                new TextSection
                {
                    Title = Question.Configuration.ContainsKey("SectionTitle") ? Question.Configuration["SectionTitle"].ToString() ?? "" : "",
                    Description = Question.Configuration.ContainsKey("SectionDescription") ? Question.Configuration["SectionDescription"].ToString() ?? "" : "",
                    IsRequired = false
                }
            };
        }

        return new List<TextSection>();
    }

    private List<TextSection> GetOrderedTextSections()
    {
        var sections = GetTextSectionsFromConfiguration();

        // Check if we need to initialize Order values (for legacy data or duplicates)
        var orderValues = sections.Select(s => s.Order).ToList();
        var distinctOrderCount = orderValues.Distinct().Count();
        var hasUnsetOrders = orderValues.Any(o => o == 0) && sections.Count > 1;
        var hasDuplicateOrders = distinctOrderCount != sections.Count;

        if (hasUnsetOrders || hasDuplicateOrders)
        {
            // Re-assign all Order values sequentially
            for (int i = 0; i < sections.Count; i++)
            {
                sections[i].Order = i;
            }
            Question.Configuration["TextSections"] = sections;
        }

        return sections.OrderBy(s => s.Order).ToList();
    }


    private async Task RemoveTextSection(int index)
    {
        var sections = GetTextSectionsFromConfiguration();
        if (index >= 0 && index < sections.Count)
        {
            var sectionName = string.IsNullOrWhiteSpace(sections[index].Title) ? $"Text Section {index + 1}" : sections[index].Title;
            var confirmed = await DialogService.Confirm($"Are you sure you want to delete '{sectionName}'?", "Delete Text Section",
                new ConfirmOptions() { OkButtonText = "Yes", CancelButtonText = "No" });

            if (confirmed == true)
            {
                sections.RemoveAt(index);
                Question.Configuration["TextSections"] = sections;
                StateHasChanged();
            }
        }
    }

    private void UpdateTextSectionTitle(int index, string value)
    {
        var sections = GetTextSectionsFromConfiguration();
        if (index >= 0 && index < sections.Count)
        {
            sections[index].Title = value ?? "";
            Question.Configuration["TextSections"] = sections;
            StateHasChanged();
        }
    }

    private void UpdateTextSectionDescription(int index, string value)
    {
        var sections = GetTextSectionsFromConfiguration();
        if (index >= 0 && index < sections.Count)
        {
            sections[index].Description = value ?? "";
            Question.Configuration["TextSections"] = sections;
            StateHasChanged();
        }
    }

    private void MoveTextSectionUp(int displayIndex)
    {
        var sections = GetOrderedTextSections();
        if (displayIndex > 0 && displayIndex < sections.Count)
        {
            // Simple array swap - exactly like the original working code
            (sections[displayIndex], sections[displayIndex - 1]) = (sections[displayIndex - 1], sections[displayIndex]);

            // Now update Order properties to match new positions
            for (int i = 0; i < sections.Count; i++)
            {
                sections[i].Order = i;
            }

            Question.Configuration["TextSections"] = sections;
            StateHasChanged();
        }
    }

    private void MoveTextSectionDown(int displayIndex)
    {
        var sections = GetOrderedTextSections();
        if (displayIndex >= 0 && displayIndex < sections.Count - 1)
        {
            // Simple array swap - exactly like the original working code
            (sections[displayIndex], sections[displayIndex + 1]) = (sections[displayIndex + 1], sections[displayIndex]);

            // Now update Order properties to match new positions
            for (int i = 0; i < sections.Count; i++)
            {
                sections[i].Order = i;
            }

            Question.Configuration["TextSections"] = sections;
            StateHasChanged();
        }
    }

    // Required flag methods for competencies
    private bool GetCompetencyRequired(int displayIndex)
    {
        var orderedCompetencies = GetOrderedCompetencies();
        if (displayIndex >= 0 && displayIndex < orderedCompetencies.Count)
        {
            return orderedCompetencies[displayIndex].IsRequired;
        }
        return false;
    }

    private async Task UpdateCompetencyRequired(int displayIndex, bool value)
    {
        var orderedCompetencies = GetOrderedCompetencies();
        if (displayIndex >= 0 && displayIndex < orderedCompetencies.Count)
        {
            orderedCompetencies[displayIndex].IsRequired = value;
            Question.Configuration["Competencies"] = GetCompetenciesFromConfiguration();
            StateHasChanged();
            await OnRequiredChanged.InvokeAsync();
        }
    }

    private void MoveCompetencyUp(int displayIndex)
    {
        var competencies = GetOrderedCompetencies();
        if (displayIndex > 0 && displayIndex < competencies.Count)
        {
            // Simple array swap - exactly like the original working code
            (competencies[displayIndex], competencies[displayIndex - 1]) = (competencies[displayIndex - 1], competencies[displayIndex]);

            // Now update Order properties to match new positions
            for (int i = 0; i < competencies.Count; i++)
            {
                competencies[i].Order = i;
            }

            Question.Configuration["Competencies"] = competencies;
            StateHasChanged();
        }
    }

    private void MoveCompetencyDown(int displayIndex)
    {
        var competencies = GetOrderedCompetencies();
        if (displayIndex >= 0 && displayIndex < competencies.Count - 1)
        {
            // Simple array swap - exactly like the original working code
            (competencies[displayIndex], competencies[displayIndex + 1]) = (competencies[displayIndex + 1], competencies[displayIndex]);

            // Now update Order properties to match new positions
            for (int i = 0; i < competencies.Count; i++)
            {
                competencies[i].Order = i;
            }

            Question.Configuration["Competencies"] = competencies;
            StateHasChanged();
        }
    }

    // Required flag methods for goal categories
    private bool GetGoalCategoryRequired(int index)
    {
        var categories = GetGoalCategoriesFromConfiguration();
        if (index >= 0 && index < categories.Count)
        {
            return categories[index].IsRequired;
        }
        return false;
    }

    private async Task UpdateGoalCategoryRequired(int index, bool value)
    {
        var categories = GetGoalCategoriesFromConfiguration();
        if (index >= 0 && index < categories.Count)
        {
            categories[index].IsRequired = value;
            Question.Configuration["GoalCategories"] = categories;
            StateHasChanged();
            await OnRequiredChanged.InvokeAsync();
        }
    }

    private void MoveGoalCategoryUp(int displayIndex)
    {
        var categories = GetOrderedGoalCategories();
        if (displayIndex > 0 && displayIndex < categories.Count)
        {
            // Simple array swap - exactly like the original working code
            (categories[displayIndex], categories[displayIndex - 1]) = (categories[displayIndex - 1], categories[displayIndex]);

            // Now update Order properties to match new positions
            for (int i = 0; i < categories.Count; i++)
            {
                categories[i].Order = i;
            }

            Question.Configuration["GoalCategories"] = categories;
            StateHasChanged();
        }
    }

    private void MoveGoalCategoryDown(int displayIndex)
    {
        var categories = GetOrderedGoalCategories();
        if (displayIndex >= 0 && displayIndex < categories.Count - 1)
        {
            // Simple array swap - exactly like the original working code
            (categories[displayIndex], categories[displayIndex + 1]) = (categories[displayIndex + 1], categories[displayIndex]);

            // Now update Order properties to match new positions
            for (int i = 0; i < categories.Count; i++)
            {
                categories[i].Order = i;
            }

            Question.Configuration["GoalCategories"] = categories;
            StateHasChanged();
        }
    }

    // Required flag methods for text sections
    private bool GetTextSectionRequired(int index)
    {
        var sections = GetTextSectionsFromConfiguration();
        if (index >= 0 && index < sections.Count)
        {
            return sections[index].IsRequired;
        }
        return false;
    }

    private async Task UpdateTextSectionRequired(int index, bool value)
    {
        var sections = GetTextSectionsFromConfiguration();
        if (index >= 0 && index < sections.Count)
        {
            sections[index].IsRequired = value;
            Question.Configuration["TextSections"] = sections;
            StateHasChanged();
            await OnRequiredChanged.InvokeAsync();
        }
    }


    public class GoalCategory
    {
        public string Title { get; set; } = "";
        public string Description { get; set; } = "";
        public bool IsRequired { get; set; } = false;
        public int Order { get; set; } = 0;
    }

    public class TextSection
    {
        public string Title { get; set; } = "";
        public string Description { get; set; } = "";
        public bool IsRequired { get; set; } = false;
        public int Order { get; set; } = 0;
    }
}