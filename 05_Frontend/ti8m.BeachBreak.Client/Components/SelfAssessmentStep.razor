@using Radzen
@using Radzen.Blazor
@using ti8m.BeachBreak.Client.Models

<RadzenCard Class="self-assessment-step">
    <RadzenText TextStyle="TextStyle.H4" Class="text-competency mb-3">
        <RadzenIcon Icon="self_improvement" Class="me-2" />
        2023 Self-Assessment of Competencies
    </RadzenText>
    
    <RadzenText TextStyle="TextStyle.Body1" Class="mb-4">
        In this section, your professional competencies and skills from 2023 are reflected upon.
    </RadzenText>

    <RadzenAlert AlertStyle="AlertStyle.Info" Class="mb-4" ShowIcon="true">
        <RadzenText TextStyle="TextStyle.Body2">
            <strong>Rating Scale:</strong> 1 (Not at all satisfied) - 2 (Not satisfied) - 3 (Satisfied) - 4 (Very satisfied)
            <br />
            Optional comments can be added in the text field.
        </RadzenText>
    </RadzenAlert>

    <div class="competencies-container">
        @foreach (var competency in Competencies)
        {
            <RadzenCard Class="competency-card mb-3 p-3 border">
                <RadzenRow>
                    <RadzenColumn Size="12" SizeMD="8">
                        <RadzenText TextStyle="TextStyle.Subtitle1" Class="fw-bold mb-2">
                            @competency.Title
                        </RadzenText>
                        <RadzenText TextStyle="TextStyle.Body2" Class="text-muted mb-2">
                            @competency.Description
                        </RadzenText>
                    </RadzenColumn>
                    <RadzenColumn Size="12" SizeMD="4" Class="text-end">
                        <div class="rating-section">
                            <RadzenText TextStyle="TextStyle.Caption" Class="mb-1">Rate your satisfaction:</RadzenText>
                            <RadzenRating Value="@GetRating(competency.Key)" 
                                        ValueChanged="@(value => SetRating(competency.Key, value))"
                                        Stars="4" 
                                        Class="mb-2" />
                            <RadzenText TextStyle="TextStyle.Caption" Class="text-competency">
                                @GetRatingText(GetRating(competency.Key))
                            </RadzenText>
                        </div>
                    </RadzenColumn>
                </RadzenRow>
                <RadzenTextArea Value="@GetComment(competency.Key)"
                              ValueChanged="@(value => SetComment(competency.Key, value))"
                              Placeholder="Optional: Add your comments here..."
                              Rows="2"
                              Class="w-100 mt-2" />
            </RadzenCard>
        }
    </div>

    <div class="mt-4">
        <RadzenText TextStyle="TextStyle.Body2" Class="text-muted">
            Progress: @completedCompetencies out of @Competencies.Count competencies rated
        </RadzenText>
        <RadzenProgressBar Value="@progressPercentage" Max="100" Class="mt-2" />
    </div>
</RadzenCard>

@code {
    [Parameter] public List<CompetencyDefinition> Competencies { get; set; } = new();
    [Parameter] public Dictionary<string, CompetencyRating> Ratings { get; set; } = new();
    [Parameter] public EventCallback<Dictionary<string, CompetencyRating>> RatingsChanged { get; set; }

    [Parameter] public bool CanProceed { get; set; } = false;
    [Parameter] public EventCallback<bool> CanProceedChanged { get; set; }

    private int completedCompetencies => Ratings.Count(r => r.Value.Rating > 0);
    private double progressPercentage => Competencies.Count > 0 ? (double)completedCompetencies / Competencies.Count * 100 : 0;

    protected override async Task OnInitializedAsync()
    {
        // Initialize ratings if empty
        foreach (var competency in Competencies)
        {
            if (!Ratings.ContainsKey(competency.Key))
            {
                Ratings[competency.Key] = new CompetencyRating();
            }
        }
        await UpdateProgress();
    }

    private int GetRating(string key)
    {
        return Ratings.TryGetValue(key, out var rating) ? rating.Rating : 0;
    }

    private string GetComment(string key)
    {
        return Ratings.TryGetValue(key, out var rating) ? rating.Comment : string.Empty;
    }

    private async Task SetRating(string key, int value)
    {
        if (!Ratings.ContainsKey(key))
            Ratings[key] = new CompetencyRating();
        
        Ratings[key].Rating = value;
        await UpdateProgress();
    }

    private async Task SetComment(string key, string value)
    {
        if (!Ratings.ContainsKey(key))
            Ratings[key] = new CompetencyRating();
        
        Ratings[key].Comment = value ?? string.Empty;
        await RatingsChanged.InvokeAsync(Ratings);
    }

    private async Task UpdateProgress()
    {
        bool canProceed = Competencies.All(c => Ratings.ContainsKey(c.Key) && Ratings[c.Key].Rating > 0);
        await CanProceedChanged.InvokeAsync(canProceed);
        await RatingsChanged.InvokeAsync(Ratings);
    }

    private string GetRatingText(int rating)
    {
        return rating switch
        {
            1 => "Not satisfied",
            2 => "Somewhat satisfied",
            3 => "Satisfied",
            4 => "Very satisfied",
            _ => "Not rated"
        };
    }


}