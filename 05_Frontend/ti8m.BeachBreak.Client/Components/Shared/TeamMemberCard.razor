@using Radzen
@using Radzen.Blazor
@using ti8m.BeachBreak.Client.Models

<div class="team-member-item team-member-card-adaptive p-4 mb-3 rounded"
     @onmouseover="@(() => isHovered = true)"
     @onmouseout="@(() => isHovered = false)">

    <!-- Member Header - Simplified -->
    <div class="d-flex align-items-center justify-content-between mb-2">
        <div class="d-flex align-items-center">
            <RadzenIcon Icon="person" Style="font-size: 1.25rem;" Class="text-primary me-2" />
            <div>
                <span class="fw-medium">@TeamMember.FirstName @TeamMember.LastName</span>
                <small class="text-muted ms-2">@TeamMember.EMail</small>
            </div>
        </div>
        <div class="d-flex align-items-center gap-2">
            <!-- Compact Status Summary -->
            @if (OverdueCount > 0)
            {
                <RadzenBadge Text="@OverdueCount.ToString()"
                            BadgeStyle="BadgeStyle.Danger"
                            title="@($"{OverdueCount} overdue assignments")"
                            Class="px-2 py-1" />
            }
            @if (InProgressCount > 0)
            {
                <RadzenBadge Text="@InProgressCount.ToString()"
                            BadgeStyle="BadgeStyle.Info"
                            title="@($"{InProgressCount} in progress")"
                            Class="px-2 py-1" />
            }
            <RadzenBadge Text="@($"{CompletedCount}/{TotalCount}")"
                        BadgeStyle="BadgeStyle.Success"
                        title="@($"{CompletedCount} of {TotalCount} completed")"
                        Class="px-2 py-1" />
        </div>
    </div>

    @if (Assignments.Any())
    {
        <!-- Clean Assignment List -->
        <div class="assignment-list-simple mt-2">
            @foreach (var assignment in (showAllAssignments ? Assignments : Assignments.Take(3)))
            {
                <div class="d-flex align-items-center justify-content-between py-2 px-3 rounded assignment-row assignment-row-adaptive"
                     style="cursor: pointer; margin-bottom: 6px;"
                     @onclick="@(() => OnAssignmentClick.InvokeAsync(assignment.Id))">
                    <div class="d-flex align-items-center flex-grow-1">
                        <div class="assignment-status-dot me-2"
                             style="width: 8px; height: 8px; border-radius: 50%; background-color: @WorkflowStateHelper.GetStateColor(assignment.WorkflowState);"></div>
                        <span class="assignment-name text-truncate">@assignment.TemplateName</span>
                        @if (assignment.DueDate.HasValue && assignment.DueDate.Value < DateTime.Now && assignment.WorkflowState != WorkflowState.Finalized)
                        {
                            <RadzenIcon Icon="warning" Class="text-danger ms-1" Style="font-size: 0.75rem;" title="Overdue" />
                        }
                    </div>
                    <div class="d-flex align-items-center gap-1">
                        @if (OnSendReminder.HasDelegate && assignment.WorkflowState != WorkflowState.Finalized)
                        {
                            <RadzenButton Icon="notifications"
                                        ButtonStyle="ButtonStyle.Light"
                                        Size="ButtonSize.ExtraSmall"
                                        Click="@((args) => OnSendReminderForAssignment(assignment))"
                                        title="Send reminder"
                                        @onclick:stopPropagation="true"
                                        Class="hover-visible"
                                        Style="padding: 2px 4px; opacity: 0.7;" />
                        }
                        @if (CanReopen(assignment))
                        {
                            <RadzenButton Icon="refresh"
                                        ButtonStyle="ButtonStyle.Light"
                                        Size="ButtonSize.ExtraSmall"
                                        Click="@((args) => OnReopenAssignment(assignment))"
                                        title="Reopen"
                                        @onclick:stopPropagation="true"
                                        Class="hover-visible"
                                        Style="padding: 2px 4px; opacity: 0.7;" />
                        }
                    </div>
                </div>
            }
            @if (Assignments.Count > 3)
            {
                <div class="text-muted text-center mt-1" style="cursor: pointer;" @onclick="ToggleShowAllAssignments">
                    <small>
                        @if (showAllAssignments)
                        {
                            <span><RadzenIcon Icon="expand_less" Style="font-size: 0.8rem;" /> Show less</span>
                        }
                        else
                        {
                            <span>+@(Assignments.Count - 3) more assignments - click to view all <RadzenIcon Icon="expand_more" Style="font-size: 0.8rem;" /></span>
                        }
                    </small>
                </div>
            }
        </div>
    }
    else
    {
        <div class="text-center py-2">
            <small class="text-muted">No assignments yet</small>
        </div>
    }
</div>

@code {
    [Parameter, EditorRequired] public EmployeeDto TeamMember { get; set; } = default!;
    [Parameter, EditorRequired] public List<QuestionnaireAssignment> Assignments { get; set; } = new();
    [Parameter] public EventCallback<EmployeeDto> OnSendReminder { get; set; }
    [Parameter] public EventCallback<Guid> OnAssignmentClick { get; set; }
    [Parameter] public EventCallback<QuestionnaireAssignment> OnReopenClick { get; set; }

    private bool isHovered = false;
    private bool showAllAssignments = false;
    private int TotalCount => Assignments.Count;
    // Completed: ONLY Finalized state (consistent with employee view)
    private int CompletedCount => Assignments.Count(a => a.WorkflowState == WorkflowState.Finalized);
    // Pending: Just assigned or initialized, not started yet
    private int PendingCount => Assignments.Count(a =>
        a.WorkflowState == WorkflowState.Assigned ||
        a.WorkflowState == WorkflowState.Initialized);
    // In Progress: Work started but not finalized (includes all working, submitted, and review states)
    private int InProgressCount => Assignments.Count(a =>
        a.WorkflowState is WorkflowState.EmployeeInProgress
        or WorkflowState.ManagerInProgress
        or WorkflowState.BothInProgress
        or WorkflowState.EmployeeSubmitted
        or WorkflowState.ManagerSubmitted
        or WorkflowState.BothSubmitted
        or WorkflowState.InReview
        or WorkflowState.EmployeeReviewConfirmed
        or WorkflowState.ReviewFinished);
    private int OverdueCount => Assignments.Count(a =>
        a.DueDate.HasValue &&
        a.DueDate.Value < DateTime.Now &&
        a.WorkflowState != WorkflowState.Finalized);

    private double ProgressPercentage => TotalCount > 0 ? Math.Round((double)CompletedCount / TotalCount * 100, 1) : 0;

    private BadgeStyle GetProgressBadgeStyle()
    {
        if (OverdueCount > 0) return BadgeStyle.Danger;
        if (ProgressPercentage >= 100) return BadgeStyle.Success;
        if (ProgressPercentage >= 50) return BadgeStyle.Info;
        return BadgeStyle.Warning;
    }

    private BadgeStyle GetStatusBadgeStyle(WorkflowState state)
    {
        return state switch
        {
            WorkflowState.Assigned or WorkflowState.Initialized => BadgeStyle.Secondary,
            WorkflowState.EmployeeInProgress or WorkflowState.ManagerInProgress or WorkflowState.BothInProgress => BadgeStyle.Info,
            WorkflowState.EmployeeSubmitted or WorkflowState.ManagerSubmitted or WorkflowState.BothSubmitted => BadgeStyle.Primary,
            WorkflowState.InReview or WorkflowState.EmployeeReviewConfirmed or WorkflowState.ReviewFinished => BadgeStyle.Warning,
            WorkflowState.Finalized => BadgeStyle.Success,
            _ => BadgeStyle.Light
        };
    }

    private string GetBorderClass(QuestionnaireAssignment assignment)
    {
        if (assignment.DueDate.HasValue && assignment.DueDate.Value < DateTime.Now && assignment.WorkflowState != WorkflowState.Finalized)
            return "border-danger";

        return assignment.WorkflowState switch
        {
            WorkflowState.Assigned or WorkflowState.Initialized => "border-warning",
            WorkflowState.EmployeeInProgress or WorkflowState.ManagerInProgress or WorkflowState.BothInProgress => "border-info",
            WorkflowState.EmployeeSubmitted or WorkflowState.ManagerSubmitted => "border-info",
            WorkflowState.BothSubmitted or WorkflowState.InReview or WorkflowState.EmployeeReviewConfirmed or WorkflowState.ReviewFinished => "border-primary",
            WorkflowState.Finalized => "border-success",
            _ => "border-secondary"
        };
    }

    private string GetDueDateClass(QuestionnaireAssignment assignment)
    {
        if (assignment.DueDate.HasValue && assignment.DueDate.Value < DateTime.Now && assignment.WorkflowState != WorkflowState.Finalized)
            return "text-danger fw-bold";
        return "text-muted";
    }

    private async Task OnSendReminderForAssignment(QuestionnaireAssignment assignment)
    {
        // Invoke the reminder callback with the employee for this specific assignment
        // The parent component will handle showing the message
        await OnSendReminder.InvokeAsync(TeamMember);
    }

    private bool CanReopen(QuestionnaireAssignment assignment)
    {
        // Can reopen if in a submitted or confirmed state (not Finalized, not in-progress)
        return assignment.WorkflowState == WorkflowState.EmployeeSubmitted ||
               assignment.WorkflowState == WorkflowState.ManagerSubmitted ||
               assignment.WorkflowState == WorkflowState.BothSubmitted ||
               assignment.WorkflowState == WorkflowState.InReview ||
               assignment.WorkflowState == WorkflowState.EmployeeReviewConfirmed ||
               assignment.WorkflowState == WorkflowState.ReviewFinished;
    }

    private async Task OnReopenAssignment(QuestionnaireAssignment assignment)
    {
        if (OnReopenClick.HasDelegate)
        {
            await OnReopenClick.InvokeAsync(assignment);
        }
    }

    private void ToggleShowAllAssignments()
    {
        showAllAssignments = !showAllAssignments;
        StateHasChanged();
    }

}
