@using Radzen.Blazor
@using ti8m.BeachBreak.Client.Models
@using ti8m.BeachBreak.Client.Models.DTOs
@using ti8m.BeachBreak.Client.Services
@using ti8m.BeachBreak.Client.Components.Questions
@using Microsoft.AspNetCore.Components.Authorization
@using ti8m.BeachBreak.Client.Extensions
@inject NotificationService NotificationService
@inject IQuestionnaireTemplateService TemplateService
@inject IQuestionnaireResponseService ResponseService
@inject IQuestionnaireAssignmentService AssignmentService
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IAuthService AuthService

<style>
    .questionnaire-completion {
        --primary-color: #2563eb;
        --success-color: #059669;
        --warning-color: #d97706;
        --text-color: #374151;
        --text-muted: #6b7280;
        --border-light: #f3f4f6;
        --border-color: #d1d5db;
        --bg-light: #f9fafb;

        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
        max-width: 900px;
        margin: 0 auto;
        padding: 2rem;
    }

    .completion-header {
        text-align: center;
        margin-bottom: 3rem;
        padding-bottom: 2rem;
        border-bottom: 2px solid var(--border-light);
    }

    .questionnaire-title {
        font-size: 2rem;
        font-weight: 700;
        color: var(--text-color);
        margin-bottom: 0.5rem;
        letter-spacing: -0.025em;
    }

    .questionnaire-description {
        font-size: 1.1rem;
        color: var(--text-muted);
        line-height: 1.6;
        margin-bottom: 1.5rem;
    }

    .progress-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
        margin-bottom: 2rem;
    }

    .section-progress {
        flex: 1;
        font-size: 0.875rem;
        color: var(--text-muted);
    }

    .progress-info {
        display: flex;
        align-items: center;
        gap: 1rem;
        font-size: 0.875rem;
        color: var(--text-muted);
    }

    .section-container {
        background: white;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 2rem;
        margin-bottom: 2rem;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .section-header-questionnaire {
        margin-bottom: 2rem;
        padding-bottom: 1.5rem;
        border-bottom: 1px solid var(--border-light);
    }

    .section-title {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--text-color);
        margin-bottom: 0.75rem;
        letter-spacing: -0.025em;
    }

    .section-description {
        font-size: 1rem;
        color: var(--text-muted);
        line-height: 1.6;
    }

    .question-container {
        margin-bottom: 2rem;
    }

    .question-content {
        background: var(--bg-light);
        border-radius: 6px;
        border-left: 4px solid var(--primary-color);
        padding: 1.5rem;
    }

    .question-header {
        margin-bottom: 1.5rem;
    }

    .question-label {
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--text-color);
        margin-bottom: 0.5rem;
        line-height: 1.5;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .required-indicator {
        color: #dc2626;
        font-weight: 700;
    }

    .question-description {
        font-size: 0.875rem;
        color: var(--text-muted);
        line-height: 1.5;
    }

    .competency-item {
        background: white;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        padding: 1.5rem;
        margin-bottom: 1.5rem;
    }

    .competency-header {
        margin-bottom: 1rem;
    }

    .competency-title {
        font-size: 1rem;
        font-weight: 600;
        color: var(--text-color);
        margin-bottom: 0.5rem;
    }

    .competency-description {
        font-size: 0.875rem;
        color: var(--text-muted);
        line-height: 1.5;
    }

    .rating-container {
        display: flex;
        align-items: center;
        gap: 1rem;
        margin-bottom: 1rem;
        flex-wrap: wrap;
    }

    .rating-labels {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.875rem;
        color: var(--text-muted);
    }

    .goal-field {
        margin-bottom: 1.5rem;
    }

    .goal-field-label {
        font-size: 0.875rem;
        font-weight: 600;
        color: var(--text-color);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin-bottom: 0.5rem;
        display: block;
    }

    .goal-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1.5rem;
        margin-bottom: 1.5rem;
    }

    .text-input {
        width: 100%;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 0.875rem;
        font-size: 0.95rem;
        font-family: inherit;
        resize: vertical;
        min-height: 100px;
        transition: border-color 0.2s ease;
    }

    .text-input:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }

    .form-input {
        width: 100%;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 0.75rem;
        font-size: 0.95rem;
        font-family: inherit;
        transition: border-color 0.2s ease;
    }

    .form-input:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }

    .navigation-container {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding-top: 2rem;
        border-top: 1px solid var(--border-light);
        margin-top: 3rem;
    }

    .nav-button {
        min-width: 120px;
    }

    .save-status {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.875rem;
        color: var(--text-muted);
    }

    .auto-save-indicator {
        color: var(--success-color);
        animation: pulse 2s infinite;
    }

    @@keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }

    .completion-summary {
        text-align: center;
        padding: 3rem;
        background: var(--bg-light);
        border-radius: 8px;
        border: 2px solid var(--success-color);
    }

    .completion-icon {
        font-size: 4rem;
        color: var(--success-color);
        margin-bottom: 1rem;
    }

    .validation-error {
        background: #fef2f2;
        border: 1px solid #fecaca;
        color: #dc2626;
        padding: 1rem;
        border-radius: 4px;
        font-size: 0.875rem;
        margin-bottom: 1rem;
        display: flex;
        align-items: flex-start;
        gap: 0.75rem;
    }

    .validation-error strong {
        flex-shrink: 0;
        font-weight: 700;
    }

    .validation-error ul {
        list-style: none;
        padding: 0;
        margin: 0;
        flex: 1;
    }

    .validation-error li {
        padding: 0.125rem 0;
    }

    .validation-error li::before {
        content: "• ";
    }

    @@media (max-width: 768px) {
        .questionnaire-completion {
            padding: 1rem;
        }

        .questionnaire-title {
            font-size: 1.5rem;
        }

        .section-title {
            font-size: 1.25rem;
        }

        .goal-row {
            grid-template-columns: 1fr;
            gap: 1rem;
        }

        .progress-header {
            flex-direction: column;
            align-items: stretch;
            gap: 0.5rem;
        }

        .rating-container {
            flex-direction: column;
            align-items: stretch;
        }
    }
</style>

<div class="questionnaire-completion">
    @if (isCompleted)
    {
        <div class="completion-summary">
            <div class="completion-icon">✅</div>
            <h2>Questionnaire Completed!</h2>
            <p>Thank you for completing this questionnaire. Your responses have been submitted successfully.</p>
            @if (OnCompleted.HasDelegate)
            {
                <RadzenButton Text="Continue" ButtonStyle="ButtonStyle.Primary"
                              Click="@(() => OnCompleted.InvokeAsync())" Class="mt-3" />
            }
        </div>
    }
    else
    {
        @if (isLoading)
        {
            <div class="text-center p-5">
                <RadzenProgressBarCircular ShowValue="false" Mode="ProgressBarMode.Indeterminate" Size="ProgressBarCircularSize.Large" />
                <RadzenText TextStyle="TextStyle.Body1" Class="text-muted mt-3">Loading questionnaire...</RadzenText>
            </div>
        }
        else if (template == null)
        {
            <div class="text-center p-5">
                <RadzenText TextStyle="TextStyle.Body1" Class="text-muted">Could not load questionnaire template.</RadzenText>
            </div>
        }
        else
        {
            <div class="completion-header">
                <h1 class="questionnaire-title">@template.Name</h1>
                @if (!string.IsNullOrWhiteSpace(template.Description))
                {
                    <p class="questionnaire-description">@template.Description</p>
                }
            </div>

            <div class="progress-header">
                <div class="section-progress">
                    Section @(currentSectionIndex + 1) of @template.Sections.Count
                </div>
            <div class="progress-info">
                <RadzenProgressBar Value="@progressPercentage" Max="100" ShowValue="true" />
                @if (lastSavedTime.HasValue)
                {
                    <div class="save-status">
                        <RadzenIcon Icon="cloud_done" Class="auto-save-indicator" />
                        Last saved @lastSavedTime.Value.ToString("HH:mm")
                    </div>
                }
            </div>
        </div>

        @if (validationErrors.Any())
        {
            <div class="validation-error">
                <strong>Please fix the following issues:</strong>
                <ul>
                    @foreach (var error in validationErrors)
                    {
                        <li>@error</li>
                    }
                </ul>
            </div>
        }

        <div class="section-container">
            <div class="section-header-questionnaire">
                <h2 class="section-title">@currentSection.Title</h2>
                @if (!string.IsNullOrWhiteSpace(currentSection.Description))
                {
                    <p class="section-description">@currentSection.Description</p>
                }
            </div>

            @foreach (var question in currentSection.Questions.OrderBy(q => q.Order))
            {
                <div class="question-container">
                    @if (!string.IsNullOrWhiteSpace(question.Description))
                    {
                        <div class="question-header">
                            <p class="question-description">@question.Description</p>
                        </div>
                    }
                    <div class="question-content">
                        @GetQuestionInput(question)
                    </div>
                </div>
            }
        </div>

        <div class="navigation-container">
            <div>
                @if (currentSectionIndex > 0)
                {
                    <RadzenButton Text="Previous" ButtonStyle="ButtonStyle.Light"
                                  Icon="arrow_back" Click="@PreviousSection" Class="nav-button" />
                }
            </div>

            <div class="save-status" style="text-align: center;">
                @if (isSaving)
                {
                    <RadzenProgressBarCircular ShowValue="false" Size="ProgressBarCircularSize.Small" />
                    <span>Saving...</span>
                }
                else if (lastSavedTime.HasValue)
                {
                    <RadzenIcon Icon="cloud_done" />
                    <span>All changes saved</span>
                }
            </div>

            <div>
                @if (template != null && currentSectionIndex < template.Sections.Count - 1)
                {
                    <RadzenButton Text="Next" ButtonStyle="ButtonStyle.Primary"
                                  Icon="arrow_forward" Click="@NextSection" Class="nav-button"
                                  Disabled="@(!canEdit)" />
                }
                else if (CanShowSubmitButton())
                {
                    <RadzenButton Text="Submit" ButtonStyle="ButtonStyle.Success"
                                  Icon="send" Click="@SubmitQuestionnaire" Class="nav-button"
                                  Disabled="@(isSaving || !canEdit)" />
                }
            </div>
        </div>
        }
    }
</div>

@code {
    [Parameter, EditorRequired] public QuestionnaireAssignment Assignment { get; set; } = null!;
    [Parameter] public Dictionary<QuestionType, string>? QuestionTypeLabels { get; set; }
    [Parameter] public Dictionary<Guid, SectionResponse>? ExistingResponses { get; set; }
    [Parameter] public EventCallback OnCompleted { get; set; }
    [Parameter] public EventCallback<Dictionary<Guid, SectionResponse>> OnSave { get; set; }

    private QuestionnaireTemplate? template;
    private int currentSectionIndex = 0;
    private Dictionary<Guid, SectionResponse> responses = new();
    private List<string> validationErrors = new();
    private bool isCompleted = false;
    private bool isSaving = false;
    private bool isLoading = true;
    private DateTime? lastSavedTime;
    private ApplicationRole userRole = ApplicationRole.Employee;
    private bool isEmployee = false;
    private bool isManager = false;
    private bool canEdit = false;

    /// <summary>
    /// The response role for accessing RoleResponses dictionary.
    /// Provides type-safe access while maintaining compatibility with string-based dictionary.
    /// </summary>
    private ResponseRole CurrentResponseRole => userRole.ToResponseRole();

    /// <summary>
    /// String key for accessing RoleResponses dictionary.
    /// Provides backwards compatibility with string-based dictionary keys.
    /// </summary>
    private string currentUserRole => CurrentResponseRole.ToRoleKey();

    // Auto-save timer
    private Timer? autoSaveTimer;
    private bool hasUnsavedChanges = false;

    private QuestionSection currentSection => template?.Sections.OrderBy(s => s.Order).Skip(currentSectionIndex).First() ?? new QuestionSection();
    private double progressPercentage => template != null ? ((double)(currentSectionIndex + 1) / template.Sections.Count) * 100 : 0;

    protected override async Task OnInitializedAsync()
    {
        await DetermineUserRole();
        await LoadTemplate();
        await LoadExistingResponses();
        InitializeResponses();
        SetupAutoSave();
        isLoading = false;
        StateHasChanged();
    }

    private async Task DetermineUserRole()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        try
        {
            // WebAssembly client doesn't have ApplicationRole claims (those are added server-side only)
            // So we need to call the API to get the user's role from the database
            var roleData = await AuthService.GetMyRoleAsync();

            if (roleData == null)
            {
                // Default to Employee for safety
                userRole = ApplicationRole.Employee;
                isManager = false;
                isEmployee = true;
                UpdateCanEdit();
                return;
            }

            // Store the actual ApplicationRole - computed properties derive behavior from it
            userRole = roleData.ApplicationRole;
            isManager = userRole is ApplicationRole.TeamLead or ApplicationRole.HR or ApplicationRole.HRLead or ApplicationRole.Admin;
            isEmployee = true; // Everyone has employee-level access
        }
        catch (Exception ex)
        {
            // Default to Employee for safety on API call failure
            userRole = ApplicationRole.Employee;
            isManager = false;
            isEmployee = true;
        }

        // Determine if editing is allowed based on workflow state
        UpdateCanEdit();
    }

    private void UpdateCanEdit()
    {
        if (Assignment == null)
        {
            canEdit = false;
            return;
        }

        // Check workflow state to determine if editing is allowed
        if (isEmployee && !isManager)
        {
            canEdit = WorkflowStateHelper.CanEmployeeEdit(Assignment);
        }
        else if (isManager)
        {
            canEdit = WorkflowStateHelper.CanManagerEdit(Assignment) ||
                      WorkflowStateHelper.CanManagerEditDuringReview(Assignment);
        }
    }

    private bool CanShowSubmitButton()
    {
        if (Assignment == null) return false;

        if (isEmployee && !isManager)
        {
            return WorkflowStateHelper.CanEmployeeSubmit(Assignment);
        }
        else if (isManager)
        {
            return WorkflowStateHelper.CanManagerSubmit(Assignment);
        }

        return false;
    }

    private async Task LoadTemplate()
    {
        try
        {
            template = await TemplateService.GetTemplateByIdAsync(Assignment.TemplateId);
            if (template == null)
            {
                NotificationService.Notify(NotificationSeverity.Error, "Error", "Could not load questionnaire template");
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(NotificationSeverity.Error, "Error", $"Failed to load template: {ex.Message}");
        }
    }

    private async Task LoadExistingResponses()
    {
        try
        {
            // First check if existing responses were passed as a parameter
            if (ExistingResponses != null && ExistingResponses.Any())
            {
                responses = new Dictionary<Guid, SectionResponse>(ExistingResponses);
                return;
            }

            // If no existing responses passed, try to load from API
            var existingResponse = await ResponseService.GetResponseByAssignmentIdAsync(Assignment.Id);
            if (existingResponse?.SectionResponses != null)
            {
                responses = existingResponse.SectionResponses;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading existing responses: {ex.Message}");
        }
    }

    private void InitializeResponses()
    {
        if (template == null) return;

        foreach (var section in template.Sections)
        {
            if (!responses.ContainsKey(section.Id))
            {
                responses[section.Id] = new SectionResponse
                {
                    SectionId = section.Id,
                    RoleResponses = new Dictionary<ResponseRole, Dictionary<Guid, QuestionResponse>>()
                };
            }

            // Ensure role dictionary exists
            if (!responses[section.Id].RoleResponses.ContainsKey(CurrentResponseRole))
            {
                responses[section.Id].RoleResponses[CurrentResponseRole] = new Dictionary<Guid, QuestionResponse>();
            }

            // Initialize question responses for current user's role
            foreach (var question in section.Questions)
            {
                if (!responses[section.Id].RoleResponses[CurrentResponseRole].ContainsKey(question.Id))
                {
                    responses[section.Id].RoleResponses[CurrentResponseRole][question.Id] = new QuestionResponse
                    {
                        QuestionId = question.Id,
                        QuestionType = question.Type,
                        ResponseData = question.Type switch
                        {
                            QuestionType.TextQuestion => new TextResponseDataDto(),
                            QuestionType.Assessment => new AssessmentResponseDataDto(),
                            QuestionType.Goal => new GoalResponseDataDto(),
                            _ => null
                        }
                    };
                }
            }
        }
    }

    private void SetupAutoSave()
    {
        autoSaveTimer = new Timer(async _ =>
        {
            if (hasUnsavedChanges && !isSaving)
            {
                await InvokeAsync(async () => await SaveProgress());
            }
        }, null, TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(30));
    }

    private async Task SaveProgress()
    {
        if (isSaving) return;

        isSaving = true;
        hasUnsavedChanges = false;
        StateHasChanged();

        try
        {
            await ResponseService.SaveResponseAsync(Assignment.Id, responses);
            lastSavedTime = DateTime.Now;

            if (OnSave.HasDelegate)
            {
                await OnSave.InvokeAsync(responses);
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(NotificationSeverity.Error, "Save Failed", $"Could not save progress: {ex.Message}");
        }
        finally
        {
            isSaving = false;
            StateHasChanged();
        }
    }

    private void MarkChanged()
    {
        hasUnsavedChanges = true;
        StateHasChanged();
    }

    private async Task NextSection()
    {
        if (ValidateCurrentSection())
        {
            await SaveProgress();

            if (template != null && currentSectionIndex < template.Sections.Count - 1)
            {
                currentSectionIndex++;
                validationErrors.Clear();
                StateHasChanged();
            }
        }
    }

    private async Task PreviousSection()
    {
        await SaveProgress();

        if (currentSectionIndex > 0)
        {
            currentSectionIndex--;
            validationErrors.Clear();
            StateHasChanged();
        }
    }

    private async Task SubmitQuestionnaire()
    {
        if (ValidateAllSections())
        {
            await SaveProgress();

            try
            {
                // Use workflow-aware submission based on role
                bool success;
                var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
                var userName = authState.User.Identity?.Name ?? "Unknown";

                if (isEmployee && !isManager && WorkflowStateHelper.CanEmployeeSubmit(Assignment))
                {
                    success = await AssignmentService.SubmitEmployeeQuestionnaireAsync(Assignment.Id, userName);
                }
                else if (isManager && WorkflowStateHelper.CanManagerSubmit(Assignment))
                {
                    success = await AssignmentService.SubmitManagerQuestionnaireAsync(Assignment.Id, userName);
                }
                else
                {
                    NotificationService.Notify(NotificationSeverity.Warning, "Cannot Submit",
                        "You cannot submit this questionnaire in its current workflow state.");
                    return;
                }

                if (success)
                {
                    isCompleted = true;
                    NotificationService.Notify(NotificationSeverity.Success, "Submitted", "Questionnaire submitted successfully!");
                    StateHasChanged();
                }
                else
                {
                    NotificationService.Notify(NotificationSeverity.Error, "Submission Failed",
                        "Could not submit questionnaire. Please try again.");
                }
            }
            catch (Exception ex)
            {
                NotificationService.Notify(NotificationSeverity.Error, "Submission Failed", $"Could not submit questionnaire: {ex.Message}");
            }
        }
    }

    private bool ValidateCurrentSection()
    {
        validationErrors.Clear();
        var section = currentSection;

        if (!responses[section.Id].RoleResponses.TryGetValue(CurrentResponseRole, out var roleQuestions))
            return false;

        foreach (var question in section.Questions.Where(q => q.IsRequired))
        {
            if (!roleQuestions.TryGetValue(question.Id, out var response))
            {
                validationErrors.Add($"'{GetQuestionTypeLabel(question)}' is required");
                continue;
            }

            if (!IsQuestionAnswered(question, response))
            {
                validationErrors.Add($"'{GetQuestionTypeLabel(question)}' is required");
            }
        }

        return !validationErrors.Any();
    }

    private bool ValidateAllSections()
    {
        validationErrors.Clear();

        if (template == null) return !validationErrors.Any();

        foreach (var section in template.Sections)
        {
            if (!responses[section.Id].RoleResponses.TryGetValue(CurrentResponseRole, out var roleQuestions))
                continue;

            foreach (var question in section.Questions.Where(q => q.IsRequired))
            {
                if (!roleQuestions.TryGetValue(question.Id, out var response) ||
                    !IsQuestionAnswered(question, response))
                {
                    validationErrors.Add($"'{GetQuestionTypeLabel(question)}' in section '{section.Title}' is required");
                }
            }
        }

        return !validationErrors.Any();
    }

    private bool IsQuestionAnswered(QuestionItem question, QuestionResponse response)
    {
        return question.Type switch
        {
            QuestionType.Assessment => IsCompetencyAssessmentComplete(question, response),
            QuestionType.Goal => IsGoalComplete(response),
            QuestionType.TextQuestion => IsTextQuestionAnswered(response),
            _ => false
        };
    }

    private bool IsTextQuestionAnswered(QuestionResponse response)
    {
        if (response.ResponseData is not TextResponseDataDto textData)
            return false;

        return textData.TextSections.Any(section => !string.IsNullOrWhiteSpace(section));
    }

    private bool IsCompetencyAssessmentComplete(QuestionItem question, QuestionResponse response)
    {
        if (response.ResponseData is not AssessmentResponseDataDto assessmentData)
            return false;

        var competencies = GetCompetenciesFromConfiguration(question);
        foreach (var competency in competencies.Where(c => c.IsRequired))
        {
            if (!assessmentData.Competencies.TryGetValue(competency.Key, out var competencyRating) ||
                competencyRating.Rating == 0)
            {
                return false;
            }
        }
        return true;
    }

    private bool IsGoalComplete(QuestionResponse response)
    {
        if (response.ResponseData is not GoalResponseDataDto goalData)
            return false;

        // Goal is complete if it has at least one goal with an objective
        return goalData.Goals.Any(goal => !string.IsNullOrWhiteSpace(goal.ObjectiveDescription));
    }

    private string GetQuestionTypeLabel(QuestionItem question)
    {
        if (question.Configuration.ContainsKey("QuestionTitle"))
        {
            var customTitle = question.Configuration["QuestionTitle"].ToString() ?? "";
            if (!string.IsNullOrWhiteSpace(customTitle))
            {
                return customTitle;
            }
        }

        if (QuestionTypeLabels != null && QuestionTypeLabels.TryGetValue(question.Type, out var label))
        {
            return label;
        }

        return question.Type.ToString();
    }

    private RenderFragment GetQuestionInput(QuestionItem question)
    {
        var sectionResponse = responses[currentSection.Id];
        var questionResponse = sectionResponse.RoleResponses[CurrentResponseRole][question.Id];

        return @<OptimizedQuestionRenderer
            Question="@question"
            Response="@questionResponse"
            OnResponseChanged="@HandleQuestionResponseChanged"
            IsReadOnly="@(!canEdit)"
            HideHeader="true" />;
    }

    private async Task HandleQuestionResponseChanged(QuestionResponse updatedResponse)
    {
        // Response object is already updated by reference
        // Just trigger validation and state change
        await InvokeAsync(StateHasChanged);
    }

    // Helper methods for data binding and change handling (kept for backward compatibility)
    private int GetCompetencyRating(QuestionResponse response, string competencyId)
    {
        if (response.ResponseData is AssessmentResponseDataDto assessmentData &&
            assessmentData.Competencies.TryGetValue(competencyId, out var competencyRating))
        {
            return competencyRating.Rating;
        }
        return 0;
    }

    private string GetCompetencyComments(QuestionResponse response, string competencyId)
    {
        if (response.ResponseData is AssessmentResponseDataDto assessmentData &&
            assessmentData.Competencies.TryGetValue(competencyId, out var competencyRating))
        {
            return competencyRating.Comment;
        }
        return "";
    }

    private async Task OnCompetencyRatingChange(QuestionResponse response, string competencyId, int rating)
    {
        if (response.ResponseData is not AssessmentResponseDataDto assessmentData)
        {
            assessmentData = new AssessmentResponseDataDto();
            response.ResponseData = assessmentData;
        }

        if (!assessmentData.Competencies.ContainsKey(competencyId))
        {
            assessmentData.Competencies[competencyId] = new CompetencyRatingDto();
        }

        assessmentData.Competencies[competencyId].Rating = rating;
        response.LastModified = DateTime.Now;
        MarkChanged();
    }

    private async Task OnCompetencyCommentsChange(QuestionResponse response, string competencyId, string comments)
    {
        if (response.ResponseData is not AssessmentResponseDataDto assessmentData)
        {
            assessmentData = new AssessmentResponseDataDto();
            response.ResponseData = assessmentData;
        }

        if (!assessmentData.Competencies.ContainsKey(competencyId))
        {
            assessmentData.Competencies[competencyId] = new CompetencyRatingDto();
        }

        assessmentData.Competencies[competencyId].Comment = comments;
        response.LastModified = DateTime.Now;
        MarkChanged();
    }

    private async Task OnTextResponseChange(QuestionResponse response, string value)
    {
        if (response.ResponseData is not TextResponseDataDto textData)
        {
            textData = new TextResponseDataDto();
            response.ResponseData = textData;
        }

        // Ensure at least one section exists
        if (textData.TextSections.Count == 0)
        {
            textData.TextSections.Add(value);
        }
        else
        {
            textData.TextSections[0] = value;
        }

        response.LastModified = DateTime.Now;
        MarkChanged();
    }

    // Configuration helpers - minimal versions needed for validation
    private List<CompetencyDefinition> GetCompetenciesFromConfiguration(QuestionItem question)
    {
        if (!question.Configuration.ContainsKey("Competencies"))
            return new List<CompetencyDefinition>();

        var competenciesObj = question.Configuration["Competencies"];

        if (competenciesObj is List<CompetencyDefinition> competencies)
            return competencies;

        if (competenciesObj is System.Text.Json.JsonElement jsonElement && jsonElement.ValueKind == System.Text.Json.JsonValueKind.Array)
        {
            try
            {
                return System.Text.Json.JsonSerializer.Deserialize<List<CompetencyDefinition>>(
                    jsonElement.GetRawText()
                ) ?? new List<CompetencyDefinition>();
            }
            catch { /* Ignore deserialization errors */ }
        }

        return new List<CompetencyDefinition>();
    }

    public void Dispose()
    {
        autoSaveTimer?.Dispose();
    }
}