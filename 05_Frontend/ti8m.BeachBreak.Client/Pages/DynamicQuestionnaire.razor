@page "/my-questionnaires/{TemplateId:guid}"
@page "/questionnaire/{AssignmentId:guid}"
@attribute [Microsoft.AspNetCore.Authorization.Authorize]
@using Radzen
@using Radzen.Blazor
@using ti8m.BeachBreak.Client.Components
@using ti8m.BeachBreak.Client.Components.Questions
@using ti8m.BeachBreak.Client.Models
@using ti8m.BeachBreak.Client.Services
@using ti8m.BeachBreak.Client.Components.Shared
@using ti8m.BeachBreak.Client.Components.Dialogs
@using Microsoft.AspNetCore.Components.Authorization
@using ti8m.BeachBreak.Client.Extensions
@inject DialogService DialogService
@inject NotificationService NotificationService
@inject NavigationManager NavigationManager
@inject IEmployeeQuestionnaireService EmployeeQuestionnaireService
@inject IQuestionnaireAssignmentService AssignmentService
@inject IQuestionnaireTemplateService TemplateService
@inject IQuestionnaireResponseService ResponseService
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject QuestionConfigurationService ConfigService
@inject GoalService GoalService
@inject IJSRuntime JSRuntime
@inject IAuthService AuthService
@inherits OptimizedComponentBase

<link href="css/questionnaire-unified.css" rel="stylesheet" />

<PageTitle>@(template?.Name ?? "Questionnaire")</PageTitle>

<div class="container-fluid questionnaire-unified-container">
    @if (template == null)
    {
        <div class="text-center p-5">
            <RadzenProgressBarCircular ProgressBarStyle="ProgressBarStyle.Primary" Value="100" ShowValue="false" Class="mb-3" />
            <RadzenText TextStyle="TextStyle.Body1" Class="text-muted">Loading questionnaire...</RadzenText>
        </div>
    }
    else if (assignment != null && assignment.WorkflowState == WorkflowState.InReview && isManager)
    {
        <!-- Show Review Mode for managers during InReview state -->
        <QuestionnaireReviewMode Assignment="@assignment" OnReviewFinished="@OnReviewFinished" />
    }
    else
    {
        <RadzenCard Class="questionnaire-main-card p-4">
            <div class="questionnaire-header text-center mb-4">
                <RadzenText TextStyle="TextStyle.H3" Class="questionnaire-title text-primary">
                    <RadzenIcon Icon="quiz" Class="me-2" />
                    @template.Name
                </RadzenText>
                @if (!string.IsNullOrWhiteSpace(template.Description))
                {
                    <RadzenText TextStyle="TextStyle.Subtitle1" Class="questionnaire-subtitle text-muted">
                        @template.Description
                    </RadzenText>
                }
            </div>

            @* Workflow Action Buttons - Sticky Banner *@
            @if (assignment != null && assignmentId.HasValue)
            {
                <WorkflowActionButtons Assignment="@assignment"
                                      IsEmployee="@isEmployee"
                                      IsManager="@isManager"
                                      UserName="@currentUserName"
                                      OnActionCompleted="@OnWorkflowActionCompleted" />
            }

            @if (IsQuestionnaireCompleted())
            {
                @if (isManager && template != null && !template.RequiresManagerReview)
                {
                    <RadzenAlert AlertStyle="AlertStyle.Info" Variant="Variant.Flat" Shade="Shade.Lighter" Class="workflow-alert mb-4" ShowIcon="true">
                        <RadzenText TextStyle="TextStyle.Body1">
                            <strong>Viewing employee questionnaire in read-only mode.</strong>
                            <span> This questionnaire does not require manager input. You can view the employee's responses for monitoring purposes.</span>
                        </RadzenText>
                    </RadzenAlert>
                }
                else
                {
                    @* Show specific banner message based on workflow state *@
                    @if (assignment?.WorkflowState == WorkflowState.Finalized)
                    {
                        <RadzenAlert AlertStyle="AlertStyle.Success" Variant="Variant.Flat" Shade="Shade.Lighter" Class="workflow-alert mb-4" ShowIcon="true">
                            <RadzenText TextStyle="TextStyle.Body1">
                                <strong>This questionnaire has been finalized and is now locked.</strong>
                                <span> No further changes can be made. You can review the final responses below.</span>
                            </RadzenText>
                        </RadzenAlert>
                    }
                    else if (assignment?.WorkflowState == WorkflowState.ManagerReviewConfirmed)
                    {
                        <RadzenAlert AlertStyle="AlertStyle.Info" Variant="Variant.Flat" Shade="Shade.Lighter" Class="workflow-alert mb-4" ShowIcon="true">
                            <RadzenText TextStyle="TextStyle.Body1">
                                @if (isManager)
                                {
                                    <strong>Awaiting employee sign-off.</strong>
                                    <span> You have confirmed the review. Waiting for the employee to sign off before finalization.</span>
                                }
                                else
                                {
                                    <strong>Manager review confirmed.</strong>
                                    <span> The manager has confirmed the review. You can now sign off on the review outcome.</span>
                                }
                            </RadzenText>
                        </RadzenAlert>
                    }
                    else if (assignment?.WorkflowState == WorkflowState.EmployeeReviewConfirmed)
                    {
                        <RadzenAlert AlertStyle="AlertStyle.Info" Variant="Variant.Flat" Shade="Shade.Lighter" Class="workflow-alert mb-4" ShowIcon="true">
                            <RadzenText TextStyle="TextStyle.Body1">
                                @if (isManager)
                                {
                                    <strong>Ready to finalize.</strong>
                                    <span> The employee has signed off. You can now finalize the questionnaire.</span>
                                }
                                else
                                {
                                    <strong>Review signed off.</strong>
                                    <span> You have signed off on the review. Waiting for final confirmation to complete the questionnaire.</span>
                                }
                            </RadzenText>
                        </RadzenAlert>
                    }
                    else if (assignment?.WorkflowState == WorkflowState.InReview)
                    {
                        <RadzenAlert AlertStyle="AlertStyle.Warning" Variant="Variant.Flat" Shade="Shade.Lighter" Class="workflow-alert mb-4" ShowIcon="true">
                            <RadzenText TextStyle="TextStyle.Body1">
                                <strong>Review meeting in progress.</strong>
                                <span> This questionnaire is currently in review. Responses are temporarily read-only during the review phase.</span>
                            </RadzenText>
                        </RadzenAlert>
                    }
                    else if (assignment?.WorkflowState == WorkflowState.EmployeeSubmitted ||
                             assignment?.WorkflowState == WorkflowState.ManagerSubmitted ||
                             assignment?.WorkflowState == WorkflowState.BothSubmitted)
                    {
                        <RadzenAlert AlertStyle="AlertStyle.Info" Variant="Variant.Flat" Shade="Shade.Lighter" Class="workflow-alert mb-4" ShowIcon="true">
                            <RadzenText TextStyle="TextStyle.Body1">
                                <strong>Questionnaire submitted.</strong>
                                <span> Your responses have been submitted and are now read-only. Waiting for the next phase of the workflow.</span>
                            </RadzenText>
                        </RadzenAlert>
                    }
                    else
                    {
                        <RadzenAlert AlertStyle="AlertStyle.Success" Variant="Variant.Flat" Shade="Shade.Lighter" Class="workflow-alert mb-4" ShowIcon="true">
                            <RadzenText TextStyle="TextStyle.Body1">
                                <strong>This questionnaire is now read-only.</strong>
                                <span> You can review your responses below, but cannot make changes.</span>
                            </RadzenText>
                        </RadzenAlert>
                    }
                }
            }

            @* Show review changes summary after review meeting finishes *@
            @if (assignment != null && assignmentId.HasValue && response != null &&
                 template != null && template.RequiresManagerReview &&
                 (assignment.WorkflowState == WorkflowState.ManagerReviewConfirmed ||
                  assignment.WorkflowState == WorkflowState.EmployeeReviewConfirmed ||
                  assignment.WorkflowState == WorkflowState.Finalized))
            {
                <ReviewChangesSummary Response="@response" AssignmentId="@assignmentId.Value" />
            }

            <div class="section-counter mb-4">
                <RadzenText TextStyle="TextStyle.Body2" Class="text-muted text-end">
                    Section @(currentSectionIndex + 1) of @visibleSections.Count
                </RadzenText>
            </div>

            <RadzenSteps Value="@currentSectionIndex" Change="@OnSectionChanged" Class="mb-4" ShowStepsButtons="false">
                @for (int i = 0; i < visibleSections.Count; i++)
                {
                    var section = visibleSections[i];
                    var isCompleted = IsSectionCompleted(section.Id);
                    var sectionTitle = section.Title;
                    <RadzenStepsItem Text="@sectionTitle" Icon="@(isCompleted ? "check_circle" : null)" />
                }
            </RadzenSteps>

            <div class="questionnaire-content">
                @if (currentSection != null)
                {
                    <RadzenCard Class="section-card p-4">
                        <div class="section-card-header">
                            <div class="section-title-container flex-grow-1">
                                <RadzenText TextStyle="TextStyle.H4" Class="section-title text-primary mb-2">
                                    @currentSection.Title
                                </RadzenText>
                                @if (!string.IsNullOrWhiteSpace(currentSection.Description))
                                {
                                    <RadzenText TextStyle="TextStyle.Body1" Class="section-description text-muted">
                                        @currentSection.Description
                                    </RadzenText>
                                }
                            </div>
                            @if (currentSection.CompletionRole != CompletionRole.Both)
                            {
                                <div class="completion-role-badge @GetRoleBadgeClass(currentSection.CompletionRole)">
                                    <RadzenIcon Icon="@GetRoleIconForSection(currentSection.CompletionRole)" />
                                    @currentSection.CompletionRole.ToString()
                                </div>
                            }
                        </div>

                        <div class="questions-container">
                            @foreach (var question in currentSection.Questions.OrderBy(q => q.Order))
                            {
                                <div class="question-wrapper mb-4">
                                    @RenderQuestionWithRef(question)
                                </div>
                            }
                        </div>
                    </RadzenCard>
                }
            </div>

            <div class="navigation-footer d-flex justify-content-between mt-4">
                <RadzenButton Text="Previous"
                             ButtonStyle="ButtonStyle.Light"
                             Icon="arrow_back"
                             Click="@PreviousSection"
                             Disabled="@(currentSectionIndex == 0)" />

                <div class="navigation-actions d-flex gap-2">
                    @if (!IsQuestionnaireCompleted())
                    {
                        <RadzenButton Text="@(isSaving ? "Saving..." : "Save Progress")"
                                     ButtonStyle="ButtonStyle.Info"
                                     Icon="@(isSaving ? "hourglass_empty" : "save")"
                                     Click="@SaveProgress"
                                     Disabled="@isSaving" />

                        @if (currentSectionIndex == visibleSections.Count - 1)
                        {
                            <RadzenButton Text="@(isSubmitting ? "Submitting..." : "Submit")"
                                         ButtonStyle="ButtonStyle.Success"
                                         Icon="send"
                                         Click="@ShowReview"
                                         Disabled="@(!CanSubmit() || isSubmitting)" />
                        }
                        else
                        {
                            <RadzenButton Text="Next"
                                         ButtonStyle="ButtonStyle.Primary"
                                         Icon="arrow_forward"
                                         Click="@NextSection"
                                         Disabled="@(!CanProceedFromCurrentSection())" />
                        }
                    }
                    else
                    {
                        @* In read-only mode *@
                        @if (currentSectionIndex < visibleSections.Count - 1)
                        {
                            @* Show Next button for navigation if not on last section *@
                            <RadzenButton Text="Next"
                                         ButtonStyle="ButtonStyle.Primary"
                                         Icon="arrow_forward"
                                         Click="@NextSection" />
                        }
                    }
                </div>
            </div>

            @* Review Comments Display - Below Questionnaire *@
            @* Show after review meeting finishes so employee can see manager's summary before signing off *@
            @if (assignment != null && template != null && template.RequiresManagerReview &&
                 (assignment.WorkflowState == WorkflowState.ManagerReviewConfirmed ||
                  assignment.WorkflowState == WorkflowState.EmployeeReviewConfirmed ||
                  assignment.WorkflowState == WorkflowState.Finalized))
            {
                <ReviewComments Assignment="@assignment"
                               IsEmployee="@isEmployee"
                               IsManager="@isManager" />
            }
        </RadzenCard>
    }
</div>

@code {
    [Parameter] public Guid? TemplateId { get; set; }
    [Parameter] public Guid? AssignmentId { get; set; }

    private Guid? assignmentId;
    private QuestionnaireAssignment? assignment;
    private QuestionnaireTemplate? template;
    private QuestionnaireResponse response = new();
    private int currentSectionIndex = 0;

    // Store references to question renderers for calling SavePendingGoalChanges
    private Dictionary<Guid, OptimizedQuestionRenderer> questionRenderers = new();

    /// <summary>
    /// The user's organizational role determining data access permissions.
    /// Maps to ApplicationRole enum: Employee, TeamLead, HR, HRLead, Admin.
    /// </summary>
    private ApplicationRole userRole = ApplicationRole.Employee;

    /// <summary>
    /// Whether user has manager-level privileges (TeamLead or higher).
    /// Determines endpoint access and UI features.
    /// </summary>
    private bool HasManagerPrivileges => userRole is ApplicationRole.TeamLead
        or ApplicationRole.HR
        or ApplicationRole.HRLead
        or ApplicationRole.Admin;

    /// <summary>
    /// Whether user can act as an employee (complete employee sections, view own responses).
    /// TRUE for all users - everyone has employee-level access.
    /// Note: Used for explicit checks (e.g., "isEmployee && !isManager") and component parameters.
    /// In simple if/else branches, prefer "else" over "else if (isEmployee)" since it's always true.
    /// </summary>
    private bool isEmployee => true;

    /// <summary>
    /// Whether user can act as a manager (complete manager sections, view team responses).
    /// TRUE for TeamLead, HR, HRLead, Admin.
    /// This is used to determine which API endpoints to call and which UI features to show.
    /// </summary>
    private bool isManager => HasManagerPrivileges;

    /// <summary>
    /// The response role for accessing RoleResponses dictionary.
    /// Determines which response set (Employee or Manager) the user is currently viewing/editing.
    /// This is separate from organizational role (ApplicationRole) and section assignment (CompletionRole).
    /// </summary>
    private ResponseRole CurrentResponseRole => userRole.ToResponseRole();

    /// <summary>
    /// Legacy string accessor for compatibility with components that expect string role names.
    /// New code should use CurrentResponseRole enum directly.
    /// </summary>
    private string currentUserRole => CurrentResponseRole.ToRoleKey();

    private string currentUserName = string.Empty;
    private List<QuestionSection> visibleSections = new();
    private QuestionSection? currentSection => visibleSections.ElementAtOrDefault(currentSectionIndex);
    private bool isSubmitting = false;
    private bool isProcessing = false;
    private bool isSaving = false;

    private bool IsQuestionnaireCompleted()
    {
        // Read-only state is determined ONLY by the assignment's WorkflowState
        // The response.Status is for domain-level validation, not UI read-only logic
        if (assignment == null)
            return false;

        // Phase 2 Read-Only (Permanent): After finalization
        var isPhase2ReadOnly = assignment.WorkflowState == WorkflowState.Finalized;

        // After review confirmation states (waiting for finalization)
        var isPostReviewConfirmation = assignment.WorkflowState is WorkflowState.EmployeeReviewConfirmed or WorkflowState.ManagerReviewConfirmed;

        // Managers/HR viewing employee-only questionnaires should always see read-only
        if (isManager && template != null && !template.RequiresManagerReview)
        {
            return true;
        }

        // Determine read-only based on user role and workflow state
        if (isEmployee && !isManager)
        {
            // Employee can edit: Assigned, EmployeeInProgress, BothInProgress, ManagerSubmitted
            // Employee is READ-ONLY during: InReview (manager-led review meeting)
            // Employee CANNOT edit after: EmployeeSubmitted, BothSubmitted, Post-review, Finalized
            // Note: Employee CAN still edit when ManagerSubmitted (manager submitted but employee hasn't)
            return assignment.WorkflowState is WorkflowState.EmployeeSubmitted or WorkflowState.BothSubmitted or WorkflowState.InReview
                || isPostReviewConfirmation
                || isPhase2ReadOnly;
        }
        else if (isManager)
        {
            // Manager can edit: Assigned, ManagerInProgress, BothInProgress, InReview
            // Manager CANNOT edit ONLY when: ManagerSubmitted, BothSubmitted, Post-review, Finalized
            // Note: Manager CAN still see EmployeeSubmitted state (employee submitted but manager hasn't)
            return assignment.WorkflowState is WorkflowState.ManagerSubmitted or WorkflowState.BothSubmitted
                || isPostReviewConfirmation
                || isPhase2ReadOnly;
        }

        return isPhase2ReadOnly; // Default: only finalized is truly read-only
    }

    protected override async Task OnInitializedAsync()
    {
        await DetermineUserRole();
        await LoadAssignmentAndTemplate();
        await InitializeResponseAsync();
        await LoadExistingResponse();
        await FilterVisibleSections();
        UpdateProgress();
    }

    protected override bool HasStateChanged()
    {
        return HasParameterChanged(nameof(currentSectionIndex), currentSectionIndex) ||
               HasParameterChanged(nameof(response.ProgressPercentage), response.ProgressPercentage) ||
               HasParameterChanged(nameof(template), template) ||
               HasParameterChanged(nameof(isSaving), isSaving) ||
               HasParameterChanged(nameof(isSubmitting), isSubmitting);
    }

    private async Task DetermineUserRole()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        // Get user name for workflow actions
        currentUserName = user.Identity?.Name ?? "Unknown User";

        try
        {
            // WebAssembly client doesn't have ApplicationRole claims (those are added server-side only)
            // So we need to call the API to get the user's role from the database
            var roleData = await AuthService.GetMyRoleAsync();

            if (roleData == null)
            {
                // Default to Employee for safety
                userRole = ApplicationRole.Employee;
                return;
            }

            // Store the actual ApplicationRole - computed properties derive behavior from it
            userRole = roleData.ApplicationRole;
        }
        catch (Exception ex)
        {
            // Default to Employee for safety
            userRole = ApplicationRole.Employee;
        }
    }

    private async Task LoadAssignmentAndTemplate()
    {
        try
        {
            // Determine which parameter was provided
            if (AssignmentId.HasValue)
            {
                // New route: /questionnaire/{assignmentId}
                assignmentId = AssignmentId.Value;

                // Load assignment using appropriate service based on user privileges
                // IMPORTANT: Check manager privileges FIRST because TeamLeads/HR have broader data access
                // - Managers use the general assignment endpoint (can view team's assignments)
                // - Employees use the "me/assignments" endpoint (only their own assignments)
                // Note: A TeamLead IS an employee with additional privileges, not a separate role
                if (isManager)
                {
                    // Managers use the general assignment service
                    // Backend validates manager has this employee in their team
                    assignment = await AssignmentService.GetAssignmentByIdAsync(assignmentId.Value);
                }
                else
                {
                    // Regular employees use the "me/assignments/{id}" endpoint which validates ownership
                    assignment = await EmployeeQuestionnaireService.GetMyAssignmentByIdAsync(assignmentId.Value);
                }

                if (assignment == null)
                {
                    NotificationService.Notify(NotificationSeverity.Error, "Error", "Assignment not found");
                    NavigateBack();
                    return;
                }

                template = await TemplateService.GetTemplateByIdAsync(assignment.TemplateId);
            }
            else if (TemplateId.HasValue)
            {
                // Legacy route: /my-questionnaires/{templateId} (employee only)
                await LoadTemplate();
                await LoadAssignmentForCurrentEmployee();
            }
            else
            {
                NotificationService.Notify(NotificationSeverity.Error, "Error", "No questionnaire specified");
                NavigateBack();
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(NotificationSeverity.Error, "Error", $"Failed to load questionnaire: {ex.Message}");
            NavigateBack();
        }
    }

    private async Task FilterVisibleSections()
    {
        if (template == null)
        {
            visibleSections = new List<QuestionSection>();
            return;
        }

        // After review meeting finishes, EVERYONE sees ALL sections (employee, manager, and both)
        // This ensures transparency - both parties can see what was discussed and agreed upon
        var isPostReviewState = assignment != null &&
            (assignment.WorkflowState is WorkflowState.ManagerReviewConfirmed or
                                         WorkflowState.EmployeeReviewConfirmed or
                                         WorkflowState.Finalized);

        // Managers/HR can view employee-only questionnaires in read-only mode
        var isManagerViewingEmployeeOnlyQuestionnaire = isManager && !template.RequiresManagerReview;

        if (isPostReviewState || isManagerViewingEmployeeOnlyQuestionnaire)
        {
            // Show ALL sections in read-only view
            visibleSections = template.Sections.OrderBy(s => s.Order).ToList();
            return;
        }

        // Filter sections based on workflow state and user role
        // BUSINESS RULES:
        // - Employees: See Employee + Both sections (backend filters responses in Both sections to only Employee responses)
        // - Managers: See Manager + Both sections (backend filters responses in Both sections to only Manager responses)
        // - InReview state: Manager sees ALL sections, Employee sees Employee + Both sections
        // - ManagerReviewConfirmed onwards: Everyone sees ALL sections (full transparency)
        visibleSections = template.Sections
            .Where(s =>
            {
                if (assignment == null)
                {
                    // No assignment context - use default role-based filtering
                    if (isManager && (s.CompletionRole == CompletionRole.Manager || s.CompletionRole == CompletionRole.Both))
                        return true;
                    if (isEmployee && (s.CompletionRole == CompletionRole.Employee || s.CompletionRole == CompletionRole.Both))
                        return true;
                    return false;
                }

                // From ManagerReviewConfirmed onwards: Everyone sees ALL sections
                if (assignment.WorkflowState is WorkflowState.ManagerReviewConfirmed or
                                                WorkflowState.EmployeeReviewConfirmed or
                                                WorkflowState.Finalized)
                {
                    return true;
                }

                // InReview state: Manager sees ALL, Employee sees Employee + Both
                if (assignment.WorkflowState == WorkflowState.InReview)
                {
                    if (isManager)
                        return true; // Manager sees ALL sections
                    else
                        return s.CompletionRole == CompletionRole.Employee || s.CompletionRole == CompletionRole.Both;
                }

                // In-Progress + Submitted states: Role-based filtering
                // Employees see: Employee + Both
                // Managers see: Manager + Both
                if (isManager)
                {
                    return s.CompletionRole == CompletionRole.Manager || s.CompletionRole == CompletionRole.Both;
                }
                else
                {
                    return s.CompletionRole == CompletionRole.Employee || s.CompletionRole == CompletionRole.Both;
                }
            })
            .OrderBy(s => s.Order)
            .ToList();

        // If no visible sections, show helpful error
        if (!visibleSections.Any() && template.Sections.Any())
        {
            var sectionDetails = string.Join(", ", template.Sections.Select(s => $"'{s.Title}' (assigned to {s.CompletionRole})"));
            var roleDescription = isManager ? "managers" : "employees";
            NotificationService.Notify(NotificationSeverity.Warning, "No Sections Available",
                $"This questionnaire has no sections assigned to {roleDescription}. " +
                $"Please edit the template to assign sections appropriately. " +
                $"Current sections: {sectionDetails}");
        }
    }

    private void NavigateBack()
    {
        if (isManager)
            NavigationManager.NavigateTo("/team/questionnaires");
        else
            NavigationManager.NavigateTo("/my-questionnaires");
    }

    private async Task LoadTemplate()
    {
        if (!TemplateId.HasValue) return;

        try
        {
            template = await TemplateService.GetTemplateByIdAsync(TemplateId.Value);
            if (template == null)
            {
                NotificationService.Notify(NotificationSeverity.Error, "Error", "Questionnaire template not found");
                NavigationManager.NavigateTo("/my-questionnaires");
                return;
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(NotificationSeverity.Error, "Error", $"Failed to load questionnaire: {ex.Message}");
            NavigationManager.NavigateTo("/my-questionnaires");
            return;
        }

        // Fallback to sample template if API fails
        if (template == null)
        {
        template = new QuestionnaireTemplate
        {
            Id = TemplateId.Value,
            Name = "Employee Performance Review",
            Description = "Annual performance evaluation questionnaire",
            Sections = new List<QuestionSection>
            {
                new QuestionSection
                {
                    Id = Guid.NewGuid(),
                    Title = "Self Assessment",
                    Description = "Rate your performance in key areas",
                    Order = 0,
                    Questions = new List<QuestionItem>
                    {
                        new QuestionItem
                        {
                            Id = Guid.NewGuid(),
                            Title = "How would you rate your overall performance this year?",
                            Type = QuestionType.Assessment,
                            Order = 0,
                            IsRequired = true
                        },
                        new QuestionItem
                        {
                            Id = Guid.NewGuid(),
                            Title = "What are your key accomplishments?",
                            Type = QuestionType.TextQuestion,
                            Order = 1,
                            IsRequired = true
                        }
                    }
                },
                new QuestionSection
                {
                    Id = Guid.NewGuid(),
                    Title = "Goals for Next Year",
                    Description = "Define your objectives for the upcoming year",
                    Order = 1,
                    Questions = new List<QuestionItem>
                    {
                        new QuestionItem
                        {
                            Id = Guid.NewGuid(),
                            Title = "Set your primary goal for next year",
                            Type = QuestionType.Goal,
                            Order = 0,
                            IsRequired = true
                        }
                    }
                }
            }
        };
        }
    }

    private async Task LoadAssignmentForCurrentEmployee()
    {
        try
        {
            // Load the current employee's assignment for this template
            var assignments = await EmployeeQuestionnaireService.GetMyAssignmentsAsync();
            var matchingAssignment = assignments.FirstOrDefault(a => a.TemplateId == TemplateId!.Value &&
                                                           a.WorkflowState != WorkflowState.Finalized);

            if (matchingAssignment != null)
            {
                assignmentId = matchingAssignment.Id;
                assignment = matchingAssignment;
            }
            else
            {
                NotificationService.Notify(NotificationSeverity.Warning, "Not Assigned", "This questionnaire has not been assigned to you.");
                NavigationManager.NavigateTo("/my-questionnaires");
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(NotificationSeverity.Error, "Error", $"Failed to load assignment: {ex.Message}");
            NavigationManager.NavigateTo("/my-questionnaires");
        }
    }

    private async Task LoadExistingResponse()
    {
        if (!assignmentId.HasValue) return;

        try
        {
            QuestionnaireResponse? existingResponse = null;

            // After review meeting, everyone loads ALL role responses for full transparency
            var isPostReviewState = assignment != null &&
                (assignment.WorkflowState is WorkflowState.ManagerReviewConfirmed or
                                             WorkflowState.EmployeeReviewConfirmed or
                                             WorkflowState.Finalized);

            if (isPostReviewState || isManager)
            {
                // Post-review or managers: load ALL role responses (Employee + Manager + Both)
                existingResponse = await ResponseService.GetResponseByAssignmentIdAsync(assignmentId.Value);
            }
            else
            {
                // Regular employees during questionnaire: load only their own responses
                existingResponse = await EmployeeQuestionnaireService.GetMyResponseAsync(assignmentId.Value);
            }

            if (existingResponse == null || !existingResponse.SectionResponses.Any())
            {
                return;
            }

            // Merge existing responses with initialized structure
            foreach (var sectionKvp in existingResponse.SectionResponses)
            {
                if (response.SectionResponses.TryGetValue(sectionKvp.Key, out var sectionResponse))
                {
                    // After review meeting: load ALL role responses for full transparency
                    // Managers viewing employee-only questionnaires: load ALL responses
                    // Normal mode: only load current user's role responses
                    var isManagerViewingEmployeeOnlyQuestionnaire = isManager && template != null && !template.RequiresManagerReview;

                    if ((isPostReviewState || isManagerViewingEmployeeOnlyQuestionnaire) && sectionKvp.Value.RoleResponses != null)
                    {
                        // Load ALL role responses (Employee, Manager)
                        foreach (var roleKvp in sectionKvp.Value.RoleResponses)
                        {
                            var role = roleKvp.Key;
                            var roleQuestions = roleKvp.Value;

                            // Ensure role exists in response structure
                            if (!sectionResponse.RoleResponses.ContainsKey(role))
                            {
                                sectionResponse.RoleResponses[role] = new Dictionary<Guid, QuestionResponse>();
                            }

                            // Merge question responses for this role
                            foreach (var questionKvp in roleQuestions)
                            {
                                sectionResponse.RoleResponses[role][questionKvp.Key] = questionKvp.Value;
                            }
                        }
                    }
                    else if (sectionKvp.Value.RoleResponses != null && sectionKvp.Value.RoleResponses.TryGetValue(CurrentResponseRole, out var roleQuestions))
                    {
                        // Normal mode: only load current user's role responses
                        foreach (var questionKvp in roleQuestions)
                        {
                            if (sectionResponse.RoleResponses.ContainsKey(CurrentResponseRole) &&
                                sectionResponse.RoleResponses[CurrentResponseRole].ContainsKey(questionKvp.Key))
                            {
                                sectionResponse.RoleResponses[CurrentResponseRole][questionKvp.Key] = questionKvp.Value;
                            }
                        }
                    }
                    sectionResponse.IsCompleted = sectionKvp.Value.IsCompleted;
                }
            }

            // Find current section based on progress
            var completedSections = response.SectionResponses.Count(sr => sr.Value.IsCompleted);
            currentSectionIndex = Math.Min(completedSections, Math.Max(0, visibleSections.Count - 1));
        }
        catch (Exception ex)
        {
            // Could not load existing response - continue with new response
        }
    }

    private async Task InitializeResponseAsync()
    {
        if (template == null) return;

        // Get current user's EmployeeGuid from claims
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var employeeGuid = authState.User.FindFirst("EmployeeGuid")?.Value ?? string.Empty;

        response = new QuestionnaireResponse
        {
            TemplateId = TemplateId ?? template?.Id ?? Guid.Empty,
            AssignmentId = assignmentId ?? Guid.Empty,
            EmployeeId = employeeGuid
        };

        // Initialize section responses with role-based structure
        foreach (var section in template.Sections)
        {
            var sectionResponse = new SectionResponse
            {
                SectionId = section.Id,
                RoleResponses = new Dictionary<ResponseRole, Dictionary<Guid, QuestionResponse>>()
            };

            // Initialize question responses for current user's role
            sectionResponse.RoleResponses[CurrentResponseRole] = new Dictionary<Guid, QuestionResponse>();

            foreach (var question in section.Questions)
            {
                sectionResponse.RoleResponses[CurrentResponseRole][question.Id] = new QuestionResponse
                {
                    QuestionId = question.Id,
                    QuestionType = question.Type
                };
            }

            response.SectionResponses[section.Id] = sectionResponse;
        }
    }

    private RenderFragment RenderQuestion(QuestionItem question)
    {
        // Check if we're in post-review state and section is "Both"
        var isPostReviewState = assignment != null &&
            (assignment.WorkflowState is WorkflowState.ManagerReviewConfirmed or
                                         WorkflowState.EmployeeReviewConfirmed or
                                         WorkflowState.Finalized);

        var isBothSection = currentSection?.CompletionRole == CompletionRole.Both;

        // In post-review state for "Both" sections, show BOTH employee and manager responses
        if (isPostReviewState && isBothSection)
        {
            var employeeResponse = GetQuestionResponseForRole(question.Id, "Employee");
            var managerResponse = GetQuestionResponseForRole(question.Id, "Manager");

            return @<div>
                @* Employee's Answer *@
                <div class="role-response-section mb-4">
                    <RadzenText TextStyle="TextStyle.Subtitle2" Class="fw-bold text-success mb-2">
                        <RadzenIcon Icon="person" Class="me-1" />
                        EMPLOYEE'S ANSWER
                    </RadzenText>
                    <div class="ps-3 border-start border-success border-3">
                        <OptimizedQuestionRenderer
                            Question="@question"
                            Response="@employeeResponse"
                            OnResponseChanged="@HandleQuestionResponseChangedDynamic"
                            IsReadOnly="true"
                            HideHeader="true"
                            AssignmentId="@(assignmentId ?? Guid.Empty)"
                            CurrentUserRole="Employee"
                            AssignmentWorkflowState="@(assignment?.WorkflowState ?? WorkflowState.EmployeeInProgress)" />
                    </div>
                </div>

                @* Manager's Answer *@
                <div class="role-response-section">
                    <RadzenText TextStyle="TextStyle.Subtitle2" Class="fw-bold text-info mb-2">
                        <RadzenIcon Icon="manage_accounts" Class="me-1" />
                        MANAGER'S ANSWER
                    </RadzenText>
                    <div class="ps-3 border-start border-info border-3">
                        <OptimizedQuestionRenderer
                            Question="@question"
                            Response="@managerResponse"
                            OnResponseChanged="@HandleQuestionResponseChangedDynamic"
                            IsReadOnly="true"
                            HideHeader="true"
                            AssignmentId="@(assignmentId ?? Guid.Empty)"
                            CurrentUserRole="Manager"
                            AssignmentWorkflowState="@(assignment?.WorkflowState ?? WorkflowState.ManagerInProgress)" />
                    </div>
                </div>
            </div>;
        }

        // Normal rendering for non-Both sections or during active questionnaire
        var questionResponse = GetQuestionResponse(question.Id);

        return @<OptimizedQuestionRenderer
            Question="@question"
            Response="@questionResponse"
            OnResponseChanged="@HandleQuestionResponseChangedDynamic"
            IsReadOnly="@IsQuestionnaireCompleted()"
            AssignmentId="@(assignmentId ?? Guid.Empty)"
            CurrentUserRole="@currentUserRole"
            AssignmentWorkflowState="@(assignment?.WorkflowState ?? WorkflowState.EmployeeInProgress)" />;
    }

    private RenderFragment RenderQuestionWithRef(QuestionItem question)
    {
        // Check if we're in post-review state and section is "Both"
        var isPostReviewState = assignment != null &&
            (assignment.WorkflowState is WorkflowState.ManagerReviewConfirmed or
                                         WorkflowState.EmployeeReviewConfirmed or
                                         WorkflowState.Finalized);

        var isBothSection = currentSection?.CompletionRole == CompletionRole.Both;

        // In post-review state for "Both" sections, show BOTH employee and manager responses
        if (isPostReviewState && isBothSection)
        {
            var employeeResponse = GetQuestionResponseForRole(question.Id, "Employee");
            var managerResponse = GetQuestionResponseForRole(question.Id, "Manager");

            return @<div>
                @* Employee's Answer *@
                <div class="role-response-section mb-4">
                    <RadzenText TextStyle="TextStyle.Subtitle2" Class="fw-bold text-success mb-2">
                        <RadzenIcon Icon="person" Class="me-1" />
                        EMPLOYEE'S ANSWER
                    </RadzenText>
                    <div class="ps-3 border-start border-success border-3">
                        <OptimizedQuestionRenderer
                            Question="@question"
                            Response="@employeeResponse"
                            OnResponseChanged="@HandleQuestionResponseChangedDynamic"
                            IsReadOnly="true"
                            HideHeader="true"
                            AssignmentId="@(assignmentId ?? Guid.Empty)"
                            CurrentUserRole="Employee"
                            AssignmentWorkflowState="@(assignment?.WorkflowState ?? WorkflowState.EmployeeInProgress)" />
                    </div>
                </div>

                @* Manager's Answer *@
                <div class="role-response-section">
                    <RadzenText TextStyle="TextStyle.Subtitle2" Class="fw-bold text-info mb-2">
                        <RadzenIcon Icon="manage_accounts" Class="me-1" />
                        MANAGER'S ANSWER
                    </RadzenText>
                    <div class="ps-3 border-start border-info border-3">
                        <OptimizedQuestionRenderer
                            Question="@question"
                            Response="@managerResponse"
                            OnResponseChanged="@HandleQuestionResponseChangedDynamic"
                            IsReadOnly="true"
                            HideHeader="true"
                            AssignmentId="@(assignmentId ?? Guid.Empty)"
                            CurrentUserRole="Manager"
                            AssignmentWorkflowState="@(assignment?.WorkflowState ?? WorkflowState.ManagerInProgress)" />
                    </div>
                </div>
            </div>;
        }

        // Normal rendering for non-Both sections or during active questionnaire
        var questionResponse = GetQuestionResponse(question.Id);

        // Store reference for goal questions so we can call SavePendingGoalChanges later
        return @<OptimizedQuestionRenderer
            @ref="questionRenderers[question.Id]"
            Question="@question"
            Response="@questionResponse"
            OnResponseChanged="@HandleQuestionResponseChangedDynamic"
            IsReadOnly="@IsQuestionnaireCompleted()"
            AssignmentId="@(assignmentId ?? Guid.Empty)"
            CurrentUserRole="@currentUserRole"
            AssignmentWorkflowState="@(assignment?.WorkflowState ?? WorkflowState.EmployeeInProgress)" />;
    }

    /// <summary>
    /// Saves all pending goal changes across all question renderers.
    /// Returns true if all operations succeed.
    /// </summary>
    private async Task<bool> SaveAllPendingGoalChanges()
    {
        if (!questionRenderers.Any())
            return true;

        bool allSucceeded = true;
        foreach (var renderer in questionRenderers.Values)
        {
            if (renderer != null)
            {
                var success = await renderer.SavePendingGoalChanges();
                if (!success)
                {
                    allSucceeded = false;
                }
            }
        }

        return allSucceeded;
    }

    private async Task HandleQuestionResponseChangedDynamic(QuestionResponse updatedResponse)
    {
        // Response object is already updated by reference
        // Trigger validation and progress update
        UpdateProgress();
        await InvokeAsync(StateHasChanged);
    }

    // Helper methods for question responses
    private QuestionResponse GetQuestionResponseForRole(Guid questionId, string roleName)
    {
        if (currentSection == null) return new QuestionResponse { QuestionId = questionId };

        var sectionResponse = response.SectionResponses[currentSection.Id];
        var role = ResponseRoleExtensions.ParseRoleKey(roleName);

        // Access responses for the specified role
        if (sectionResponse.RoleResponses.TryGetValue(role, out var roleQuestions) &&
            roleQuestions.TryGetValue(questionId, out var questionResponse))
        {
            return questionResponse;
        }

        return new QuestionResponse { QuestionId = questionId };
    }

    private QuestionResponse GetQuestionResponse(Guid questionId)
    {
        if (currentSection == null) return new QuestionResponse { QuestionId = questionId };

        var sectionResponse = response.SectionResponses[currentSection.Id];

        // Determine which role's responses to fetch based on section's CompletionRole
        // In read-only mode after review, managers view responses based on who originally completed the section
        // Employees in post-review states also need to view responses based on section's CompletionRole
        // After review meeting or when viewing employee-only questionnaires
        var isPostReviewState = assignment != null &&
            (assignment.WorkflowState is WorkflowState.ManagerReviewConfirmed or
                                          WorkflowState.EmployeeReviewConfirmed or
                                          WorkflowState.Finalized);

        var isManagerViewingEmployeeOnlyQuestionnaire = isManager && template != null && !template.RequiresManagerReview;

        ResponseRole roleToFetch = CurrentResponseRole;

        if (isPostReviewState || isManagerViewingEmployeeOnlyQuestionnaire)
        {
            // In post-review states or when manager views employee-only questionnaire,
            // fetch responses based on section's CompletionRole
            roleToFetch = currentSection.CompletionRole switch
            {
                CompletionRole.Employee => ResponseRole.Employee,
                CompletionRole.Manager => ResponseRole.Manager,
                CompletionRole.Both => CurrentResponseRole,
                _ => CurrentResponseRole
            };
        }

        // Access responses for the determined role
        if (sectionResponse.RoleResponses.TryGetValue(roleToFetch, out var roleQuestions) &&
            roleQuestions.TryGetValue(questionId, out var questionResponse))
        {
            return questionResponse;
        }

        return new QuestionResponse { QuestionId = questionId };
    }

    private void UpdateQuestionResponse(Guid questionId, int value)
    {
        var questionResponse = GetQuestionResponse(questionId);
        questionResponse.ComplexValue = new Dictionary<string, object> { { "value", value } };
        questionResponse.LastModified = DateTime.Now;
        UpdateProgress();
        NotifyStateChanged();
    }

    private void UpdateQuestionResponseText(Guid questionId, string value)
    {
        var questionResponse = GetQuestionResponse(questionId);
        questionResponse.ComplexValue = new Dictionary<string, object> { { "value", value } };
        questionResponse.LastModified = DateTime.Now;
        UpdateProgress();
        NotifyStateChangedDebounced(200);
    }

    // Goal question helpers
    private DateTime? GetGoalStartDate(Guid questionId)
    {
        var response = GetQuestionResponse(questionId);
        return response.ComplexValue?.TryGetValue("StartDate", out var value) == true ? (DateTime?)value : null;
    }

    private string GetGoalJustification(Guid questionId)
    {
        var response = GetQuestionResponse(questionId);
        return response.ComplexValue?.TryGetValue("Justification", out var value) == true ? value.ToString() ?? "" : "";
    }

    private ProgressBarStyle GetProgressStyle(int percentage)
    {
        return percentage switch
        {
            >= 90 => ProgressBarStyle.Success,
            >= 70 => ProgressBarStyle.Info,
            >= 50 => ProgressBarStyle.Warning,
            _ => ProgressBarStyle.Danger
        };
    }

    private string GetStatusStyle(int percentage)
    {
        var color = percentage switch
        {
            >= 90 => "background-color: var(--light-blue); border: 1px solid var(--success-color); color: var(--dark-blue);",
            >= 70 => "background-color: rgba(0, 230, 200, 0.1); border: 1px solid var(--green-new); color: var(--dark-blue);",
            >= 50 => "background-color: rgba(230, 191, 127, 0.2); border: 1px solid var(--golden-milk); color: var(--dark-blue);",
            _ => "background-color: rgba(240, 128, 128, 0.2); border: 1px solid var(--peach-kiss); color: var(--dark-blue);"
        };
        return color;
    }

    private string GetStatusIcon(int percentage)
    {
        return percentage switch
        {
            >= 90 => "check_circle",
            >= 70 => "task_alt",
            >= 50 => "warning",
            _ => "error"
        };
    }

    private string GetStatusText(int percentage)
    {
        return percentage switch
        {
            >= 90 => "Excellent Achievement",
            >= 70 => "Good Achievement", 
            >= 50 => "Partial Achievement",
            _ => "Below Expectations"
        };
    }

    private string GetGoalMeasurement(Guid questionId)
    {
        var response = GetQuestionResponse(questionId);
        return response.ComplexValue?.TryGetValue("Measurement", out var value) == true ? value.ToString() ?? "" : "";
    }

    private decimal GetGoalWeighting(Guid questionId)
    {
        var response = GetQuestionResponse(questionId);
        return response.ComplexValue?.TryGetValue("Weighting", out var value) == true ? Convert.ToDecimal(value) : 0m;
    }

    private bool GetBooleanValue(Guid questionId)
    {
        var response = GetQuestionResponse(questionId);
        return response.ComplexValue?.TryGetValue("value", out var value) == true && value?.ToString() == "true";
    }

    private DateTime? GetDateValue(Guid questionId)
    {
        var response = GetQuestionResponse(questionId);
        if (response.ComplexValue?.TryGetValue("value", out var value) == true && value is DateTime dateValue)
            return dateValue;
        return null;
    }

    private int GetNumericValue(Guid questionId)
    {
        var response = GetQuestionResponse(questionId);
        if (response.ComplexValue?.TryGetValue("value", out var value) == true)
        {
            if (value is int intValue) return intValue;
            if (int.TryParse(value?.ToString(), out var parsed)) return parsed;
        }
        return 0;
    }

    // Setter methods for goal questions
    private void SetGoalStartDate(Guid questionId, DateTime? value)
    {
        var response = GetQuestionResponse(questionId);
        if (response.ComplexValue == null) response.ComplexValue = new Dictionary<string, object>();
        if (value.HasValue) response.ComplexValue["StartDate"] = value.Value;
        else response.ComplexValue.Remove("StartDate");
        response.LastModified = DateTime.Now;
        UpdateProgress();
    }

    private void SetGoalEndDate(Guid questionId, DateTime? value)
    {
        var response = GetQuestionResponse(questionId);
        if (response.ComplexValue == null) response.ComplexValue = new Dictionary<string, object>();
        if (value.HasValue) response.ComplexValue["EndDate"] = value.Value;
        else response.ComplexValue.Remove("EndDate");
        response.LastModified = DateTime.Now;
        UpdateProgress();
    }

    private void SetGoalDescription(Guid questionId, string value)
    {
        var response = GetQuestionResponse(questionId);
        if (response.ComplexValue == null) response.ComplexValue = new Dictionary<string, object>();
        response.ComplexValue["Description"] = value ?? "";
        response.LastModified = DateTime.Now;
        UpdateProgress();
    }

    private void SetGoalPercentage(Guid questionId, int value)
    {
        var response = GetQuestionResponse(questionId);
        if (response.ComplexValue == null) response.ComplexValue = new Dictionary<string, object>();
        response.ComplexValue["AchievementPercentage"] = value;
        response.LastModified = DateTime.Now;
        UpdateProgress();
    }

    private void SetGoalJustification(Guid questionId, string value)
    {
        var response = GetQuestionResponse(questionId);
        if (response.ComplexValue == null) response.ComplexValue = new Dictionary<string, object>();
        response.ComplexValue["Justification"] = value ?? "";
        response.LastModified = DateTime.Now;
        UpdateProgress();
    }

    private void SetGoalMeasurement(Guid questionId, string value)
    {
        var response = GetQuestionResponse(questionId);
        if (response.ComplexValue == null) response.ComplexValue = new Dictionary<string, object>();
        response.ComplexValue["Measurement"] = value ?? "";
        response.LastModified = DateTime.Now;
        UpdateProgress();
    }

    private void SetGoalWeighting(Guid questionId, decimal value)
    {
        var response = GetQuestionResponse(questionId);
        if (response.ComplexValue == null) response.ComplexValue = new Dictionary<string, object>();
        response.ComplexValue["Weighting"] = value;
        response.LastModified = DateTime.Now;
        UpdateProgress();
    }

    private void SetSimpleValue(Guid questionId, object? value)
    {
        var response = GetQuestionResponse(questionId);
        if (value != null)
        {
            // For bool, store as lowercase string "true"/"false" for consistency
            if (value is bool boolValue)
                value = boolValue.ToString().ToLower();

            response.ComplexValue = new Dictionary<string, object> { { "value", value } };
        }
        else
        {
            response.ComplexValue = null;
        }
        response.LastModified = DateTime.Now;
        UpdateProgress();
    }

    // Navigation methods
    private void OnSectionChanged(int newIndex)
    {
        // In read-only mode, allow free navigation between all sections
        if (IsQuestionnaireCompleted())
        {
            if (HasParameterChanged(nameof(currentSectionIndex), newIndex))
            {
                currentSectionIndex = newIndex;
                NotifyStateChanged();
            }
            return;
        }

        // In edit mode, validate completion before allowing forward navigation
        if (newIndex < currentSectionIndex || CanProceedFromCurrentSection())
        {
            if (HasParameterChanged(nameof(currentSectionIndex), newIndex))
            {
                currentSectionIndex = newIndex;
                NotifyStateChanged();
            }
        }
        else
        {
            NotificationService.Notify(NotificationSeverity.Warning,
                "Complete Section",
                "Please complete all required questions in the current section.");
        }
    }

    private void PreviousSection()
    {
        if (currentSectionIndex > 0)
        {
            currentSectionIndex--;
            NotifyStateChanged();
        }
    }

    private void NextSection()
    {
        // In read-only mode, allow navigation without validation
        if (IsQuestionnaireCompleted())
        {
            if (currentSectionIndex < visibleSections.Count - 1)
            {
                currentSectionIndex++;
                NotifyStateChanged();
            }
            return;
        }

        // In edit mode, validate completion before allowing navigation
        if (CanProceedFromCurrentSection() && currentSectionIndex < visibleSections.Count - 1)
        {
            currentSectionIndex++;
            UpdateProgress();
            NotifyStateChanged();
        }
    }

    private bool CanProceedFromCurrentSection()
    {
        if (currentSection == null || !currentSection.IsRequired) return true;

        var sectionResponse = response.SectionResponses[currentSection.Id];

        // Check if role responses exist for current user
        if (!sectionResponse.RoleResponses.TryGetValue(CurrentResponseRole, out var roleQuestions))
            return false;

        foreach (var question in currentSection.Questions.Where(q => q.IsRequired))
        {
            if (!roleQuestions.TryGetValue(question.Id, out var questionResponse))
                return false;

            if (!IsQuestionAnswered(question, questionResponse))
                return false;
        }

        return true;
    }

    private bool IsQuestionAnswered(QuestionItem question, QuestionResponse questionResponse)
    {
        return question.Type switch
        {
            QuestionType.Assessment => IsAssessmentCompleted(question, questionResponse),
            QuestionType.TextQuestion => IsTextQuestionCompleted(question, questionResponse),
            QuestionType.Goal => true, // Goal questions never block submission (see comment below)
            _ => true
        };
    }

    // Note: Goal questions are designed to never block submission because:
    // 1. Empty goal sections are acceptable for submission
    // 2. Pending operations (PENDING ADD, PENDING EDIT, etc.) are stored in component local state,
    //    not in questionResponse data accessible here
    // 3. Goals can be added/modified during review phases after submission
    // 4. Users should not be prevented from progressing due to goal workflow states

    private bool IsTextQuestionCompleted(QuestionItem question, QuestionResponse questionResponse)
    {
        var textSections = ConfigService.GetTextSections(question);
        if (textSections.Count == 0) return true;

        if (questionResponse.ComplexValue == null) return false;

        // Match the key format used by OptimizedTextQuestion
        if (textSections.Count == 1)
        {
            // Single section uses "value" key
            var hasValue = questionResponse.ComplexValue.TryGetValue("value", out var val) &&
                          !string.IsNullOrWhiteSpace(val?.ToString());
            return hasValue;
        }

        // Multiple sections use "section_0", "section_1", etc.
        // Get only required text sections
        var requiredTextSections = textSections.Where(ts => ts.IsRequired).ToList();

        // If no required text sections exist, check if at least one section has content
        if (!requiredTextSections.Any())
        {
            return textSections.Select((ts, index) => index).Any(index =>
            {
                var sectionKey = $"section_{index}";
                var hasValue = questionResponse.ComplexValue.TryGetValue(sectionKey, out var val) &&
                              !string.IsNullOrWhiteSpace(val?.ToString());
                return hasValue;
            });
        }

        // Check that ALL required text sections have non-empty values
        return requiredTextSections.All(ts =>
        {
            var index = textSections.IndexOf(ts);
            var sectionKey = $"section_{index}";
            var hasValue = questionResponse.ComplexValue.TryGetValue(sectionKey, out var val) &&
                          !string.IsNullOrWhiteSpace(val?.ToString());
            return hasValue;
        });
    }

    private bool IsAssessmentCompleted(QuestionItem question, QuestionResponse questionResponse)
    {
        var competencies = ConfigService.GetCompetencies(question);
        if (competencies.Count == 0) return true;

        if (questionResponse.ComplexValue == null) return false;

        // Get only required competencies
        var requiredCompetencies = competencies.Where(c => c.IsRequired).ToList();

        // If no required competencies exist, check if at least one competency is rated
        if (!requiredCompetencies.Any())
        {
            return competencies.Any(c => HasCompetencyRating(questionResponse, c.Key));
        }

        // Check that ALL required competencies have been rated
        return requiredCompetencies.All(c => HasCompetencyRating(questionResponse, c.Key));
    }

    private bool HasCompetencyRating(QuestionResponse questionResponse, string competencyKey)
    {
        if (questionResponse.ComplexValue?.TryGetValue($"rating_{competencyKey}", out var value) == true)
        {
            // Handle JsonElement from deserialization
            if (value is System.Text.Json.JsonElement jsonElement)
            {
                if (jsonElement.ValueKind == System.Text.Json.JsonValueKind.Number)
                {
                    return jsonElement.GetInt32() > 0;
                }
            }
            else if (value is int intValue)
            {
                return intValue > 0;
            }
        }
        return false;
    }

    private bool IsSectionCompleted(Guid sectionId)
    {
        if (!response.SectionResponses.TryGetValue(sectionId, out var sectionResponse))
            return false;

        if (!sectionResponse.RoleResponses.TryGetValue(CurrentResponseRole, out var roleQuestions))
            return false;

        var section = template!.Sections.First(s => s.Id == sectionId);

        return section.Questions.Where(q => q.IsRequired).All(q =>
            roleQuestions.TryGetValue(q.Id, out var qr) &&
            IsQuestionAnswered(q, qr));
    }

    private void UpdateProgress()
    {
        if (template == null) return;

        var totalQuestions = template.Sections.SelectMany(s => s.Questions.Where(q => q.IsRequired)).Count();
        var answeredQuestions = 0;

        foreach (var section in template.Sections)
        {
            if (response.SectionResponses.TryGetValue(section.Id, out var sectionResponse) &&
                sectionResponse.RoleResponses.TryGetValue(CurrentResponseRole, out var roleQuestions))
            {
                answeredQuestions += section.Questions.Where(q => q.IsRequired).Count(q =>
                    roleQuestions.TryGetValue(q.Id, out var qr) &&
                    IsQuestionAnswered(q, qr));
            }
        }

        response.ProgressPercentage = totalQuestions > 0 ? (int)(answeredQuestions * 100.0 / totalQuestions) : 0;
    }

    private bool CanSubmit()
    {
        // If no visible sections, allow submission
        if (!visibleSections.Any()) return true;

        // Check only visible sections for current user role
        // A section is considered complete if it has no required questions OR all required questions are answered
        return visibleSections.All(s =>
        {
            var section = template!.Sections.FirstOrDefault(sec => sec.Id == s.Id);
            if (section == null) return true;

            var requiredQuestions = section.Questions.Where(q => q.IsRequired).ToList();

            // If no required questions, section is complete
            if (!requiredQuestions.Any()) return true;

            // Check if all required questions are answered
            if (!response.SectionResponses.TryGetValue(s.Id, out var sectionResponse))
                return false;

            if (!sectionResponse.RoleResponses.TryGetValue(CurrentResponseRole, out var roleQuestions))
                return false;

            return requiredQuestions.All(q =>
                roleQuestions.TryGetValue(q.Id, out var qr) &&
                IsQuestionAnswered(q, qr));
        });
    }

    private async Task SaveProgress()
    {
        if (!assignmentId.HasValue)
        {
            NotificationService.Notify(NotificationSeverity.Warning, "Cannot Save", "No assignment ID available");
            return;
        }

        // Prevent saving if questionnaire is in read-only state (uses WorkflowState logic)
        if (IsQuestionnaireCompleted())
        {
            NotificationService.Notify(NotificationSeverity.Warning, "Cannot Save", "This questionnaire is in read-only state and cannot be modified");
            return;
        }

        if (isSaving)
        {
            return; // Prevent double save
        }

        try
        {
            isSaving = true;
            StateHasChanged(); // Update UI to show saving state

            // Save any pending goal changes BEFORE saving question responses
            var goalsSaved = await SaveAllPendingGoalChanges();
            if (!goalsSaved)
            {
                NotificationService.Notify(NotificationSeverity.Warning, "Partial Save", "Some goal changes could not be saved. Other progress was saved successfully.");
            }

            if (isEmployee && !isManager)
            {
                // Employees save responses and complete any finished sections
                await CompleteSectionsAsEmployee(); // Complete sections first to update workflow state
                await EmployeeQuestionnaireService.SaveMyResponseAsync(assignmentId.Value, response.SectionResponses);
            }
            else if (isManager)
            {
                // Managers save responses and complete any finished sections
                await CompleteSectionsAsManager(); // Complete sections first to update workflow state
                await ResponseService.SaveManagerResponseAsync(assignmentId.Value, response.SectionResponses);
            }

            // Reload assignment to get updated workflow state and section progress
            if (isManager)
            {
                assignment = await AssignmentService.GetAssignmentByIdAsync(assignmentId.Value);
            }
            else
            {
                assignment = await EmployeeQuestionnaireService.GetMyAssignmentByIdAsync(assignmentId.Value);
            }
            StateHasChanged(); // Force UI update with new workflow state

            NotificationService.Notify(NotificationSeverity.Success, "Saved", "Your progress has been saved successfully");
        }
        catch (Exception ex)
        {
            NotificationService.Notify(NotificationSeverity.Error, "Save Failed", $"Failed to save progress: {ex.Message}");
        }
        finally
        {
            isSaving = false;
            StateHasChanged(); // Reset UI state
        }
    }

    private async Task ShowReview()
    {
        if (!CanSubmit())
        {
            var incompleteSections = visibleSections.Where(s =>
            {
                var section = template!.Sections.FirstOrDefault(sec => sec.Id == s.Id);
                if (section == null) return false;

                var requiredQuestions = section.Questions.Where(q => q.IsRequired).ToList();
                if (!requiredQuestions.Any()) return false;

                if (!response.SectionResponses.TryGetValue(s.Id, out var sectionResponse))
                    return true;

                if (!sectionResponse.RoleResponses.TryGetValue(CurrentResponseRole, out var roleQuestions))
                    return true;

                return !requiredQuestions.All(q =>
                    roleQuestions.TryGetValue(q.Id, out var qr) &&
                    IsQuestionAnswered(q, qr));
            }).Select(s => s.Title).ToList();

            var message = incompleteSections.Any()
                ? $"Please complete all required questions in: {string.Join(", ", incompleteSections)}"
                : "Please complete all required questions before reviewing";

            NotificationService.Notify(NotificationSeverity.Warning, "Incomplete", message);
            return;
        }

        // Show a confirmation dialog with review summary
        var confirmed = await DialogService.Confirm(
            $"You are about to submit your responses for '{template?.Name}'. Please review your answers before submitting. Do you want to continue?",
            "Submit",
            new ConfirmOptions
            {
                OkButtonText = "Submit",
                CancelButtonText = "Cancel",
                AutoFocusFirstElement = true
            });

        if (confirmed == true)
        {
            await SubmitQuestionnaire();
        }
    }

    private async Task SubmitQuestionnaire()
    {
        if (!CanSubmit())
        {
            NotificationService.Notify(NotificationSeverity.Warning, "Incomplete", "Please complete all required sections.");
            return;
        }

        if (!assignmentId.HasValue)
        {
            NotificationService.Notify(NotificationSeverity.Warning, "Cannot Submit", "No assignment ID available");
            return;
        }

        if (isSubmitting)
        {
            return; // Prevent double submission
        }

        try
        {
            isSubmitting = true;
            StateHasChanged();

            // Save any pending goal changes BEFORE saving question responses
            var goalsSaved = await SaveAllPendingGoalChanges();
            if (!goalsSaved)
            {
                NotificationService.Notify(NotificationSeverity.Error, "Cannot Submit", "Please ensure all goal changes are saved before submitting.");
                return;
            }

            if (isManager)
            {
                // Manager flow - complete sections, save and submit
                await CompleteSectionsAsManager();
                await ResponseService.SaveManagerResponseAsync(assignmentId.Value, response.SectionResponses);
                var submitSuccess = await AssignmentService.SubmitManagerQuestionnaireAsync(assignmentId.Value, currentUserName);

                if (submitSuccess)
                {
                    // Reload the assignment to get the updated WorkflowState
                    assignment = await AssignmentService.GetAssignmentByIdAsync(assignmentId.Value);
                    StateHasChanged(); // Force UI update with new workflow state

                    NotificationService.Notify(NotificationSeverity.Success, "Submitted", "Questionnaire submitted successfully!");
                    NavigationManager.NavigateTo("/team/questionnaires");
                }
                else
                {
                    NotificationService.Notify(NotificationSeverity.Error, "Submission Failed", "Failed to submit questionnaire");
                }
            }
            else
            {
                // Employee flow - complete sections, save and submit
                await CompleteSectionsAsEmployee();
                await EmployeeQuestionnaireService.SaveMyResponseAsync(assignmentId.Value, response.SectionResponses);
                var submittedResponse = await EmployeeQuestionnaireService.SubmitMyResponseAsync(assignmentId.Value);

                if (submittedResponse != null)
                {
                    response = submittedResponse;

                    // Reload the assignment to get the updated WorkflowState
                    assignment = await EmployeeQuestionnaireService.GetMyAssignmentByIdAsync(assignmentId.Value);
                    StateHasChanged(); // Force UI update with new workflow state

                    NotificationService.Notify(NotificationSeverity.Success, "Submitted", "Questionnaire submitted successfully!");
                    NavigationManager.NavigateTo("/my-questionnaires");
                }
                else
                {
                    NotificationService.Notify(NotificationSeverity.Error, "Submission Failed", "Failed to submit questionnaire");
                }
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(NotificationSeverity.Error, "Submission Failed", $"Failed to submit questionnaire: {ex.Message}");
        }
        finally
        {
            isSubmitting = false;
            StateHasChanged();
        }
    }

    private async Task CompleteSectionsAsEmployee()
    {
        if (!assignmentId.HasValue) return;

        // Collect all completed section IDs
        var completedSectionIds = visibleSections
            .Where(s => IsSectionCompleted(s.Id))
            .Select(s => s.Id)
            .ToList();

        if (!completedSectionIds.Any())
            return;

        try
        {
            // Single atomic bulk operation - fixes concurrency issue
            await AssignmentService.CompleteBulkSectionsAsEmployeeAsync(assignmentId.Value, completedSectionIds);
        }
        catch (Exception ex)
        {
            NotificationService.Notify(NotificationSeverity.Warning, "Section Completion",
                $"Could not complete sections: {ex.Message}");
        }
    }

    private async Task CompleteSectionsAsManager()
    {
        if (!assignmentId.HasValue) return;

        // Collect all completed section IDs
        var completedSectionIds = visibleSections
            .Where(s => IsSectionCompleted(s.Id))
            .Select(s => s.Id)
            .ToList();

        if (!completedSectionIds.Any())
            return;

        try
        {
            // Single atomic bulk operation - fixes concurrency issue
            await AssignmentService.CompleteBulkSectionsAsManagerAsync(assignmentId.Value, completedSectionIds);
        }
        catch (Exception ex)
        {
            NotificationService.Notify(NotificationSeverity.Warning, "Section Completion",
                $"Could not complete sections: {ex.Message}");
        }
    }

    private async Task OnWorkflowActionCompleted()
    {
        // Reload the assignment to get updated workflow state
        if (assignmentId.HasValue)
        {
            try
            {
                if (isManager)
                {
                    assignment = await AssignmentService.GetAssignmentByIdAsync(assignmentId.Value);
                }
                else
                {
                    assignment = await EmployeeQuestionnaireService.GetMyAssignmentByIdAsync(assignmentId.Value);
                }

                StateHasChanged();
            }
            catch (Exception ex)
            {
                NotificationService.Notify(NotificationSeverity.Error, "Reload Error",
                    $"Failed to reload assignment: {ex.Message}");
            }
        }
    }

    private async Task OnReviewFinished()
    {
        // This callback is invoked by QuestionnaireReviewMode after successfully finishing the review
        // The API call has already been made by QuestionnaireReviewMode, so we just handle the navigation here
        if (!assignmentId.HasValue)
        {
            NotificationService.Notify(NotificationSeverity.Error, "Error", "No assignment ID available");
            return;
        }

        try
        {
            // Reload assignment to get updated workflow state
            await OnWorkflowActionCompleted();

            // Navigate back to team questionnaires
            NavigationManager.NavigateTo("/team/questionnaires");
        }
        catch (Exception ex)
        {
            NotificationService.Notify(NotificationSeverity.Error, "Error", $"Failed to reload assignment: {ex.Message}");
        }
    }

    // Competency-specific helper methods
    private int GetCompetencyRating(Guid questionId, string competencyKey)
    {
        var response = GetQuestionResponse(questionId);
        if (response.ComplexValue?.TryGetValue($"rating_{competencyKey}", out var value) == true)
        {
            // Handle JsonElement from deserialization
            if (value is System.Text.Json.JsonElement jsonElement)
            {
                if (jsonElement.ValueKind == System.Text.Json.JsonValueKind.Number)
                {
                    return jsonElement.GetInt32();
                }
            }
            else if (value is int intValue)
            {
                return intValue;
            }
            else
            {
                return Convert.ToInt32(value);
            }
        }
        return 0;
    }

    private string GetCompetencyComment(Guid questionId, string competencyKey)
    {
        var response = GetQuestionResponse(questionId);
        if (response.ComplexValue?.TryGetValue($"comment_{competencyKey}", out var value) == true)
        {
            return value.ToString() ?? "";
        }
        return "";
    }

    private void SetCompetencyRating(Guid questionId, string competencyKey, int value)
    {
        var response = GetQuestionResponse(questionId);
        if (response.ComplexValue == null) response.ComplexValue = new Dictionary<string, object>();
        response.ComplexValue[$"rating_{competencyKey}"] = value;
        response.LastModified = DateTime.Now;
        UpdateProgress();
    }

    private void SetCompetencyComment(Guid questionId, string competencyKey, string value)
    {
        var response = GetQuestionResponse(questionId);
        if (response.ComplexValue == null) response.ComplexValue = new Dictionary<string, object>();
        response.ComplexValue[$"comment_{competencyKey}"] = value ?? "";
        response.LastModified = DateTime.Now;
        UpdateProgress();
    }

    // Text Question helper methods
    private string GetTextQuestionSectionTitle(QuestionItem question)
    {
        if (question.Configuration.ContainsKey("SectionTitle"))
        {
            return question.Configuration["SectionTitle"].ToString() ?? "Career Ambitions";
        }
        return "Career Ambitions";
    }

    private string GetTextQuestionSectionDescription(QuestionItem question)
    {
        if (question.Configuration.ContainsKey("SectionDescription"))
        {
            return question.Configuration["SectionDescription"].ToString() ?? "Where do you see yourself long-term in your professional career?";
        }
        return "Where do you see yourself long-term in your professional career?";
    }

    // Helper methods for unified styling
    private string GetRoleBadgeClass(CompletionRole role)
    {
        return role switch
        {
            CompletionRole.Employee => "role-employee",
            CompletionRole.Manager => "role-manager",
            CompletionRole.Both => "role-both",
            _ => ""
        };
    }

    private string GetRoleIconForSection(CompletionRole role)
    {
        return role switch
        {
            CompletionRole.Employee => "person",
            CompletionRole.Manager => "supervisor_account",
            CompletionRole.Both => "groups",
            _ => "help"
        };
    }
}