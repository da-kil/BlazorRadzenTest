@page "/my-questionnaires/{TemplateId:guid}"
@page "/questionnaire/{AssignmentId:guid}"
@attribute [Microsoft.AspNetCore.Authorization.Authorize]
@using Radzen
@using Radzen.Blazor
@using ti8m.BeachBreak.Client.Components
@using ti8m.BeachBreak.Client.Components.Questions
@using ti8m.BeachBreak.Client.Models
@using ti8m.BeachBreak.Client.Models.DTOs
@using ti8m.BeachBreak.Client.Services
@using ti8m.BeachBreak.Client.Components.Shared
@using ti8m.BeachBreak.Client.Components.Dialogs
@using ti8m.BeachBreak.Client.Layout
@using Microsoft.AspNetCore.Components.Authorization
@using ti8m.BeachBreak.Client.Extensions
@inject DialogService DialogService
@inject NavigationManager NavigationManager
@inject IEmployeeQuestionnaireService EmployeeQuestionnaireService
@inject IQuestionnaireAssignmentService AssignmentService
@inject IQuestionnaireTemplateService TemplateService
@inject IQuestionnaireResponseService ResponseService
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject QuestionConfigurationService ConfigService
@inject GoalService GoalService
@inject IJSRuntime JSRuntime
@inject IAuthService AuthService
@inherits OptimizedTranslatableComponentBase


<PageTitle>@(template?.GetLocalizedNameWithFallback(CurrentLanguage) ?? "Questionnaire")</PageTitle>

@if (template == null)
{
    <div class="text-center p-5">
        <RadzenProgressBarCircular ProgressBarStyle="ProgressBarStyle.Primary" Value="100" ShowValue="false" Class="mb-3" />
        <RadzenText TextStyle="TextStyle.Body1" Class="text-muted">Loading questionnaire...</RadzenText>
    </div>
}
else if (assignment != null && assignment.WorkflowState == WorkflowState.InReview && isManager)
{
    <!-- Show Review Mode for managers during InReview state -->
    <QuestionnaireReviewMode Assignment="@assignment"
                             OnReviewFinished="@OnReviewFinished"
                             Template="@(template!)"
                             Response="@response"
                             UserRole="@userRole" />
}
else
{
    <PageLayout Title="@template.GetLocalizedNameWithFallback(CurrentLanguage)"
                        Description="@template.GetLocalizedDescriptionWithFallback(CurrentLanguage)"
                        ShowDefaultFooter="true">
        <DefaultFooterContent>
            <RadzenButton Text="@T("buttons.previous")"
                         ButtonStyle="ButtonStyle.Light"
                         Icon="arrow_back"
                         Click="@PreviousSection"
                         Disabled="@(currentSectionIndex == 0)" />

            <div class="navigation-actions d-flex gap-2">
                @if (!IsQuestionnaireCompleted())
                {
                    <RadzenButton Text="@(isSaving ? T("buttons.saving") : T("buttons.save-progress"))"
                                 ButtonStyle="ButtonStyle.Info"
                                 Icon="@(isSaving ? "hourglass_empty" : "save")"
                                 Click="@SaveProgress"
                                 Disabled="@isSaving" />

                    @if (currentSectionIndex == visibleSections.Count - 1)
                    {
                        <RadzenButton Text="@(isSubmitting ? T("buttons.submitting") : T("buttons.submit"))"
                                     ButtonStyle="ButtonStyle.Success"
                                     Icon="send"
                                     Click="@ShowReview"
                                     Disabled="@(!CanSubmit() || isSubmitting)" />
                    }
                    else
                    {
                        <RadzenButton Text="@T("buttons.next")"
                                     ButtonStyle="ButtonStyle.Primary"
                                     Icon="arrow_forward"
                                     Click="@NextSection"
                                     Disabled="@(!CanProceedFromCurrentSection())" />
                    }
                }
                else
                {
                    @* In read-only mode *@
                    @if (currentSectionIndex < visibleSections.Count - 1)
                    {
                        @* Show Next button for navigation if not on last sectionData *@
                        <RadzenButton Text="@T("buttons.next")"
                                     ButtonStyle="ButtonStyle.Primary"
                                     Icon="arrow_forward"
                                     Click="@NextSection" />
                    }
                }
            </div>
        </DefaultFooterContent>
        <ChildContent>

            @* Workflow Action Buttons - Sticky Banner *@
            @if (assignment != null && assignmentId.HasValue)
            {
                <WorkflowActionButtons Assignment="@assignment"
                                      IsEmployee="@isEmployeeOnly"
                                      IsManager="@isManager"
                                      UserName="@currentUserName"
                                      OnActionCompleted="@OnWorkflowActionCompleted" />
            }

            @if (IsQuestionnaireCompleted())
            {
                @if (isManager && template != null && !template.RequiresManagerReview)
                {
                    <RadzenAlert AlertStyle="AlertStyle.Info" Variant="Variant.Flat" Shade="Shade.Lighter" Class="workflow-alert mb-4" ShowIcon="true">
                        <RadzenText TextStyle="TextStyle.Body1">
                            <strong>@T("messages.viewing-employee-questionnaire-readonly")</strong>
                            <span> @T("messages.no-manager-input-required")</span>
                        </RadzenText>
                    </RadzenAlert>
                }
                else
                {
                    @* Show specific banner message based on workflow state *@
                    @if (assignment?.WorkflowState == WorkflowState.Finalized)
                    {
                        <RadzenAlert AlertStyle="AlertStyle.Success" Variant="Variant.Flat" Shade="Shade.Lighter" Class="workflow-alert mb-4" ShowIcon="true">
                            <RadzenText TextStyle="TextStyle.Body1">
                                <strong>@T("messages.questionnaire-finalized-locked")</strong>
                                <span> @T("messages.no-further-changes-allowed")</span>
                            </RadzenText>
                        </RadzenAlert>
                    }
                    else if (assignment?.WorkflowState == WorkflowState.ReviewFinished)
                    {
                        <RadzenAlert AlertStyle="AlertStyle.Info" Variant="Variant.Flat" Shade="Shade.Lighter" Class="workflow-alert mb-4" ShowIcon="true">
                            <RadzenText TextStyle="TextStyle.Body1">
                                @if (isManager)
                                {
                                    <strong>@T("messages.awaiting-employee-signoff")</strong>
                                    <span> @T("messages.review-meeting-completed-waiting-signoff")</span>
                                }
                                else
                                {
                                    <strong>@T("messages.review-meeting-completed")</strong>
                                    <span> @T("messages.review-meeting-finished-please-signoff")</span>
                                }
                            </RadzenText>
                        </RadzenAlert>
                    }
                    else if (assignment?.WorkflowState == WorkflowState.EmployeeReviewConfirmed)
                    {
                        <RadzenAlert AlertStyle="AlertStyle.Info" Variant="Variant.Flat" Shade="Shade.Lighter" Class="workflow-alert mb-4" ShowIcon="true">
                            <RadzenText TextStyle="TextStyle.Body1">
                                @if (isManager)
                                {
                                    <strong>@T("messages.ready-to-finalize")</strong>
                                    <span> @T("messages.employee-signed-off-can-finalize")</span>
                                }
                                else
                                {
                                    <strong>@T("messages.review-signed-off")</strong>
                                    <span> @T("messages.waiting-final-confirmation")</span>
                                }
                            </RadzenText>
                        </RadzenAlert>
                    }
                    else if (assignment?.WorkflowState == WorkflowState.InReview)
                    {
                        <RadzenAlert AlertStyle="AlertStyle.Warning" Variant="Variant.Flat" Shade="Shade.Lighter" Class="workflow-alert mb-4" ShowIcon="true">
                            <RadzenText TextStyle="TextStyle.Body1">
                                <strong>@T("messages.review-meeting-in-progress")</strong>
                                <span> @T("messages.questionnaire-in-review-readonly")</span>
                            </RadzenText>
                        </RadzenAlert>
                    }
                    else if (assignment?.WorkflowState == WorkflowState.EmployeeSubmitted ||
                             assignment?.WorkflowState == WorkflowState.ManagerSubmitted ||
                             assignment?.WorkflowState == WorkflowState.BothSubmitted)
                    {
                        <RadzenAlert AlertStyle="AlertStyle.Info" Variant="Variant.Flat" Shade="Shade.Lighter" Class="workflow-alert mb-4" ShowIcon="true">
                            <RadzenText TextStyle="TextStyle.Body1">
                                <strong>@T("messages.questionnaire-submitted")</strong>
                                <span> @T("messages.responses-submitted-readonly")</span>
                            </RadzenText>
                        </RadzenAlert>
                    }
                    else
                    {
                        <RadzenAlert AlertStyle="AlertStyle.Success" Variant="Variant.Flat" Shade="Shade.Lighter" Class="workflow-alert mb-4" ShowIcon="true">
                            <RadzenText TextStyle="TextStyle.Body1">
                                <strong>@T("messages.questionnaire-readonly")</strong>
                                <span> @T("messages.review-responses-no-changes")</span>
                            </RadzenText>
                        </RadzenAlert>
                    }
                }
            }

            @* Show review changes summary after review meeting finishes *@
            @if (assignment != null && assignmentId.HasValue && response != null &&
                 template != null && template.RequiresManagerReview &&
                 (assignment.WorkflowState == WorkflowState.ReviewFinished ||
                  assignment.WorkflowState == WorkflowState.EmployeeReviewConfirmed ||
                  assignment.WorkflowState == WorkflowState.Finalized))
            {
                <ReviewChangesSummary Response="@response" AssignmentId="@assignmentId.Value" />
            }

            <div class="section-counter mb-4 mt-3">
                <RadzenText TextStyle="TextStyle.Body2" Class="text-muted text-end">
                    @T("sections.section-counter") @(currentSectionIndex + 1) of @visibleSections.Count
                </RadzenText>
            </div>

            <section class="questionnaire-content">
                @if (currentSection != null)
                {
                    <header class="section-header-questionnaire">
                        <div class="section-title-container">
                            <h2 class="section-title">@currentSection.GetLocalizedTitleWithFallback(CurrentLanguage)</h2>
                            @{
                                var sectionDescription = currentSection.GetLocalizedDescriptionWithFallback(CurrentLanguage);
                            }
                            @if (!string.IsNullOrWhiteSpace(sectionDescription))
                            {
                                <p class="section-description">@sectionDescription</p>
                            }
                        </div>
                    </header>

                    <div class="questions-container">
                        @RenderSectionWithRef(currentSection)
                    </div>
                }
            </section>


            @* Review Comments Display - Below Questionnaire *@
            @* Show after review meeting finishes so employee can see manager's summary before signing off *@
            @if (assignment != null && template != null && template.RequiresManagerReview &&
                 (assignment.WorkflowState == WorkflowState.ReviewFinished ||
                  assignment.WorkflowState == WorkflowState.EmployeeReviewConfirmed ||
                  assignment.WorkflowState == WorkflowState.Finalized))
            {
                <ReviewComments Assignment="@assignment"
                               IsEmployee="@isEmployeeOnly"
                               IsManager="@isManager" />
            }
        </ChildContent>
    </PageLayout>
}

@code {
    [Parameter] public Guid? TemplateId { get; set; }
    [Parameter] public Guid? AssignmentId { get; set; }

    private Guid? assignmentId;
    private QuestionnaireAssignment? assignment;
    private QuestionnaireTemplate? template;
    private QuestionnaireResponse response = new();
    private int currentSectionIndex = 0;

    // Store references to question renderers for calling SavePendingGoalChanges
    private Dictionary<Guid, OptimizedQuestionRenderer> questionRenderers = new();

    /// <summary>
    /// The user's organizational role determining data access permissions.
    /// Maps to ApplicationRole enum: Employee, TeamLead, HR, HRLead, Admin.
    /// </summary>
    private ApplicationRole userRole = ApplicationRole.Employee;

    /// <summary>
    /// Whether user has manager-level privileges (TeamLead or higher).
    /// Determines endpoint access and UI features.
    /// </summary>
    private bool HasManagerPrivileges => userRole is ApplicationRole.TeamLead
        or ApplicationRole.HR
        or ApplicationRole.HRLead
        or ApplicationRole.Admin;

    /// <summary>
    /// Whether user can act as an employee (complete employee sections, view own responses).
    /// TRUE for all users - everyone has employee-level access.
    /// Note: Used for explicit checks (e.g., "isEmployee && !isManager") and component parameters.
    /// In simple if/else branches, prefer "else" over "else if (isEmployee)" since it's always true.
    /// </summary>
    private bool isEmployee => true;

    /// <summary>
    /// Whether user is specifically an Employee (not a manager) for employee-only workflow actions.
    /// TRUE only for Employee role, FALSE for all manager roles (TeamLead, HR, HRLead, Admin).
    /// This is used exclusively for workflow actions like employee sign-off that should not be available to managers.
    /// </summary>
    private bool isEmployeeOnly => !HasManagerPrivileges;

    /// <summary>
    /// Whether user can act as a manager (complete manager sections, view team responses).
    /// TRUE for TeamLead, HR, HRLead, Admin.
    /// This is used to determine which API endpoints to call and which UI features to show.
    /// </summary>
    private bool isManager => HasManagerPrivileges;

    /// <summary>
    /// The response role for accessing RoleResponses dictionary.
    /// Determines which response set (Employee or Manager) the user is currently viewing/editing.
    /// This is separate from organizational role (ApplicationRole) and sectionData assignment (CompletionRole).
    /// </summary>
    private ResponseRole CurrentResponseRole => userRole.ToResponseRole();

    /// <summary>
    /// String accessor for components that need actual ApplicationRole strings.
    /// Goal filtering requires specific ApplicationRole strings (TeamLead, HR, etc.), not simplified ResponseRole strings.
    /// </summary>
    private string currentUserRole => userRole.ToString();

    private string currentUserName = string.Empty;
    private string managerContextRole = string.Empty;
    private List<QuestionSection> customSections = new();
    private List<QuestionSection> visibleSections = new();
    private QuestionSection? currentSection => visibleSections.ElementAtOrDefault(currentSectionIndex);
    private SectionResponse? currentSectionData => currentSection != null && response.SectionResponses.TryGetValue(currentSection.Id, out var sectionData) ? sectionData : null;
    private bool isSubmitting = false;
    private bool isProcessing = false;
    private bool isSaving = false;

    private bool IsQuestionnaireCompleted()
    {
        // Read-only state is determined ONLY by the assignment's WorkflowState
        // The response.Status is for domain-level validation, not UI read-only logic
        if (assignment == null)
            return false;

        // Phase 2 Read-Only (Permanent): After finalization
        var isPhase2ReadOnly = assignment.WorkflowState == WorkflowState.Finalized;

        // After review confirmation states (waiting for finalization)
        var isPostReviewConfirmation = assignment.WorkflowState is WorkflowState.EmployeeReviewConfirmed or WorkflowState.ReviewFinished;

        // Managers/HR viewing employee-only questionnaires should always see read-only
        if (isManager && template != null && !template.RequiresManagerReview)
        {
            return true;
        }

        // Determine read-only based on user role and workflow state
        if (isEmployee && !isManager)
        {
            // Employee can edit: Assigned, EmployeeInProgress, BothInProgress, ManagerSubmitted
            // Employee is READ-ONLY during: InReview (manager-led review meeting)
            // Employee CANNOT edit after: EmployeeSubmitted, BothSubmitted, Post-review, Finalized
            // Note: Employee CAN still edit when ManagerSubmitted (manager submitted but employee hasn't)
            return assignment.WorkflowState is WorkflowState.EmployeeSubmitted or WorkflowState.BothSubmitted or WorkflowState.InReview
                || isPostReviewConfirmation
                || isPhase2ReadOnly;
        }
        else if (isManager)
        {
            // Manager can edit: Assigned, ManagerInProgress, BothInProgress, InReview
            // Manager CANNOT edit ONLY when: ManagerSubmitted, BothSubmitted, Post-review, Finalized
            // Note: Manager CAN still see EmployeeSubmitted state (employee submitted but manager hasn't)
            return assignment.WorkflowState is WorkflowState.ManagerSubmitted or WorkflowState.BothSubmitted
                || isPostReviewConfirmation
                || isPhase2ReadOnly;
        }

        return isPhase2ReadOnly; // Default: only finalized is truly read-only
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        await DetermineUserRole();
        await LoadAssignmentAndTemplate();

        // Redirect managers to initialization page if assignment is in Assigned state
        if (assignment != null && assignment.WorkflowState == WorkflowState.Assigned)
        {
            if (isManager)
            {
                NavigationManager.NavigateTo($"/assignments/{assignment.Id}/initialize", replace: true);
                return;
            }
            else
            {
                // Employees cannot access assignments in Assigned state
                NavigationManager.NavigateTo("/my-questionnaires", replace: true);
                return;
            }
        }

        await InitializeResponseAsync();
        await LoadExistingResponse();
        await FilterVisibleSections();
        UpdateProgress();
    }

    protected override bool HasStateChanged()
    {
        return HasParameterChanged(nameof(currentSectionIndex), currentSectionIndex) ||
               HasParameterChanged(nameof(response.ProgressPercentage), response.ProgressPercentage) ||
               HasParameterChanged(nameof(template), template) ||
               HasParameterChanged(nameof(isSaving), isSaving) ||
               HasParameterChanged(nameof(isSubmitting), isSubmitting);
    }

    private async Task DetermineUserRole()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        // Get user name for workflow actions
        currentUserName = user.Identity?.Name ?? "Unknown User";

        try
        {
            // WebAssembly client doesn't have ApplicationRole claims (those are added server-side only)
            // So we need to call the API to get the user's role from the database
            var roleData = await AuthService.GetMyRoleAsync();

            if (roleData == null)
            {
                // Default to Employee for safety
                userRole = ApplicationRole.Employee;
                return;
            }

            // Store the actual ApplicationRole - computed properties derive behavior from it
            userRole = roleData.ApplicationRole;

            // Cache role for Manager's Answer sections filtering
            var userRoleString = userRole.ToString();
            managerContextRole = IsManagerRole(userRoleString) ? userRoleString : "TeamLead";
        }
        catch (Exception ex)
        {
            // Default to Employee for safety
            userRole = ApplicationRole.Employee;
            managerContextRole = "TeamLead"; // Fallback for filtering
        }
    }

    private async Task LoadAssignmentAndTemplate()
    {
        try
        {
            // Determine which parameter was provided
            if (AssignmentId.HasValue)
            {
                // New route: /questionnaire/{assignmentId}
                assignmentId = AssignmentId.Value;

                // Load assignment using appropriate service based on user privileges
                // IMPORTANT: Check manager privileges FIRST because TeamLeads/HR have broader data access
                // - Managers use the general assignment endpoint (can view team's assignments)
                // - Employees use the "me/assignments" endpoint (only their own assignments)
                // Note: A TeamLead IS an employee with additional privileges, not a separate role
                if (isManager)
                {
                    // Managers use the general assignment service
                    // Backend validates manager has this employee in their team
                    assignment = await AssignmentService.GetAssignmentByIdAsync(assignmentId.Value);
                }
                else
                {
                    // Regular employees use the "me/assignments/{id}" endpoint which validates ownership
                    assignment = await EmployeeQuestionnaireService.GetMyAssignmentByIdAsync(assignmentId.Value);
                }

                if (assignment == null)
                {
                    NotificationService.Notify(NotificationSeverity.Error, "Error", "Assignment not found");
                    NavigateBack();
                    return;
                }

                template = await TemplateService.GetTemplateByIdAsync(assignment.TemplateId);

                // Load custom sections for this assignment (if any)
                await LoadCustomSections();
            }
            else if (TemplateId.HasValue)
            {
                // Legacy route: /my-questionnaires/{templateId} (employee only)
                await LoadTemplate();
                await LoadAssignmentForCurrentEmployee();

                // Load custom sections after assignment is loaded
                if (assignmentId.HasValue)
                {
                    await LoadCustomSections();
                }
            }
            else
            {
                NotificationService.Notify(NotificationSeverity.Error, "Error", "No questionnaire specified");
                NavigateBack();
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(NotificationSeverity.Error, "Error", $"Failed to load questionnaire: {ex.Message}");
            NavigateBack();
        }
    }

    private async Task LoadCustomSections()
    {
        try
        {
            if (assignmentId.HasValue)
            {
                // Use employee-specific endpoint if user is employee-only, otherwise use manager endpoint
                if (isEmployeeOnly)
                {
                    customSections = await AssignmentService.GetMyCustomSectionsAsync(assignmentId.Value);
                }
                else
                {
                    customSections = await AssignmentService.GetCustomSectionsAsync(assignmentId.Value);
                }
            }
        }
        catch (Exception ex)
        {
            // Don't fail the whole page if custom sections can't be loaded
            // They might not exist yet (Assigned state before initialization)
            Console.WriteLine($"Could not load custom sections: {ex.Message}");
            customSections = new List<QuestionSection>();
        }
    }

    /// <summary>
    /// Gets all sections for this questionnaire: template sections + custom sections
    /// Custom sections are instance-specific and added during manager initialization
    /// </summary>
    private List<QuestionSection> GetAllSections()
    {
        if (template == null)
            return new List<QuestionSection>();

        var allSections = new List<QuestionSection>();

        // Add template sections
        allSections.AddRange(template.Sections);

        // Add custom sections (instance-specific)
        allSections.AddRange(customSections);

        // Sort by Order to maintain proper sequence
        return allSections.OrderBy(s => s.Order).ToList();
    }

    private async Task FilterVisibleSections()
    {
        if (template == null)
        {
            visibleSections = new List<QuestionSection>();
            return;
        }

        // Get all sections (template + custom)
        var allSections = GetAllSections();

        // After review meeting finishes, EVERYONE sees ALL sections (employee, manager, and both)
        // This ensures transparency - both parties can see what was discussed and agreed upon
        var isPostReviewState = assignment != null &&
            (assignment.WorkflowState is WorkflowState.ReviewFinished or
                                         WorkflowState.EmployeeReviewConfirmed or
                                         WorkflowState.Finalized);

        // Managers/HR can view employee-only questionnaires in read-only mode
        var isManagerViewingEmployeeOnlyQuestionnaire = isManager && !template.RequiresManagerReview;

        if (isPostReviewState || isManagerViewingEmployeeOnlyQuestionnaire)
        {
            // Show ALL sections in read-only view
            visibleSections = allSections.OrderBy(s => s.Order).ToList();
            return;
        }

        // Filter sections based on workflow state and user role
        // BUSINESS RULES:
        // - Employees: See Employee + Both sections (backend filters responses in Both sections to only Employee responses)
        // - Managers: See Manager + Both sections (backend filters responses in Both sections to only Manager responses)
        // - InReview state: Manager sees ALL sections, Employee sees Employee + Both sections
        // - ReviewFinished onwards: Everyone sees ALL sections (full transparency)
        visibleSections = allSections
            .Where(s =>
            {
                if (assignment == null)
                {
                    // No assignment context - use default role-based filtering
                    if (isManager && (s.CompletionRole == CompletionRole.Manager || s.CompletionRole == CompletionRole.Both))
                        return true;
                    if (isEmployee && (s.CompletionRole == CompletionRole.Employee || s.CompletionRole == CompletionRole.Both))
                        return true;
                    return false;
                }

                // From ReviewFinished onwards: Everyone sees ALL sections
                if (assignment.WorkflowState is WorkflowState.ReviewFinished or
                                                WorkflowState.EmployeeReviewConfirmed or
                                                WorkflowState.Finalized)
                {
                    return true;
                }

                // InReview state: Manager sees ALL, Employee sees Employee + Both
                if (assignment.WorkflowState == WorkflowState.InReview)
                {
                    if (isManager)
                        return true; // Manager sees ALL sections
                    else
                        return s.CompletionRole == CompletionRole.Employee || s.CompletionRole == CompletionRole.Both;
                }

                // In-Progress + Submitted states: Role-based filtering
                // Employees see: Employee + Both
                // Managers see: Manager + Both
                if (isManager)
                {
                    return s.CompletionRole == CompletionRole.Manager || s.CompletionRole == CompletionRole.Both;
                }
                else
                {
                    return s.CompletionRole == CompletionRole.Employee || s.CompletionRole == CompletionRole.Both;
                }
            })
            .OrderBy(s => s.Order)
            .ToList();

        // If no visible sections, show helpful error
        if (!visibleSections.Any() && allSections.Any())
        {
            var sectionDetails = string.Join(", ", allSections.Select(s => $"'{s.GetLocalizedTitleWithFallback(CurrentLanguage)}' (assigned to {s.CompletionRole})"));
            var roleDescription = isManager ? "managers" : "employees";
            NotificationService.Notify(NotificationSeverity.Warning, "No Sections Available",
                $"This questionnaire has no sections assigned to {roleDescription}. " +
                $"Please edit the template to assign sections appropriately. " +
                $"Current sections: {sectionDetails}");
        }
    }

    private void NavigateBack()
    {
        if (isManager)
            NavigationManager.NavigateTo("/team/questionnaires");
        else
            NavigationManager.NavigateTo("/my-questionnaires");
    }

    private async Task LoadTemplate()
    {
        if (!TemplateId.HasValue) return;

        try
        {
            template = await TemplateService.GetTemplateByIdAsync(TemplateId.Value);
            if (template == null)
            {
                NotificationService.Notify(NotificationSeverity.Error, "Error", "Questionnaire template not found");
                NavigationManager.NavigateTo("/my-questionnaires");
                return;
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(NotificationSeverity.Error, "Error", $"Failed to load questionnaire: {ex.Message}");
            NavigationManager.NavigateTo("/my-questionnaires");
            return;
        }

    }

    private async Task LoadAssignmentForCurrentEmployee()
    {
        try
        {
            // Load the current employee's assignment for this template
            var assignments = await EmployeeQuestionnaireService.GetMyAssignmentsAsync();
            var matchingAssignment = assignments.FirstOrDefault(a => a.TemplateId == TemplateId!.Value &&
                                                           a.WorkflowState != WorkflowState.Finalized);

            if (matchingAssignment != null)
            {
                assignmentId = matchingAssignment.Id;
                assignment = matchingAssignment;
            }
            else
            {
                NotificationService.Notify(NotificationSeverity.Warning, "Not Assigned", "This questionnaire has not been assigned to you.");
                NavigationManager.NavigateTo("/my-questionnaires");
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(NotificationSeverity.Error, "Error", $"Failed to load assignment: {ex.Message}");
            NavigationManager.NavigateTo("/my-questionnaires");
        }
    }

    private async Task LoadExistingResponse()
    {
        if (!assignmentId.HasValue) return;

        try
        {
            QuestionnaireResponse? existingResponse = null;

            // After submission and review phases, everyone loads ALL role responses for full transparency
            var isPostReviewState = assignment != null &&
                (assignment.WorkflowState is WorkflowState.BothSubmitted or
                                             WorkflowState.InReview or
                                             WorkflowState.ReviewFinished or
                                             WorkflowState.EmployeeReviewConfirmed or
                                             WorkflowState.Finalized);

            if (isPostReviewState || isManager)
            {
                // Post-review or managers: load ALL role responses (Employee + Manager + Both)
                existingResponse = await ResponseService.GetResponseByAssignmentIdAsync(assignmentId.Value);
            }
            else
            {
                // Regular employees during questionnaire: load only their own responses
                existingResponse = await EmployeeQuestionnaireService.GetMyResponseAsync(assignmentId.Value);
            }

            if (existingResponse == null || !existingResponse.SectionResponses.Any())
            {
                return;
            }

            // Merge existing responses with initialized structure
            foreach (var sectionKvp in existingResponse.SectionResponses)
            {
                if (response.SectionResponses.TryGetValue(sectionKvp.Key, out var sectionResponse))
                {
                    // After review meeting: load ALL role responses for full transparency
                    // Managers viewing employee-only questionnaires: load ALL responses
                    // Managers during InReview state: load ALL responses for active review
                    // Normal mode: only load current user's role responses
                    var isManagerViewingEmployeeOnlyQuestionnaire = isManager && template != null && !template.RequiresManagerReview;
                    var isManagerDuringReview = isManager && assignment != null && assignment.WorkflowState == WorkflowState.InReview;

                    if ((isPostReviewState || isManagerViewingEmployeeOnlyQuestionnaire || isManagerDuringReview) && sectionKvp.Value.RoleResponses != null)
                    {
                        // Load ALL role responses (Employee, Manager) - 2-level structure
                        foreach (var roleKvp in sectionKvp.Value.RoleResponses)
                        {
                            var role = roleKvp.Key;
                            var roleResponse = roleKvp.Value; // Direct QuestionResponse, not dictionary

                            // Assign role response directly (sectionData IS the question)
                            sectionResponse.RoleResponses[role] = roleResponse;
                        }
                    }
                    else if (sectionKvp.Value.RoleResponses != null && sectionKvp.Value.RoleResponses.TryGetValue(CurrentResponseRole, out var roleResponse))
                    {
                        // Normal mode: only load current user's role response
                        // Direct assignment
                        sectionResponse.RoleResponses[CurrentResponseRole] = roleResponse;
                    }
                    sectionResponse.IsCompleted = sectionKvp.Value.IsCompleted;
                }
            }

            // Find current sectionData based on progress
            var completedSections = response.SectionResponses.Count(sr => sr.Value.IsCompleted);
            currentSectionIndex = Math.Min(completedSections, Math.Max(0, visibleSections.Count - 1));
        }
        catch (Exception ex)
        {
            // Could not load existing response - continue with new response
        }
    }

    private async Task InitializeResponseAsync()
    {
        if (template == null) return;

        // Get current user's EmployeeGuid from claims
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var employeeGuid = authState.User.FindFirst("EmployeeGuid")?.Value ?? string.Empty;

        response = new QuestionnaireResponse
        {
            TemplateId = TemplateId ?? template?.Id ?? Guid.Empty,
            AssignmentId = assignmentId ?? Guid.Empty,
            EmployeeId = employeeGuid
        };

        // Initialize sectionData responses with role-based structure (template + custom sections)
        var allSections = GetAllSections();
        foreach (var sectionData in allSections)
        {
            var sectionResponse = new SectionResponse
            {
                SectionId = sectionData.Id,
                RoleResponses = new Dictionary<ResponseRole, QuestionResponse>()
            };

            // Initialize sectionData response for current user's role
            sectionResponse.RoleResponses[CurrentResponseRole] = new QuestionResponse
            {
                QuestionId = sectionData.Id,  // sectionData ID is the question ID
                QuestionType = sectionData.Type
            };

            response.SectionResponses[sectionData.Id] = sectionResponse;
        }
    }

    private RenderFragment RenderSectionWithRef(QuestionSection sectionData)
    {
        // Check if we're in post-review state and sectionData is "Both"
        var isPostReviewState = assignment != null &&
            (assignment.WorkflowState is WorkflowState.ReviewFinished or
                                         WorkflowState.EmployeeReviewConfirmed or
                                         WorkflowState.Finalized);

        var isInReview = assignment != null && assignment.WorkflowState == WorkflowState.InReview;
        var isBothSection = sectionData?.CompletionRole == CompletionRole.Both;

        // For goal sections in "Both" sections, ALWAYS use collaborative grouped view (never comparison)
        // The comparison view only makes sense for predecessor goal ratings, not new goals
        if (isBothSection && sectionData?.Type == QuestionType.Goal)
        {
            // Check if goal section should be visible based on configuration
            if (!ShouldShowGoalSection(sectionData))
            {
                return @<div></div>; // Return empty div if goal section is hidden
            }

            // Use the collaborative component that groups by roles instead of comparison view
            var goalSectionResponse = GetQuestionResponse(sectionData.Id);

            return @<OptimizedQuestionRenderer
                @ref="questionRenderers[sectionData.Id]"
                Section="@sectionData"
                Response="@goalSectionResponse"
                OnResponseChanged="@HandleQuestionResponseChangedDynamic"
                IsReadOnly="@IsQuestionnaireCompleted()"
                AssignmentId="@(assignmentId ?? Guid.Empty)"
                CurrentUserRole="@userRole"
                AssignmentWorkflowState="@(assignment?.WorkflowState ?? WorkflowState.InReview)"
                SectionData="@currentSectionData" />;
        }

        // In post-review state for "Both" sections, show BOTH employee and manager responses (comparison view)
        // Exclude goal sections as they use collaborative view instead
        if (isPostReviewState && isBothSection && sectionData?.Type != QuestionType.Goal)
        {
            var employeeResponse = GetQuestionResponseForRole(sectionData.Id, "Employee");
            var managerResponse = GetQuestionResponseForRole(sectionData.Id, "Manager");

            return @<div class="question-comparison-card">
                <!-- Side-by-side view within the section card -->
                <div class="side-by-side-view">
                    <!-- Employee Answer -->
                    <div class="answer-column employee">
                        <div class="answer-header">
                            <span class="answer-label">
                                <RadzenIcon Icon="person" Style="font-size: 1rem;" />
                                <RadzenText TextStyle="TextStyle.Subtitle2" Class="fw-medium ms-1">
                                    @T("labels.employee-answer")
                                </RadzenText>
                            </span>
                        </div>
                        <div class="answer-content">
                            <OptimizedQuestionRenderer
                                Section="@sectionData"
                                Response="@employeeResponse"
                                OnResponseChanged="@HandleQuestionResponseChangedDynamic"
                                IsReadOnly="true"
                                HideHeader="true"
                                AssignmentId="@(assignmentId ?? Guid.Empty)"
                                CurrentUserRole="ApplicationRole.Employee"
                                AssignmentWorkflowState="@(assignment?.WorkflowState ?? WorkflowState.EmployeeInProgress)"
                                SectionData="@currentSectionData" />
                        </div>
                    </div>

                    <!-- Manager Answer -->
                    <div class="answer-column manager">
                        <div class="answer-header">
                            <span class="answer-label">
                                <RadzenIcon Icon="manage_accounts" Style="font-size: 1rem;" />
                                <RadzenText TextStyle="TextStyle.Subtitle2" Class="fw-medium ms-1">
                                    @T("labels.manager-answer")
                                </RadzenText>
                            </span>
                        </div>
                        <div class="answer-content">
                            <OptimizedQuestionRenderer
                                Section="@sectionData"
                                Response="@managerResponse"
                                OnResponseChanged="@HandleQuestionResponseChangedDynamic"
                                IsReadOnly="true"
                                HideHeader="true"
                                AssignmentId="@(assignmentId ?? Guid.Empty)"
                                CurrentUserRole="@ParseApplicationRole(managerContextRole)"
                                AssignmentWorkflowState="@(assignment?.WorkflowState ?? WorkflowState.ManagerInProgress)"
                                SectionData="@currentSectionData" />
                        </div>
                    </div>
                </div>
            </div>;
        }

        // Normal rendering for non-Both sections or during active questionnaire
        var sectionResponse = GetQuestionResponse(sectionData.Id);

        // Store reference for goal sections so we can call SavePendingGoalChanges later
        return @<OptimizedQuestionRenderer
            @ref="questionRenderers[sectionData.Id]"
            Section="@sectionData"
            Response="@sectionResponse"
            OnResponseChanged="@HandleQuestionResponseChangedDynamic"
            IsReadOnly="@IsQuestionnaireCompleted()"
            AssignmentId="@(assignmentId ?? Guid.Empty)"
            CurrentUserRole="@userRole"
            AssignmentWorkflowState="@(assignment?.WorkflowState ?? WorkflowState.EmployeeInProgress)"
            SectionData="@currentSectionData" />;
    }

    /// <summary>
    /// Saves all pending goal changes across all question renderers.
    /// Returns true if all operations succeed.
    /// </summary>
    private async Task<bool> SaveAllPendingGoalChanges()
    {
        if (!questionRenderers.Any())
            return true;

        bool allSucceeded = true;
        foreach (var renderer in questionRenderers.Values)
        {
            if (renderer != null)
            {
                var success = await renderer.SavePendingGoalChanges();
                if (!success)
                {
                    allSucceeded = false;
                }
            }
        }

        return allSucceeded;
    }

    private async Task HandleQuestionResponseChangedDynamic(QuestionResponse updatedResponse)
    {
        // Response object is already updated by reference
        // Trigger validation and progress update
        UpdateProgress();
        await InvokeAsync(StateHasChanged);
    }

    // Helper methods for sectionData responses
    private QuestionResponse GetQuestionResponseForRole(Guid sectionId, string roleName)
    {
        if (!response.SectionResponses.TryGetValue(sectionId, out var sectionResponse))
            return new QuestionResponse { QuestionId = sectionId };

        var role = ResponseRoleExtensions.ParseRoleKey(roleName);

        // Direct 2-level access
        if (sectionResponse.RoleResponses.TryGetValue(role, out var sectionQuestionResponse))
        {
            return sectionQuestionResponse;
        }

        return new QuestionResponse { QuestionId = sectionId };
    }

    private QuestionResponse GetQuestionResponse(Guid sectionId)
    {
        if (!response.SectionResponses.TryGetValue(sectionId, out var sectionResponse))
            return new QuestionResponse { QuestionId = sectionId };

        // Determine which role's responses to fetch based on sectionData's CompletionRole
        // In read-only mode after review, managers view responses based on who originally completed the sectionData
        // Employees in post-review states also need to view responses based on sectionData's CompletionRole
        // After review meeting or when viewing employee-only questionnaires
        var isPostReviewState = assignment != null &&
            (assignment.WorkflowState is WorkflowState.ReviewFinished or
                                          WorkflowState.EmployeeReviewConfirmed or
                                          WorkflowState.Finalized);

        var isManagerViewingEmployeeOnlyQuestionnaire = isManager && template != null && !template.RequiresManagerReview;

        ResponseRole roleToFetch = CurrentResponseRole;

        if (isPostReviewState || isManagerViewingEmployeeOnlyQuestionnaire)
        {
            // In post-review states or when manager views employee-only questionnaire,
            // fetch responses based on sectionData's CompletionRole
            var sectionData = template?.Sections.FirstOrDefault(s => s.Id == sectionId);
            if (sectionData != null)
            {
                roleToFetch = sectionData.CompletionRole switch
                {
                    CompletionRole.Employee => ResponseRole.Employee,
                    CompletionRole.Manager => ResponseRole.Manager,
                    CompletionRole.Both => CurrentResponseRole,
                    _ => CurrentResponseRole
                };
            }
        }

        // Direct 2-level access
        if (sectionResponse.RoleResponses.TryGetValue(roleToFetch, out var sectionQuestionResponse))
        {
            return sectionQuestionResponse;
        }

        return new QuestionResponse { QuestionId = sectionId };
    }

    private ProgressBarStyle GetProgressStyle(int percentage)
    {
        return percentage switch
        {
            >= 90 => ProgressBarStyle.Success,
            >= 70 => ProgressBarStyle.Info,
            >= 50 => ProgressBarStyle.Warning,
            _ => ProgressBarStyle.Danger
        };
    }

    private string GetStatusStyle(int percentage)
    {
        var color = percentage switch
        {
            >= 90 => "background-color: var(--light-blue); border: 1px solid var(--success-color); color: var(--dark-blue);",
            >= 70 => "background-color: rgba(0, 230, 200, 0.1); border: 1px solid var(--success-color); color: var(--dark-blue);",
            >= 50 => "background-color: rgba(230, 191, 127, 0.2); border: 1px solid var(--golden-milk); color: var(--dark-blue);",
            _ => "background-color: rgba(240, 128, 128, 0.2); border: 1px solid var(--peach-kiss); color: var(--dark-blue);"
        };
        return color;
    }

    private string GetStatusIcon(int percentage)
    {
        return percentage switch
        {
            >= 90 => "check_circle",
            >= 70 => "task_alt",
            >= 50 => "warning",
            _ => "error"
        };
    }

    private string GetStatusText(int percentage)
    {
        return percentage switch
        {
            >= 90 => "Excellent Achievement",
            >= 70 => "Good Achievement", 
            >= 50 => "Partial Achievement",
            _ => "Below Expectations"
        };
    }

    // Navigation methods
    private void OnSectionChanged(int newIndex)
    {
        // In read-only mode, allow free navigation between all sections
        if (IsQuestionnaireCompleted())
        {
            if (HasParameterChanged(nameof(currentSectionIndex), newIndex))
            {
                currentSectionIndex = newIndex;
                NotifyStateChanged();
            }
            return;
        }

        // In edit mode, validate completion before allowing forward navigation
        if (newIndex < currentSectionIndex || CanProceedFromCurrentSection())
        {
            if (HasParameterChanged(nameof(currentSectionIndex), newIndex))
            {
                currentSectionIndex = newIndex;
                NotifyStateChanged();
            }
        }
        else
        {
            NotificationService.Notify(NotificationSeverity.Warning,
                "Complete sectionData",
                "Please complete all required questions in the current sectionData.");
        }
    }

    private void PreviousSection()
    {
        if (currentSectionIndex > 0)
        {
            currentSectionIndex--;
            NotifyStateChanged();
        }
    }

    private void NextSection()
    {
        // In read-only mode, allow navigation without validation
        if (IsQuestionnaireCompleted())
        {
            if (currentSectionIndex < visibleSections.Count - 1)
            {
                currentSectionIndex++;
                NotifyStateChanged();
            }
            return;
        }

        // In edit mode, validate completion before allowing navigation
        if (CanProceedFromCurrentSection() && currentSectionIndex < visibleSections.Count - 1)
        {
            currentSectionIndex++;
            UpdateProgress();
            NotifyStateChanged();
        }
    }

    private bool CanProceedFromCurrentSection()
    {
        if (currentSection == null) return true;

        if (!response.SectionResponses.TryGetValue(currentSection.Id, out var sectionResponse))
            return false;

        if (!sectionResponse.RoleResponses.TryGetValue(CurrentResponseRole, out var sectionQuestionResponse))
            return false;

        // Direct sectionData validation
        return IsSectionAnswered(currentSection, sectionQuestionResponse);
    }

    /// <summary>
    /// Checks if a Goal sectionData should be visible based on configuration.
    /// </summary>
    private bool ShouldShowGoalSection(QuestionSection sectionData)
    {
        if (sectionData.Type != QuestionType.Goal)
        {
            return true; // Not a goal sectionData, always show
        }

        if (sectionData.Configuration is GoalConfiguration config)
        {
            return config.ShowGoalSection;
        }

        return true; // Default to visible for backward compatibility
    }

    private bool IsSectionAnswered(QuestionSection sectionData, QuestionResponse sectionResponse)
    {
        return sectionData.Type switch
        {
            QuestionType.Assessment => IsAssessmentCompleted(sectionData, sectionResponse),
            QuestionType.TextQuestion => IsTextQuestionCompleted(sectionData, sectionResponse),
            QuestionType.Goal => true, // Goal questions never block submission (see comment below)
            _ => true
        };
    }

    // Note: Goal questions are designed to never block submission because:
    // 1. Empty goal sections are acceptable for submission
    // 2. Pending operations (PENDING ADD, PENDING EDIT, etc.) are stored in component local state,
    //    not in questionResponse data accessible here
    // 3. Goals can be added/modified during review phases after submission
    // 4. Users should not be prevented from progressing due to goal workflow states

    private bool IsTextQuestionCompleted(QuestionSection sectionData, QuestionResponse sectionResponse)
    {
        if (sectionData.Configuration is not TextQuestionConfiguration config)
            return false;

        var textSections = config.TextSections;
        if (textSections.Count == 0) return true;

        if (sectionResponse.ResponseData is not TextResponseDataDto textData)
        {
            // Invalid response data - check if section has any required items
            var requiredSections = textSections.Where(ts => ts.IsRequired).ToList();
            if (!requiredSections.Any())
            {
                return true; // No required text sections + invalid data = section complete
            }
            return false; // Has required text sections but invalid data = section incomplete
        }

        // Get only required text sections (works for single or multiple sections)
        var requiredTextSections = textSections.Where(ts => ts.IsRequired).ToList();

        // If no required text sections exist, section is automatically complete
        if (!requiredTextSections.Any())
        {
            return true; // Nothing required = automatically complete (matches domain logic)
        }

        // Check that ALL required text sections have non-empty values
        return requiredTextSections.All(ts =>
        {
            var index = textSections.IndexOf(ts);
            var hasValue = index < textData.TextSections.Count &&
                          !string.IsNullOrWhiteSpace(textData.TextSections[index]);
            return hasValue;
        });
    }

    private bool IsAssessmentCompleted(QuestionSection sectionData, QuestionResponse sectionResponse)
    {
        if (sectionData.Configuration is not AssessmentConfiguration config)
            return false;

        var evaluations = config.Evaluations;
        if (evaluations.Count == 0) return true;

        if (sectionResponse.ResponseData is not AssessmentResponseDataDto assessmentData)
        {
            // Invalid response data - check if section has any required items
            // If all evaluations are optional, invalid response data should not block submission
            var requiredEvals = evaluations.Where(c => c.IsRequired).ToList();
            if (!requiredEvals.Any())
            {
                return true; // No required evaluations + invalid data = section complete
            }
            return false; // Has required evaluations but invalid data = section incomplete
        }

        // Get only required evaluations
        var requiredEvaluations = evaluations.Where(c => c.IsRequired).ToList();

        // If no required evaluations exist, section is automatically complete
        if (!requiredEvaluations.Any())
        {
            return true; // Nothing required = automatically complete (matches domain logic)
        }

        // Check that ALL required evaluations have been rated
        return requiredEvaluations.All(c => HasEvaluationRating(assessmentData, c.Key));
    }

    private bool HasEvaluationRating(AssessmentResponseDataDto assessmentData, string evaluationKey)
    {
        if (assessmentData.Evaluations.TryGetValue(evaluationKey, out var evaluationRating))
        {
            return evaluationRating.Rating > 0;
        }
        return false;
    }

    private bool IsSectionCompleted(Guid sectionId)
    {
        if (!response.SectionResponses.TryGetValue(sectionId, out var sectionResponse))
            return false;

        if (!sectionResponse.RoleResponses.TryGetValue(CurrentResponseRole, out var sectionQuestionResponse))
            return false;

        var sectionData = template!.Sections.First(s => s.Id == sectionId);

        // Direct sectionData validation (no question iteration needed)
        return IsSectionAnswered(sectionData, sectionQuestionResponse);
    }

    private void UpdateProgress()
    {
        if (template == null) return;

        // Each sectionData IS one question - count all sections (template + custom)
        var allSections = GetAllSections();
        var totalSections = allSections.Count;
        var answeredSections = 0;

        foreach (var sectionData in allSections)
        {
            if (response.SectionResponses.TryGetValue(sectionData.Id, out var sectionResponse) &&
                sectionResponse.RoleResponses.TryGetValue(CurrentResponseRole, out var sectionQuestionResponse))
            {
                if (IsSectionAnswered(sectionData, sectionQuestionResponse))
                {
                    answeredSections++;
                }
            }
        }

        response.ProgressPercentage = totalSections > 0 ? (int)(answeredSections * 100.0 / totalSections) : 0;
    }

    private bool CanSubmit()
    {
        // If no visible sections, allow submission
        if (!visibleSections.Any()) return true;

        // Get all sections (template + custom sections)
        var allSections = GetAllSections();

        // Check only visible sections for current user role
        return visibleSections.All(s =>
        {
            var sectionData = allSections.FirstOrDefault(sec => sec.Id == s.Id);
            if (sectionData == null) return true;

            // Check if sectionData has response data
            if (!response.SectionResponses.TryGetValue(s.Id, out var sectionResponse))
            {
                // No response data exists - check if section has any required items
                return IsEmptySectionComplete(sectionData);
            }

            if (!sectionResponse.RoleResponses.TryGetValue(CurrentResponseRole, out var sectionQuestionResponse))
            {
                // No role-specific response exists - check if section has any required items
                return IsEmptySectionComplete(sectionData);
            }

            // ALWAYS validate items within the section (both required and optional sections)
            // This is critical: even optional sections must validate their required items if the user started filling them out
            return IsSectionAnswered(sectionData, sectionQuestionResponse);
        });
    }

    /// <summary>
    /// Determines if a section with no response data should be considered complete.
    /// A section is automatically complete if it has no required items.
    /// </summary>
    private bool IsEmptySectionComplete(QuestionSection sectionData)
    {
        return sectionData.Type switch
        {
            QuestionType.Assessment => IsAssessmentEmptyComplete(sectionData),
            QuestionType.TextQuestion => IsTextQuestionEmptyComplete(sectionData),
            QuestionType.Goal => true, // Goals never block submission
            _ => true
        };
    }

    /// <summary>
    /// Checks if an assessment section with no response data is complete (all evaluations are optional).
    /// </summary>
    private bool IsAssessmentEmptyComplete(QuestionSection sectionData)
    {
        if (sectionData.Configuration is not AssessmentConfiguration config)
            return true; // Invalid config = don't block submission

        var evaluations = config.Evaluations;
        if (evaluations.Count == 0) return true; // No evaluations = complete

        // If no evaluations are marked as required, the empty section is complete
        return !evaluations.Any(e => e.IsRequired);
    }

    /// <summary>
    /// Checks if a text question section with no response data is complete (all text sections are optional).
    /// </summary>
    private bool IsTextQuestionEmptyComplete(QuestionSection sectionData)
    {
        if (sectionData.Configuration is not TextQuestionConfiguration config)
            return true; // Invalid config = don't block submission

        var textSections = config.TextSections;
        if (textSections.Count == 0) return true; // No text sections = complete

        // If no text sections are marked as required, the empty section is complete
        return !textSections.Any(ts => ts.IsRequired);
    }

    private async Task SaveProgress()
    {
        if (!assignmentId.HasValue)
        {
            NotificationService.Notify(NotificationSeverity.Warning, "Cannot Save", "No assignment ID available");
            return;
        }

        // Prevent saving if questionnaire is in read-only state (uses WorkflowState logic)
        if (IsQuestionnaireCompleted())
        {
            NotificationService.Notify(NotificationSeverity.Warning, "Cannot Save", "This questionnaire is in read-only state and cannot be modified");
            return;
        }

        if (isSaving)
        {
            return; // Prevent double save
        }

        try
        {
            isSaving = true;
            StateHasChanged(); // Update UI to show saving state

            // Save any pending goal changes BEFORE saving question responses
            var goalsSaved = await SaveAllPendingGoalChanges();
            if (!goalsSaved)
            {
                NotificationService.Notify(NotificationSeverity.Warning, "Partial Save", "Some goal changes could not be saved. Other progress was saved successfully.");
            }

            if (isEmployee && !isManager)
            {
                await EmployeeQuestionnaireService.SaveMyResponseAsync(assignmentId.Value, response.SectionResponses, assignment?.TemplateId);
            }
            else if (isManager)
            {
                await ResponseService.SaveManagerResponseAsync(assignmentId.Value, response.SectionResponses, assignment?.TemplateId);
            }

            // Reload assignment to get updated workflow state and sectionData progress
            if (isManager)
            {
                assignment = await AssignmentService.GetAssignmentByIdAsync(assignmentId.Value);
            }
            else
            {
                assignment = await EmployeeQuestionnaireService.GetMyAssignmentByIdAsync(assignmentId.Value);
            }
            StateHasChanged(); // Force UI update with new workflow state

            NotificationService.Notify(NotificationSeverity.Success, "Saved", "Your progress has been saved successfully");
        }
        catch (Exception ex)
        {
            NotificationService.Notify(NotificationSeverity.Error, "Save Failed", $"Failed to save progress: {ex.Message}");
        }
        finally
        {
            isSaving = false;
            StateHasChanged(); // Reset UI state
        }
    }

    private async Task ShowReview()
    {
        if (!CanSubmit())
        {
            var allSections = GetAllSections();
            var incompleteSections = visibleSections.Where(s =>
            {
                var sectionData = allSections.FirstOrDefault(sec => sec.Id == s.Id);
                if (sectionData == null) return false;

                if (!response.SectionResponses.TryGetValue(s.Id, out var sectionResponse))
                    return true;

                if (!sectionResponse.RoleResponses.TryGetValue(CurrentResponseRole, out var sectionQuestionResponse))
                    return true;

                // Check if the sectionData is answered
                return !IsSectionAnswered(sectionData, sectionQuestionResponse);
            }).Select(s => s.GetLocalizedTitleWithFallback(CurrentLanguage)).ToList();

            var message = incompleteSections.Any()
                ? $"Please complete all required questions in: {string.Join(", ", incompleteSections)}"
                : "Please complete all required questions before reviewing";

            NotificationService.Notify(NotificationSeverity.Warning, "Incomplete", message);
            return;
        }

        // Show a confirmation dialog with review summary
        var confirmed = await DialogService.Confirm(
            $"You are about to submit your responses for '{template?.GetLocalizedNameWithFallback(CurrentLanguage)}'. Please review your answers before submitting. Do you want to continue?",
            "Submit",
            new ConfirmOptions
            {
                OkButtonText = "Submit",
                CancelButtonText = "Cancel",
                AutoFocusFirstElement = true
            });

        if (confirmed == true)
        {
            await SubmitQuestionnaire();
        }
    }

    private async Task SubmitQuestionnaire()
    {
        if (!CanSubmit())
        {
            NotificationService.Notify(NotificationSeverity.Warning, "Incomplete", "Please complete all required sections.");
            return;
        }

        if (!assignmentId.HasValue)
        {
            NotificationService.Notify(NotificationSeverity.Warning, "Cannot Submit", "No assignment ID available");
            return;
        }

        if (isSubmitting)
        {
            return; // Prevent double submission
        }

        try
        {
            isSubmitting = true;
            StateHasChanged();

            // Save any pending goal changes BEFORE saving question responses
            var goalsSaved = await SaveAllPendingGoalChanges();
            if (!goalsSaved)
            {
                NotificationService.Notify(NotificationSeverity.Error, "Cannot Submit", "Please ensure all goal changes are saved before submitting.");
                return;
            }

            if (isManager)
            {
                // Manager flow - backend automatically tracks sectionData completion during save
                await ResponseService.SaveManagerResponseAsync(assignmentId.Value, response.SectionResponses, assignment?.TemplateId);
                var submitSuccess = await AssignmentService.SubmitManagerQuestionnaireAsync(assignmentId.Value, currentUserName);

                if (submitSuccess)
                {
                    // Reload the assignment to get the updated WorkflowState
                    assignment = await AssignmentService.GetAssignmentByIdAsync(assignmentId.Value);
                    StateHasChanged(); // Force UI update with new workflow state

                    NotificationService.Notify(NotificationSeverity.Success, "Submitted", "Questionnaire submitted successfully!");
                    NavigationManager.NavigateTo("/team/questionnaires");
                }
                else
                {
                    NotificationService.Notify(NotificationSeverity.Error, "Submission Failed", "Failed to submit questionnaire");
                }
            }
            else
            {
                await EmployeeQuestionnaireService.SaveMyResponseAsync(assignmentId.Value, response.SectionResponses, assignment?.TemplateId);
                var submittedResponse = await EmployeeQuestionnaireService.SubmitMyResponseAsync(assignmentId.Value);

                if (submittedResponse != null)
                {
                    response = submittedResponse;

                    // Reload the assignment to get the updated WorkflowState
                    assignment = await EmployeeQuestionnaireService.GetMyAssignmentByIdAsync(assignmentId.Value);
                    StateHasChanged(); // Force UI update with new workflow state

                    NotificationService.Notify(NotificationSeverity.Success, "Submitted", "Questionnaire submitted successfully!");
                    NavigationManager.NavigateTo("/my-questionnaires");
                }
                else
                {
                    NotificationService.Notify(NotificationSeverity.Error, "Submission Failed", "Failed to submit questionnaire");
                }
            }
        }
        catch (Exception ex)
        {
            NotificationService.Notify(NotificationSeverity.Error, "Submission Failed", $"Failed to submit questionnaire: {ex.Message}");
        }
        finally
        {
            isSubmitting = false;
            StateHasChanged();
        }
    }


    private async Task OnWorkflowActionCompleted()
    {
        // Reload the assignment to get updated workflow state
        if (assignmentId.HasValue)
        {
            try
            {
                var previousState = assignment?.WorkflowState;

                if (isManager)
                {
                    assignment = await AssignmentService.GetAssignmentByIdAsync(assignmentId.Value);
                }
                else
                {
                    assignment = await EmployeeQuestionnaireService.GetMyAssignmentByIdAsync(assignmentId.Value);
                }

                StateHasChanged();

                // Navigate back to overview after completion actions
                if (assignment != null)
                {
                    var shouldNavigateBack = assignment.WorkflowState switch
                    {
                        // After manager finishes review meeting, take them back to team overview
                        WorkflowState.ReviewFinished when previousState == WorkflowState.InReview => true,
                        // After employee signs off, take them back to overview
                        WorkflowState.EmployeeReviewConfirmed when previousState == WorkflowState.ReviewFinished => true,
                        // After manager finalizes, take them back to overview
                        WorkflowState.Finalized when previousState == WorkflowState.EmployeeReviewConfirmed => true,
                        // Don't navigate for other state transitions (keep them on the questionnaire)
                        _ => false
                    };

                    if (shouldNavigateBack)
                    {
                        // Small delay to let the user see the success notification
                        await Task.Delay(2000);

                        // Navigate to appropriate overview based on user role
                        var targetRoute = isEmployeeOnly ? "/my-questionnaires" : "/team/questionnaires";
                        NavigationManager.NavigateTo(targetRoute);
                    }
                }
            }
            catch (Exception ex)
            {
                NotificationService.Notify(NotificationSeverity.Error, "Reload Error",
                    $"Failed to reload assignment: {ex.Message}");
            }
        }
    }

    private async Task OnReviewFinished()
    {
        // This callback is invoked by QuestionnaireReviewMode after successfully finishing the review
        // The API call has already been made by QuestionnaireReviewMode, so we just handle the navigation here
        if (!assignmentId.HasValue)
        {
            NotificationService.Notify(NotificationSeverity.Error, "Error", "No assignment ID available");
            return;
        }

        try
        {
            // Reload assignment to get updated workflow state and handle navigation
            await OnWorkflowActionCompleted();

            // Navigation is handled by OnWorkflowActionCompleted based on user role and workflow state
        }
        catch (Exception ex)
        {
            NotificationService.Notify(NotificationSeverity.Error, "Error", $"Failed to reload assignment: {ex.Message}");
        }
    }


    private bool IsManagerRole(string role)
    {
        return role == "TeamLead" || role == "HR" || role == "HRLead" || role == "Admin";
    }

    private ApplicationRole ParseApplicationRole(string roleString)
    {
        return roleString switch
        {
            "Employee" => ApplicationRole.Employee,
            "TeamLead" => ApplicationRole.TeamLead,
            "HR" => ApplicationRole.HR,
            "HRLead" => ApplicationRole.HRLead,
            "Admin" => ApplicationRole.Admin,
            _ => ApplicationRole.Employee // Default fallback
        };
    }

}