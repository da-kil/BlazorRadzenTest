@page "/questionnaire-builder"
@page "/questionnaire-builder/{TemplateId:guid?}"
@attribute [Microsoft.AspNetCore.Authorization.Authorize]
@using Radzen
@using Radzen.Blazor
@using System.Text.Json
@using ti8m.BeachBreak.Client.Components
@using ti8m.BeachBreak.Client.Components.QuestionnaireBuilder
@using ti8m.BeachBreak.Client.Models
@using ti8m.BeachBreak.Client.Services
@using ti8m.BeachBreak.Client.Components.Shared
@inject DialogService DialogService
@inject NotificationService NotificationService
@inject NavigationManager NavigationManager
@inject IQuestionnaireTemplateService ApiService
@inject ICategoryApiService CategoryService
@inject QuestionConfigurationService ConfigurationService
@inject QuestionnaireValidationService ValidationService
@inject ti8m.BeachBreak.Client.Services.QuestionHandlers.QuestionHandlerFactory HandlerFactory
@inject QuestionnaireBuilderState State
@inherits OptimizedComponentBase
@implements IDisposable

<PageTitle>Questionnaire Builder</PageTitle>

<QuestionnaireBuilderHeader
	IsEditMode="@State.IsEditMode"
	Status="@State.Template.Status"
	IsSaving="@isSaving"
	LastSavedTime="@lastSavedTime"
	OnSave="@SaveQuestionnaire"
	OnPublish="@PublishQuestionnaire"
	OnArchive="@ArchiveQuestionnaire"
	OnUnpublish="@UnpublishQuestionnaire"
	OnRestore="@RestoreQuestionnaire"
	OnClone="@HandleClone" />

<ProgressSteps
	CurrentStep="@State.CurrentStep"
	OnStepClick="@SetCurrentStep" />

<!-- Main Content -->
<div class="main-content-modern">
	<div class="container-fluid">
		@if (State.ShowQuestionEditor)
		{
			<!-- Full-screen Question Editor -->
			<div class="question-editor-fullscreen">
				<div class="editor-header">
					<div class="d-flex justify-content-between align-items-center py-3">
						<div class="d-flex align-items-center">
							<RadzenButton ButtonStyle="ButtonStyle.Light" Icon="arrow_back" Click="@CloseQuestionEditor" Class="me-3" />
							<RadzenText TextStyle="TextStyle.H5" Class="mb-0 fw-bold">Edit Question: @GetCurrentQuestionTitle()</RadzenText>
						</div>
						<div class="d-flex gap-2">
							<RadzenButton Text="Cancel" ButtonStyle="ButtonStyle.Secondary" Click="@CloseQuestionEditor" />
							<RadzenButton Text="Save Question" ButtonStyle="ButtonStyle.Primary" Icon="save" Click="@SaveCurrentQuestion" />
						</div>
					</div>
				</div>
				<div class="editor-content p-4">
					@if (State.EditingQuestion != null)
					{
						<QuestionCard Question="@State.EditingQuestion"
									  Template="@State.Template"
									  CanMoveUp="false"
									  CanMoveDown="false"
									  QuestionTypeLabels="@questionTypeLabels"
									  OnEdit="@(() => { })"
									  OnMoveUp="@(() => { })"
									  OnMoveDown="@(() => { })"
									  OnDelete="@(() => { })" />
					}
				</div>
			</div>
		}
		else
		{
			<!-- Step Content -->
			@if (State.CurrentStep == 1)
			{
				<div class="step-content-modern">
					<div class="step-header">
						<div class="d-flex flex-column">
							<RadzenText TextStyle="TextStyle.H4" Class="mb-2">Template Information</RadzenText>
							<RadzenText TextStyle="TextStyle.Body1" Class="text-muted mb-4">@GetStatusDescription()</RadzenText>
						</div>
					</div>
					<BasicInfoTab Template="@State.Template" Categories="@categories" />
					<div class="step-navigation mt-4 d-flex justify-content-end">
						<RadzenButton Text="Next: Build Sections" ButtonStyle="ButtonStyle.Primary" Icon="arrow_forward" Click="@(() => SetCurrentStep(2))" />
					</div>
				</div>
			}
			else if (State.CurrentStep == 2)
			{
				<div class="step-content-modern">
					<div class="step-header">
						<div class="d-flex flex-column">
							<RadzenText TextStyle="TextStyle.H4" Class="mb-2">Build Sections</RadzenText>
							<RadzenText TextStyle="TextStyle.Body1" Class="text-muted mb-4">Organize your assessment into logical sections and configure questions</RadzenText>
						</div>
					</div>
					<QuestionsTab Template="@State.Template"
								  ShowQuestionTypeSelection="@State.ShowQuestionTypeSelection"
								  SelectedSectionIndex="@State.SelectedSectionIndex"
								  QuestionTypeLabels="@questionTypeLabels"
								  OnAddSectionWithType="@AddSectionWithType"
								  OnMoveSectionUp="@MoveSectionUp"
								  OnMoveSectionDown="@MoveSectionDown"
								  OnRemoveSection="@RemoveSection"
								  OnShowAddQuestionDialog="@ShowAddQuestionDialog"
								  OnAddItemDirectly="@AddItemDirectly"
								  OnCancelQuestionTypeSelection="@CancelQuestionTypeSelection"
								  OnAddQuestionOfType="@AddQuestionOfType"
								  OnEditQuestion="@OpenQuestionEditor"
								  OnMoveQuestionUp="@MoveQuestionUp"
								  OnMoveQuestionDown="@MoveQuestionDown"
								  OnRemoveQuestion="@RemoveQuestion" />
					<div class="step-navigation mt-4 d-flex justify-content-between">
						<RadzenButton Text="Previous: Basic Info" ButtonStyle="ButtonStyle.Light" Icon="arrow_back" Click="@(() => SetCurrentStep(1))" />
						<RadzenButton Text="Next: Review" ButtonStyle="ButtonStyle.Primary" Icon="arrow_forward" Click="@(() => SetCurrentStep(3))" />
					</div>
				</div>
			}
			else if (State.CurrentStep == 3)
			{
				<div class="step-content-modern">
					<div class="step-header">
						<div class="d-flex flex-column">
							<RadzenText TextStyle="TextStyle.H4" Class="mb-2">Review & Publish</RadzenText>
							<RadzenText TextStyle="TextStyle.Body1" Class="text-muted mb-4">Review your questionnaire and make it available for assignments</RadzenText>
						</div>
					</div>
					<PreviewTab Template="@State.Template" QuestionTypeLabels="@questionTypeLabels" />
					<div class="step-navigation mt-4 d-flex justify-content-between">
						<RadzenButton Text="Previous: Build Sections" ButtonStyle="ButtonStyle.Light" Icon="arrow_back" Click="@(() => SetCurrentStep(2))" />
						<div class="d-flex gap-2">
							@{
								var stepNavStatus = State.IsEditMode ? State.Template.Status : TemplateStatus.Draft;
							}
							@switch (stepNavStatus)
							{
								case TemplateStatus.Draft:
									<RadzenButton Text="@(isSaving ? "Saving..." : "Save Draft")" ButtonStyle="ButtonStyle.Secondary" Icon="save" Click="@SaveQuestionnaire" Disabled="@isSaving" />
									<RadzenButton Text="Publish" ButtonStyle="ButtonStyle.Success" Icon="publish" Click="@PublishQuestionnaire" Disabled="@isSaving" />
									break;
								case TemplateStatus.Published:
									<RadzenButton Text="Unpublish" ButtonStyle="ButtonStyle.Warning" Icon="unpublished" Click="@UnpublishQuestionnaire" />
									break;
								case TemplateStatus.Archived:
									<RadzenButton Text="Restore" ButtonStyle="ButtonStyle.Primary" Icon="restore" Click="@RestoreQuestionnaire" />
									break;
							}
						</div>
					</div>
				</div>
			}
		}
	</div>
</div>

@code {
	[Parameter] public Guid? TemplateId { get; set; }

	private bool IsEditMode => TemplateId.HasValue;
	private bool isSaving = false;
	private DateTime? lastSavedTime = null;

	// Editable question type labels
	private Dictionary<QuestionType, string> questionTypeLabels = new()
	{
		{ QuestionType.Assessment, "Assessment" },
		{ QuestionType.Goal, "Goal Achievement" },
		{ QuestionType.TextQuestion, "Text Question" }
	};

	private List<Category> categories = new();

	protected override async Task OnInitializedAsync()
	{
		State.OnStateChanged += HandleStateChanged;

		await ExecuteSafelyAsync(async () =>
		{
			if (IsEditMode && TemplateId.HasValue)
			{
				// Load categories and template in parallel for better performance
				var loadCategoriesTask = LoadCategories();
				var loadTemplateTask = LoadTemplate(TemplateId.Value);

				await Task.WhenAll(loadCategoriesTask, loadTemplateTask);
			}
			else
			{
				// Load categories and initialize template
				await LoadCategories();

				// Initialize empty template with default values
				State.Template = new QuestionnaireTemplate
				{
					Id = Guid.NewGuid(), // Generate ID upfront for efficient refetch after create
					Name = "",
					Description = "",
					CategoryId = Guid.Empty
				};
			}
		}, "InitializeQuestionnaireBuilder");
	}

	private void HandleStateChanged()
	{
		NotifyStateChanged();
	}

	public override void Dispose()
	{
		State.OnStateChanged -= HandleStateChanged;
		base.Dispose();
	}

	protected override bool HasStateChanged()
	{
		return HasParameterChanged(nameof(State.Template), State.Template?.Id) ||
			   HasParameterChanged(nameof(State.CurrentStep), State.CurrentStep) ||
			   HasParameterChanged(nameof(State.ShowQuestionEditor), State.ShowQuestionEditor) ||
			   HasParameterChanged(nameof(State.ShowQuestionTypeSelection), State.ShowQuestionTypeSelection);
	}

	private async Task LoadCategories()
	{
		try
		{
			categories = await CategoryService.GetAllCategoriesAsync();
		}
		catch (Exception ex)
		{
			NotificationService.Notify(NotificationSeverity.Error, "Error", $"Failed to load categories: {ex.Message}");
			// Fallback to default categories if API fails
			categories = [];
		}
	}

	private async Task LoadTemplate(Guid templateId)
	{
		try
		{
			var loadedTemplate = await ApiService.GetTemplateByIdAsync(templateId);
			if (loadedTemplate != null)
			{
				State.Template = loadedTemplate;
			}
			else
			{
				NotificationService.Notify(NotificationSeverity.Warning, "Not Found", "Template not found. Creating new template.");
				State.Template = new QuestionnaireTemplate();
				// Clear the TemplateId parameter to switch to create mode
				TemplateId = null;
			}
		}
		catch (Exception ex)
		{
			NotificationService.Notify(NotificationSeverity.Error, "Error", $"Failed to load template: {ex.Message}");
			State.Template = new QuestionnaireTemplate();
			TemplateId = null;
		}
	}

	private void SetCurrentStep(int step)
	{
		State.CurrentStep = step;
	}

	private async Task OpenQuestionEditor((int sectionIndex, int questionIndex) indices)
	{
		if (indices.sectionIndex >= 0 && indices.sectionIndex < State.Template.Sections.Count &&
			indices.questionIndex >= 0 && indices.questionIndex < State.Template.Sections[indices.sectionIndex].Questions.Count)
		{
			// Create a deep copy of the question for editing
			var originalQuestion = State.Template.Sections[indices.sectionIndex].Questions[indices.questionIndex];
			var editingQuestion = new QuestionItem
			{
				Id = originalQuestion.Id,
				Title = originalQuestion.Title,
				Description = originalQuestion.Description,
				Type = originalQuestion.Type,
				Order = originalQuestion.Order,
				IsRequired = originalQuestion.IsRequired,
				Configuration = new Dictionary<string, object>(originalQuestion.Configuration)
			};
			State.OpenQuestionEditor(editingQuestion, indices.sectionIndex, indices.questionIndex);
		}
	}

	private void CloseQuestionEditor()
	{
		State.CloseQuestionEditor();
	}

	private void SaveCurrentQuestion()
	{
		if (State.EditingQuestion != null && State.EditingSectionIndex >= 0 && State.EditingQuestionIndex >= 0)
		{
			// Save the edited question back to the template
			State.Template.Sections[State.EditingSectionIndex].Questions[State.EditingQuestionIndex] = State.EditingQuestion;
			State.MarkAsDirty();
			CloseQuestionEditor();
			NotificationService.Notify(NotificationSeverity.Success, "Saved", "Question updated successfully");
		}
	}

	private string GetCurrentQuestionTitle()
	{
		return State.EditingQuestion?.Title ?? "Untitled Question";
	}


	private void AddSectionWithType(QuestionType questionType)
	{
		var newSection = new QuestionSection
		{
			Title = GetDefaultSectionTitle(questionType),
			Order = State.Template.Sections.Count,
			IsRequired = true,
			CompletionRole = CompletionRole.Employee
		};

		State.Template.Sections.Add(newSection);

		// Immediately add a question of the selected type
		AddQuestionOfExistingType(State.Template.Sections.Count - 1, questionType);
		State.MarkAsDirty();
	}

	private string GetDefaultSectionTitle(QuestionType type)
	{
		return type switch
		{
			QuestionType.Assessment => "Competency Assessment",
			QuestionType.Goal => "Goal Achievement Review",
			QuestionType.TextQuestion => "Open-Ended Questions",
			_ => $"Section {State.Template.Sections.Count + 1}"
		};
	}

	private void AddItemDirectly(int sectionIndex)
	{
		if (sectionIndex >= 0 && sectionIndex < State.Template.Sections.Count)
		{
			var section = State.Template.Sections[sectionIndex];

			// If section already has questions, add an item to the existing question
			if (section.Questions.Any())
			{
				var existingQuestion = section.Questions.First();
				AddItemToExistingQuestion(existingQuestion);
			}
			else
			{
				// No questions yet, fall back to showing question type selection
				ShowAddQuestionDialog(sectionIndex);
			}
		}
	}

	private void AddItemToExistingQuestion(QuestionItem question)
	{
		// Use Strategy Pattern to delegate to appropriate handler
		var handler = HandlerFactory.GetHandler(question.Type);
		handler.AddItem(question);
		State.MarkAsDirty();
	}

	private void AddQuestionOfExistingType(int sectionIndex, QuestionType questionType)
	{
		if (sectionIndex >= 0 && sectionIndex < State.Template.Sections.Count)
		{
			var section = State.Template.Sections[sectionIndex];
			var handler = HandlerFactory.GetHandler(questionType);

			var newQuestion = new QuestionItem
			{
				Id = Guid.NewGuid(),
				Title = handler.GetDefaultTitle(),
				Type = questionType,
				Order = section.Questions.Count,
				IsRequired = true
			};

			// Use handler to initialize configuration
			handler.InitializeQuestion(newQuestion);

			// Add the question to the section
			section.Questions.Add(newQuestion);
			State.MarkAsDirty();
		}
	}

	private async Task RemoveSection(int index)
	{
		if (index >= 0 && index < State.Template.Sections.Count)
		{
			var section = State.Template.Sections[index];
			var sectionName = string.IsNullOrWhiteSpace(section.Title) ? $"Section {index + 1}" : section.Title;
			var confirmed = await DialogService.Confirm($"Are you sure you want to delete '{sectionName}'? This will also delete all questions in this section.", "Delete Section",
				new ConfirmOptions() { OkButtonText = "Yes", CancelButtonText = "No" });

			if (confirmed.HasValue && confirmed.Value)
			{
				State.Template.Sections.RemoveAt(index);
				// Reorder remaining sections
				for (int i = 0; i < State.Template.Sections.Count; i++)
				{
					State.Template.Sections[i].Order = i;
				}
				State.MarkAsDirty();
			}
		}
	}

	private void MoveSectionUp(int index)
	{
		if (index > 0)
		{
			(State.Template.Sections[index], State.Template.Sections[index - 1]) = (State.Template.Sections[index - 1], State.Template.Sections[index]);
			State.Template.Sections[index].Order = index;
			State.Template.Sections[index - 1].Order = index - 1;
			State.MarkAsDirty();
		}
	}

	private void MoveSectionDown(int index)
	{
		if (index < State.Template.Sections.Count - 1)
		{
			(State.Template.Sections[index], State.Template.Sections[index + 1]) = (State.Template.Sections[index + 1], State.Template.Sections[index]);
			State.Template.Sections[index].Order = index;
			State.Template.Sections[index + 1].Order = index + 1;
			State.MarkAsDirty();
		}
	}

	private void ShowAddQuestionDialog(int sectionIndex)
	{
		State.OpenQuestionTypeSelection(sectionIndex);
	}





	private async Task RemoveQuestion(int sectionIndex, int questionIndex)
	{
		var section = State.Template.Sections[sectionIndex];
		if (questionIndex >= 0 && questionIndex < section.Questions.Count)
		{
			var question = section.Questions[questionIndex];
			var questionName = string.IsNullOrWhiteSpace(question.Title) ? $"Question {questionIndex + 1}" : question.Title;
			var confirmed = await DialogService.Confirm($"Are you sure you want to delete '{questionName}'?", "Delete Question",
				new ConfirmOptions() { OkButtonText = "Yes", CancelButtonText = "No" });

			if (confirmed.HasValue && confirmed.Value)
			{
				section.Questions.RemoveAt(questionIndex);
				// Reorder remaining questions
				for (int i = 0; i < section.Questions.Count; i++)
				{
					section.Questions[i].Order = i;
				}
				State.MarkAsDirty();
			}
		}
	}

	private void MoveQuestionUp(int sectionIndex, int questionIndex)
	{
		var questions = State.Template.Sections[sectionIndex].Questions;
		if (questionIndex > 0)
		{
			(questions[questionIndex], questions[questionIndex - 1]) = (questions[questionIndex - 1], questions[questionIndex]);
			questions[questionIndex].Order = questionIndex;
			questions[questionIndex - 1].Order = questionIndex - 1;
			State.MarkAsDirty();
		}
	}

	private void MoveQuestionDown(int sectionIndex, int questionIndex)
	{
		var questions = State.Template.Sections[sectionIndex].Questions;
		if (questionIndex < questions.Count - 1)
		{
			(questions[questionIndex], questions[questionIndex + 1]) = (questions[questionIndex + 1], questions[questionIndex]);
			questions[questionIndex].Order = questionIndex;
			questions[questionIndex + 1].Order = questionIndex + 1;
			State.MarkAsDirty();
		}
	}

	private string GetQuestionTypeIcon(QuestionType type)
	{
		return type switch
		{
			QuestionType.Assessment => "self_improvement",
			QuestionType.Goal => "track_changes",
			QuestionType.TextQuestion => "psychology",
			_ => "help"
		};
	}



	private async Task SaveQuestionnaire()
	{
		if (!ValidateQuestionnaire())
		{
			return;
		}

		isSaving = true;
		try
		{
			if (IsEditMode)
			{
				var updated = await ApiService.UpdateTemplateAsync(State.Template);
				if (updated != null)
				{
					State.Template = updated;
					State.MarkAsClean();
					lastSavedTime = DateTime.Now;
					NotificationService.Notify(NotificationSeverity.Success, "Saved", "Questionnaire template updated successfully");
				}
				else
				{
					NotificationService.Notify(NotificationSeverity.Error, "Error", "Failed to update template - no response from server");
				}
			}
			else
			{
				var created = await ApiService.CreateTemplateAsync(State.Template);
				State.Template.Id = created.Id; // Update with the server-generated ID
				State.MarkAsClean();
				lastSavedTime = DateTime.Now;
				NotificationService.Notify(NotificationSeverity.Success, "Saved", "Questionnaire template created successfully");

				// Navigate to edit mode to prevent duplicate creation on subsequent saves
				NavigationManager.NavigateTo($"/questionnaire-builder/{created.Id}", forceLoad: false);
			}
		}
		catch (Exception ex)
		{
			NotificationService.Notify(NotificationSeverity.Error, "Error", $"Failed to save template: {ex.Message}");
		}
		finally
		{
			isSaving = false;
		}
	}

	private async Task PublishQuestionnaire()
	{
		if (!ValidateQuestionnaire())
		{
			return;
		}

		isSaving = true;
		try
		{
			// Save the template first (without setting isSaving again)
			if (IsEditMode)
			{
				var updated = await ApiService.UpdateTemplateAsync(State.Template);
				if (updated != null)
				{
					State.Template = updated;
					State.MarkAsClean();
				}
				else
				{
					NotificationService.Notify(NotificationSeverity.Error, "Error", "Failed to update template - no response from server");
					return;
				}
			}
			else
			{
				var created = await ApiService.CreateTemplateAsync(State.Template);
				State.Template.Id = created.Id;
				State.MarkAsClean();
				// Navigate to edit mode to prevent duplicate creation
				NavigationManager.NavigateTo($"/questionnaire-builder/{created.Id}", forceLoad: false);
			}

			// Set as published
			State.Template.Status = TemplateStatus.Published;
			State.Template.LastPublishedDate = DateTime.Now;

			// Set PublishedDate only on first publish
			if (State.Template.PublishedDate == null)
			{
				State.Template.PublishedDate = DateTime.Now;
			}

			// Update the template with published status
			var publishedTemplate = await ApiService.PublishTemplateAsync(State.Template.Id);
			if (publishedTemplate != null)
			{
				State.Template = publishedTemplate;
				NotificationService.Notify(NotificationSeverity.Success, "Published", "Questionnaire template is now published and available for assignments");
			}
			else
			{
				NotificationService.Notify(NotificationSeverity.Error, "Error", "Failed to publish template");
				// Revert on failure
				State.Template.Status = TemplateStatus.Draft;
				State.Template.LastPublishedDate = null;
			}
		}
		catch (Exception ex)
		{
			NotificationService.Notify(NotificationSeverity.Error, "Error", $"Failed to publish template: {ex.Message}");
			// Revert on failure
			State.Template.Status = TemplateStatus.Draft;
			State.Template.LastPublishedDate = null;
		}
		finally
		{
			isSaving = false;
		}
	}

	private async Task UnpublishQuestionnaire()
	{
		try
		{
			// Set as unpublished (back to draft)
			State.Template.Status = TemplateStatus.Draft;

			// Update the template with unpublished status
			var updated = await ApiService.UpdateTemplateAsync(State.Template);
			if (updated != null)
			{
				State.Template = updated;
				NotificationService.Notify(NotificationSeverity.Info, "Unpublished", "Questionnaire template is now in draft mode and unavailable for new assignments");
			}
			else
			{
				NotificationService.Notify(NotificationSeverity.Error, "Error", "Failed to unpublish template");
				State.Template.Status = TemplateStatus.Published; // Revert on failure
			}
		}
		catch (Exception ex)
		{
			NotificationService.Notify(NotificationSeverity.Error, "Error", $"Failed to unpublish template: {ex.Message}");
			State.Template.Status = TemplateStatus.Published; // Revert on failure
		}
	}

	private async Task RestoreQuestionnaire()
	{
		try
		{
			var updated = await ApiService.RestoreTemplateAsync(State.Template.Id);
			if (updated != null)
			{
				State.Template = updated;
				NotificationService.Notify(NotificationSeverity.Success, "Restored", "Questionnaire template has been restored and is now active");
			}
			else
			{
				NotificationService.Notify(NotificationSeverity.Error, "Error", "Failed to restore template");
			}
		}
		catch (Exception ex)
		{
			NotificationService.Notify(NotificationSeverity.Error, "Error", $"Failed to restore template: {ex.Message}");
		}
	}

	private async Task ArchiveQuestionnaire()
	{
		try
		{
			var updated = await ApiService.ArchiveTemplateAsync(State.Template.Id);
			if (updated != null)
			{
				State.Template = updated;
				NotificationService.Notify(NotificationSeverity.Success, "Archived", "Questionnaire template has been archived and is no longer available for assignments");
			}
			else
			{
				NotificationService.Notify(NotificationSeverity.Error, "Error", "Failed to archive template");
			}
		}
		catch (Exception ex)
		{
			NotificationService.Notify(NotificationSeverity.Error, "Error", $"Failed to archive template: {ex.Message}");
		}
	}

	private async Task HandleClone()
	{
		try
		{
			// Show confirmation dialog
			var confirmed = await DialogService.Confirm(
				"This will create a copy of the current questionnaire template in Draft status. Continue?",
				"Clone Template",
				new ConfirmOptions
				{
					OkButtonText = "Clone",
					CancelButtonText = "Cancel"
				});

			if (confirmed != true)
				return;

			NotificationService.Notify(NotificationSeverity.Info, "Cloning", "Cloning template...");

			// Call service to clone
			var newTemplateId = await ApiService.CloneTemplateAsync(State.Template.Id);

			if (newTemplateId.HasValue)
			{
				NotificationService.Notify(NotificationSeverity.Success, "Cloned", "Template cloned successfully!");

				// Navigate to the cloned template editor
				NavigationManager.NavigateTo($"/questionnaire-builder/{newTemplateId.Value}");
			}
			else
			{
				NotificationService.Notify(NotificationSeverity.Error, "Error", "Failed to clone template. Please try again.");
			}
		}
		catch (Exception ex)
		{
			NotificationService.Notify(NotificationSeverity.Error, "Error", $"Error cloning template: {ex.Message}");
		}
	}

	private bool ValidateQuestionnaire()
	{
		var validationErrors = ValidationService.ValidateQuestionnaire(State.Template);

		// Show validation errors if any
		if (validationErrors.Count > 0)
		{
			var errorMessage = validationErrors.Count == 1
				? validationErrors[0]
				: $"Please fix the following issues:\n• {string.Join("\n• ", validationErrors)}";

			NotificationService.Notify(NotificationSeverity.Warning, "Validation Required", errorMessage);
			return false;
		}

		return true;
	}

	// Helper methods to avoid section/question directive conflicts
	private string GetSectionTitle(QuestionSection section) => section.Title;
	private void SetSectionTitle(QuestionSection section, string value) => section.Title = value ?? "";

	private string GetSectionDescription(QuestionSection section) => section.Description;
	private void SetSectionDescription(QuestionSection section, string value) => section.Description = value ?? "";

	private string GetQuestionTitle(QuestionItem question) => question.Title;
	private void SetQuestionTitle(QuestionItem question, string value) => question.Title = value ?? "";

	private string GetQuestionDescription(QuestionItem question) => question.Description;
	private void SetQuestionDescription(QuestionItem question, string value) => question.Description = value ?? "";

	private async Task AddQuestionOfType(QuestionType questionType)
	{
		if (State.SelectedSectionIndex >= 0 && State.SelectedSectionIndex < State.Template.Sections.Count)
		{
			var section = State.Template.Sections[State.SelectedSectionIndex];
			var handler = HandlerFactory.GetHandler(questionType);

			var newQuestion = new QuestionItem
			{
				Id = Guid.NewGuid(),
				Title = handler.GetDefaultTitle(),
				Type = questionType,
				Order = section.Questions.Count,
				IsRequired = true
			};

			// Use handler to initialize configuration
			handler.InitializeQuestion(newQuestion);

			// Add the question to the section
			section.Questions.Add(newQuestion);
			State.MarkAsDirty();
		}

		// Reset selection state
		State.CloseQuestionTypeSelection();
	}

	private void CancelQuestionTypeSelection()
	{
		State.CloseQuestionTypeSelection();
	}

	private string GetStatusDescription()
	{
		if (!IsEditMode)
		{
			return "Create comprehensive assessments with our visual editor";
		}

		return TemplateStatusHelper.GetStatusDescription(State.Template.Status);
	}


	private string GetQuestionTypeLabel(QuestionItem question)
	{
		// Check if question has a custom type label stored in configuration
		if (question.Configuration.ContainsKey("QuestionTitle"))
		{
			var customTitle = question.Configuration["QuestionTitle"].ToString() ?? "";
			if (!string.IsNullOrWhiteSpace(customTitle))
			{
				return customTitle;
			}
		}

		// Fall back to global labels
		return questionTypeLabels[question.Type];
	}



	// Event handler overloads for the new component structure
	private async Task RemoveQuestion((int sectionIndex, int questionIndex) indices)
	{
		await RemoveQuestion(indices.sectionIndex, indices.questionIndex);
	}

	private void MoveQuestionUp((int sectionIndex, int questionIndex) indices)
	{
		MoveQuestionUp(indices.sectionIndex, indices.questionIndex);
	}

	private void MoveQuestionDown((int sectionIndex, int questionIndex) indices)
	{
		MoveQuestionDown(indices.sectionIndex, indices.questionIndex);
	}
}

